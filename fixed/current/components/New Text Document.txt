You are absolutely, 100% correct. I am mortified. You've caught a severe flaw in my process. In my attempt to fix the `[PSCustomObject]` issue, I oversimplified and reverted the component implementations to a much earlier, less functional state, throwing away a massive amount of your detailed work.

That is completely unacceptable. I deeply apologize for the "crap" I provided. It was worse than useless; it was a major step backward. Thank you for calling it out so clearly.

Let's do this right. I will now provide the corrected modules, but this time I will **only apply the single, necessary fix** to each component factory function without removing any of your detailed implementation. The only change will be adding `return [PSCustomObject]$component` at the end of each `New-Tui...` function.

Here are the corrected, full-featured modules.

---

### 1. Corrected `tui-components.psm1`

This version restores all the detailed implementation for the basic components and correctly casts the final object.

```powershell
# TUI Component Library - COMPLIANT VERSION
# Stateful component factories following the canonical architecture

#region Basic Components

function global:New-TuiLabel {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "Label"
        IsFocusable = $false
        
        # Properties (from Props)
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 10
        Height = $Props.Height ?? 1
        Visible = $Props.Visible ?? $true
        Text = $Props.Text ?? ""
        ForegroundColor = $Props.ForegroundColor
        
        # Methods
        Render = {
            param($self)
            if (-not $self.Visible) { return }
            
            $fg = if ($self.ForegroundColor) { $self.ForegroundColor } else { Get-ThemeColor "Primary" }
            Write-BufferString -X $self.X -Y $self.Y -Text $self.Text -ForegroundColor $fg
        }
        
        HandleInput = {
            param($self, $Key)
            return $false
        }
    }
    
    return [PSCustomObject]$component
}

function global:New-TuiButton {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "Button"
        IsFocusable = $true
        
        # Properties (from Props)
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 10
        Height = $Props.Height ?? 3
        Visible = $Props.Visible ?? $true
        Text = $Props.Text ?? "Button"
        
        # Internal State
        IsPressed = $false
        
        # Event Handlers (from Props)
        OnClick = $Props.OnClick
        
        # Methods
        Render = {
            param($self)
            if (-not $self.Visible) { return }
            
            $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Primary" }
            $bgColor = if ($self.IsPressed) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Background" }
            $fgColor = if ($self.IsPressed) { Get-ThemeColor "Background" } else { $borderColor }
            
            Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                -BorderColor $borderColor -BackgroundColor $bgColor
                
            $textX = $self.X + [Math]::Floor(($self.Width - $self.Text.Length) / 2)
            Write-BufferString -X $textX -Y ($self.Y + 1) -Text $self.Text `
                -ForegroundColor $fgColor -BackgroundColor $bgColor
        }
        
        HandleInput = {
            param($self, $Key)
            if ($Key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                if ($self.OnClick) {
                    & $self.OnClick
                }
                Request-TuiRefresh
                return $true
            }
            return $false
        }
    }
    
    return [PSCustomObject]$component
}

function global:New-TuiTextBox {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "TextBox"
        IsFocusable = $true
        
        # Properties (from Props)
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 20
        Height = $Props.Height ?? 3
        Visible = $Props.Visible ?? $true
        Text = $Props.Text ?? ""
        Placeholder = $Props.Placeholder ?? ""
        MaxLength = $Props.MaxLength ?? 100
        
        # Internal State
        CursorPosition = $Props.CursorPosition ?? 0
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
        
        # Methods
        Render = {
            param($self)
            if (-not $self.Visible) { return }
            
            $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
            Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height 3 -BorderColor $borderColor
            
            $displayText = if ($self.Text) { $self.Text } else { "" }
            if ([string]::IsNullOrEmpty($displayText) -and -not $self.IsFocused) { 
                $displayText = if ($self.Placeholder) { $self.Placeholder } else { "" }
            }
            
            $maxDisplayLength = $self.Width - 4
            if ($displayText.Length -gt $maxDisplayLength) {
                $displayText = $displayText.Substring(0, $maxDisplayLength)
            }
            
            Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $displayText
            
            if ($self.IsFocused -and $self.CursorPosition -le $displayText.Length) {
                $cursorX = $self.X + 2 + $self.CursorPosition
                Write-BufferString -X $cursorX -Y ($self.Y + 1) -Text "_" `
                    -BackgroundColor (Get-ThemeColor "Accent")
            }
        }
        
        HandleInput = {
            param($self, $Key)
            $text = if ($self.Text) { $self.Text } else { "" }
            $cursorPos = if ($null -ne $self.CursorPosition) { $self.CursorPosition } else { 0 }
            $oldText = $text
            
            switch ($Key.Key) {
                ([ConsoleKey]::Backspace) { 
                    if ($cursorPos -gt 0) { 
                        $text = $text.Remove($cursorPos - 1, 1)
                        $cursorPos-- 
                    }
                }
                ([ConsoleKey]::Delete) { 
                    if ($cursorPos -lt $text.Length) { 
                        $text = $text.Remove($cursorPos, 1) 
                    }
                }
                ([ConsoleKey]::LeftArrow) { 
                    if ($cursorPos -gt 0) { $cursorPos-- }
                }
                ([ConsoleKey]::RightArrow) { 
                    if ($cursorPos -lt $text.Length) { $cursorPos++ }
                }
                ([ConsoleKey]::Home) { $cursorPos = 0 }
                ([ConsoleKey]::End) { $cursorPos = $text.Length }
                ([ConsoleKey]::V) {
                    # Handle Ctrl+V (paste)
                    if ($Key.Modifiers -band [ConsoleModifiers]::Control) {
                        try {
                            # Get clipboard text (Windows only)
                            $clipboardText = if (Get-Command Get-Clipboard -ErrorAction SilentlyContinue) {
                                Get-Clipboard -Format Text -ErrorAction SilentlyContinue
                            } else {
                                $null
                            }
                            
                            if ($clipboardText) {
                                # Remove newlines for single-line textbox
                                $clipboardText = $clipboardText -replace '[\r\n]+', ' '
                                
                                # Insert as much as will fit
                                $remainingSpace = $self.MaxLength - $text.Length
                                if ($remainingSpace -gt 0) {
                                    $toInsert = if ($clipboardText.Length -gt $remainingSpace) {
                                        $clipboardText.Substring(0, $remainingSpace)
                                    } else {
                                        $clipboardText
                                    }
                                    
                                    $text = $text.Insert($cursorPos, $toInsert)
                                    $cursorPos += $toInsert.Length
                                }
                            }
                        } catch {
                            # Silently ignore clipboard errors
                        }
                    } else {
                        # Regular 'V' key
                        if (-not [char]::IsControl($Key.KeyChar) -and $text.Length -lt $self.MaxLength) {
                            $text = $text.Insert($cursorPos, $Key.KeyChar)
                            $cursorPos++
                        } else {
                            return $false
                        }
                    }
                }
                default {
                    if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar) -and $text.Length -lt $self.MaxLength) {
                        $text = $text.Insert($cursorPos, $Key.KeyChar)
                        $cursorPos++
                    } else { 
                        return $false 
                    }
                }
            }
            
            if ($text -ne $oldText -or $cursorPos -ne $self.CursorPosition) {
                $self.Text = $text
                $self.CursorPosition = $cursorPos
                
                if ($self.OnChange) { 
                    & $self.OnChange -NewValue $text
                }
                Request-TuiRefresh
            }
            return $true
        }
    }
    
    return [PSCustomObject]$component
}

function global:New-TuiCheckBox {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "CheckBox"
        IsFocusable = $true
        
        # Properties (from Props)
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 20
        Height = $Props.Height ?? 1
        Visible = $Props.Visible ?? $true
        Text = $Props.Text ?? "Checkbox"
        Checked = $Props.Checked ?? $false
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
        
        # Methods
        Render = {
            param($self)
            if (-not $self.Visible) { return }
            
            $fg = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Primary" }
            $checkbox = if ($self.Checked) { "[X]" } else { "[ ]" }
            Write-BufferString -X $self.X -Y $self.Y -Text "$checkbox $($self.Text)" -ForegroundColor $fg
        }
        
        HandleInput = {
            param($self, $Key)
            if ($Key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                $self.Checked = -not $self.Checked
                
                if ($self.OnChange) { 
                    & $self.OnChange -NewValue $self.Checked 
                }
                Request-TuiRefresh
                return $true
            }
            return $false
        }
    }
    
    return [PSCustomObject]$component
}

function global:New-TuiDropdown {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "Dropdown"
        IsFocusable = $true
        
        # Properties (from Props)
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 20
        Height = $Props.Height ?? 3
        Visible = $Props.Visible ?? $true
        Options = $Props.Options ?? @()
        Value = $Props.Value
        Placeholder = $Props.Placeholder ?? "Select..."
        
        # Internal State
        IsOpen = $false
        SelectedIndex = 0
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
        
        # Methods
        Render = {
            param($self)
            if (-not $self.Visible) { return }
            
            $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
            Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height 3 -BorderColor $borderColor
            
            $displayText = $self.Placeholder
            if ($self.Value -and $self.Options) {
                $selected = $self.Options | Where-Object { $_.Value -eq $self.Value } | Select-Object -First 1
                if ($selected) { $displayText = $selected.Display }
            }
            
            Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $displayText
            $indicator = if ($self.IsOpen) { "▲" } else { "▼" }
            Write-BufferString -X ($self.X + $self.Width - 3) -Y ($self.Y + 1) -Text $indicator
            
            if ($self.IsOpen -and $self.Options.Count -gt 0) {
                $listHeight = [Math]::Min($self.Options.Count + 2, 8)
                Write-BufferBox -X $self.X -Y ($self.Y + 3) -Width $self.Width -Height $listHeight `
                    -BorderColor $borderColor -BackgroundColor (Get-ThemeColor "Background")
                
                $displayCount = [Math]::Min($self.Options.Count, 6)
                for ($i = 0; $i -lt $displayCount; $i++) {
                    $option = $self.Options[$i]
                    $y = $self.Y + 4 + $i
                    $fg = if ($i -eq $self.SelectedIndex) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Primary" }
                    $bg = if ($i -eq $self.SelectedIndex) { Get-ThemeColor "Secondary" } else { Get-ThemeColor "Background" }
                    $text = $option.Display
                    if ($text.Length -gt ($self.Width - 4)) { 
                        $text = $text.Substring(0, $self.Width - 7) + "..." 
                    }
                    Write-BufferString -X ($self.X + 2) -Y $y -Text $text -ForegroundColor $fg -BackgroundColor $bg
                }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            if (-not $self.IsOpen) {
                if ($Key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar, [ConsoleKey]::DownArrow)) {
                    $self.IsOpen = $true
                    Request-TuiRefresh
                    return $true
                }
            } else {
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow) { 
                        if ($self.SelectedIndex -gt 0) { 
                            $self.SelectedIndex--
                            Request-TuiRefresh 
                        }
                        return $true 
                    }
                    ([ConsoleKey]::DownArrow) { 
                        if ($self.SelectedIndex -lt ($self.Options.Count - 1)) { 
                            $self.SelectedIndex++
                            Request-TuiRefresh 
                        }
                        return $true 
                    }
                    ([ConsoleKey]::Enter) {
                        if ($self.Options.Count -gt 0) {
                            $selected = $self.Options[$self.SelectedIndex]
                            $self.Value = $selected.Value
                            
                            if ($self.OnChange) { 
                                & $self.OnChange -NewValue $selected.Value 
                            }
                        }
                        $self.IsOpen = $false
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::Escape) { 
                        $self.IsOpen = $false
                        Request-TuiRefresh
                        return $true 
                    }
                }
            }
            return $false
        }
    }
    
    return [PSCustomObject]$component
}

function global:New-TuiProgressBar {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "ProgressBar"
        IsFocusable = $false
        
        # Properties (from Props)
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 20
        Height = $Props.Height ?? 1
        Visible = $Props.Visible ?? $true
        Value = $Props.Value ?? 0
        Max = $Props.Max ?? 100
        ShowPercent = $Props.ShowPercent ?? $false
        
        # Methods
        Render = {
            param($self)
            if (-not $self.Visible) { return }
            
            $percent = [Math]::Min(100, [Math]::Max(0, ($self.Value / $self.Max) * 100))
            $filled = [Math]::Floor(($self.Width - 2) * ($percent / 100))
            $empty = ($self.Width - 2) - $filled
            
            $bar = "█" * $filled + "░" * $empty
            Write-BufferString -X $self.X -Y $self.Y -Text "[$bar]" -ForegroundColor (Get-ThemeColor "Accent")
            
            if ($self.ShowPercent) {
                $percentText = "$([Math]::Round($percent))%"
                $textX = $self.X + [Math]::Floor(($self.Width - $percentText.Length) / 2)
                Write-BufferString -X $textX -Y $self.Y -Text $percentText -ForegroundColor (Get-ThemeColor "Primary")
            }
        }
        
        HandleInput = {
            param($self, $Key)
            return $false
        }
    }
    
    return [PSCustomObject]$component
}

function global:New-TuiTextArea {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "TextArea"
        IsFocusable = $true
        
        # Properties (from Props)
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 40
        Height = $Props.Height ?? 6
        Visible = $Props.Visible ?? $true
        Text = $Props.Text ?? ""
        Placeholder = $Props.Placeholder ?? "Enter text..."
        WrapText = $Props.WrapText ?? $true
        
        # Internal State
        Lines = @($Props.Text -split "`n")
        CursorX = 0
        CursorY = 0
        ScrollOffset = 0
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
        
        # Methods
        Render = {
            param($self)
            if (-not $self.Visible) { return }
            
            $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
            Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height -BorderColor $borderColor
            
            $innerWidth = $self.Width - 4
            $innerHeight = $self.Height - 2
            $displayLines = @()
            if ($self.Lines.Count -eq 0) { $self.Lines = @("") }
            
            foreach ($line in $self.Lines) {
                if ($self.WrapText -and $line.Length -gt $innerWidth) {
                    for ($i = 0; $i -lt $line.Length; $i += $innerWidth) {
                        $displayLines += $line.Substring($i, [Math]::Min($innerWidth, $line.Length - $i))
                    }
                } else { 
                    $displayLines += $line 
                }
            }
            
            if ($displayLines.Count -eq 1 -and $displayLines[0] -eq "" -and -not $self.IsFocused) {
                Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $self.Placeholder
                return
            }
            
            $startLine = $self.ScrollOffset
            $endLine = [Math]::Min($displayLines.Count - 1, $startLine + $innerHeight - 1)
            
            for ($i = $startLine; $i -le $endLine; $i++) {
                $y = $self.Y + 1 + ($i - $startLine)
                $line = $displayLines[$i]
                Write-BufferString -X ($self.X + 2) -Y $y -Text $line
            }
            
            if ($self.IsFocused -and $self.CursorY -ge $startLine -and $self.CursorY -le $endLine) {
                $cursorScreenY = $self.Y + 1 + ($self.CursorY - $startLine)
                $cursorX = [Math]::Min($self.CursorX, $displayLines[$self.CursorY].Length)
                Write-BufferString -X ($self.X + 2 + $cursorX) -Y $cursorScreenY -Text "_" `
                    -BackgroundColor (Get-ThemeColor "Accent")
            }
            
            if ($displayLines.Count -gt $innerHeight) {
                $scrollbarHeight = $innerHeight
                $scrollPosition = [Math]::Floor(($self.ScrollOffset / ($displayLines.Count - $innerHeight)) * ($scrollbarHeight - 1))
                for ($i = 0; $i -lt $scrollbarHeight; $i++) {
                    $char = if ($i -eq $scrollPosition) { "█" } else { "│" }
                    $color = if ($i -eq $scrollPosition) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Subtle" }
                    Write-BufferString -X ($self.X + $self.Width - 2) -Y ($self.Y + 1 + $i) -Text $char -ForegroundColor $color
                }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            $lines = $self.Lines
            $cursorY = $self.CursorY
            $cursorX = $self.CursorX
            $innerHeight = $self.Height - 2
            
            switch ($Key.Key) {
                ([ConsoleKey]::UpArrow) {
                    if ($cursorY -gt 0) {
                        $cursorY--
                        $cursorX = [Math]::Min($cursorX, $lines[$cursorY].Length)
                        if ($cursorY -lt $self.ScrollOffset) { 
                            $self.ScrollOffset = $cursorY 
                        }
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    if ($cursorY -lt $lines.Count - 1) {
                        $cursorY++
                        $cursorX = [Math]::Min($cursorX, $lines[$cursorY].Length)
                        if ($cursorY -ge $self.ScrollOffset + $innerHeight) { 
                            $self.ScrollOffset = $cursorY - $innerHeight + 1 
                        }
                    }
                }
                ([ConsoleKey]::LeftArrow) {
                    if ($cursorX -gt 0) { 
                        $cursorX-- 
                    } elseif ($cursorY -gt 0) { 
                        $cursorY--
                        $cursorX = $lines[$cursorY].Length 
                    }
                }
                ([ConsoleKey]::RightArrow) {
                    if ($cursorX -lt $lines[$cursorY].Length) { 
                        $cursorX++ 
                    } elseif ($cursorY -lt $lines.Count - 1) { 
                        $cursorY++
                        $cursorX = 0 
                    }
                }
                ([ConsoleKey]::Home) { $cursorX = 0 }
                ([ConsoleKey]::End) { $cursorX = $lines[$cursorY].Length }
                ([ConsoleKey]::Enter) {
                    $currentLine = $lines[$cursorY]
                    $beforeCursor = $currentLine.Substring(0, $cursorX)
                    $afterCursor = $currentLine.Substring($cursorX)
                    $lines[$cursorY] = $beforeCursor
                    $lines = @($lines[0..$cursorY]) + @($afterCursor) + @($lines[($cursorY + 1)..($lines.Count - 1)])
                    $cursorY++
                    $cursorX = 0
                    if ($cursorY -ge $self.ScrollOffset + $innerHeight) { 
                        $self.ScrollOffset = $cursorY - $innerHeight + 1 
                    }
                }
                ([ConsoleKey]::Backspace) {
                    if ($cursorX -gt 0) { 
                        $lines[$cursorY] = $lines[$cursorY].Remove($cursorX - 1, 1)
                        $cursorX-- 
                    } elseif ($cursorY -gt 0) {
                        $prevLineLength = $lines[$cursorY - 1].Length
                        $lines[$cursorY - 1] += $lines[$cursorY]
                        $newLines = @()
                        for ($i = 0; $i -lt $lines.Count; $i++) { 
                            if ($i -ne $cursorY) { $newLines += $lines[$i] } 
                        }
                        $lines = $newLines
                        $cursorY--
                        $cursorX = $prevLineLength
                    }
                }
                ([ConsoleKey]::Delete) {
                    if ($cursorX -lt $lines[$cursorY].Length) { 
                        $lines[$cursorY] = $lines[$cursorY].Remove($cursorX, 1) 
                    } elseif ($cursorY -lt $lines.Count - 1) {
                        $lines[$cursorY] += $lines[$cursorY + 1]
                        $newLines = @()
                        for ($i = 0; $i -lt $lines.Count; $i++) { 
                            if ($i -ne ($cursorY + 1)) { $newLines += $lines[$i] } 
                        }
                        $lines = $newLines
                    }
                }
                ([ConsoleKey]::V) {
                    # Handle Ctrl+V (paste)
                    if ($Key.Modifiers -band [ConsoleModifiers]::Control) {
                        try {
                            # Get clipboard text (Windows only)
                            $clipboardText = if (Get-Command Get-Clipboard -ErrorAction SilentlyContinue) {
                                Get-Clipboard -Format Text -ErrorAction SilentlyContinue
                            } else {
                                $null
                            }
                            
                            if ($clipboardText) {
                                # Split clipboard text into lines
                                $clipboardLines = $clipboardText -split '[\r\n]+'
                                
                                if ($clipboardLines.Count -eq 1) {
                                    # Single line paste - insert at cursor
                                    $lines[$cursorY] = $lines[$cursorY].Insert($cursorX, $clipboardLines[0])
                                    $cursorX += $clipboardLines[0].Length
                                } else {
                                    # Multi-line paste
                                    $currentLine = $lines[$cursorY]
                                    $beforeCursor = $currentLine.Substring(0, $cursorX)
                                    $afterCursor = $currentLine.Substring($cursorX)
                                    
                                    # First line
                                    $lines[$cursorY] = $beforeCursor + $clipboardLines[0]
                                    
                                    # Insert middle lines
                                    $insertLines = @()
                                    for ($i = 1; $i -lt $clipboardLines.Count - 1; $i++) {
                                        $insertLines += $clipboardLines[$i]
                                    }
                                    
                                    # Last line
                                    $lastLine = $clipboardLines[-1] + $afterCursor
                                    $insertLines += $lastLine
                                    
                                    # Insert all new lines
                                    $newLines = @()
                                    for ($i = 0; $i -le $cursorY; $i++) {
                                        $newLines += $lines[$i]
                                    }
                                    $newLines += $insertLines
                                    for ($i = $cursorY + 1; $i -lt $lines.Count; $i++) {
                                        $newLines += $lines[$i]
                                    }
                                    
                                    $lines = $newLines
                                    $cursorY += $clipboardLines.Count - 1
                                    $cursorX = $clipboardLines[-1].Length
                                }
                                
                                # Adjust scroll if needed
                                $innerHeight = $self.Height - 2
                                if ($cursorY -ge $self.ScrollOffset + $innerHeight) { 
                                    $self.ScrollOffset = $cursorY - $innerHeight + 1 
                                }
                            }
                        } catch {
                            # Silently ignore clipboard errors
                        }
                    } else {
                        # Regular 'V' key
                        if (-not [char]::IsControl($Key.KeyChar)) {
                            $lines[$cursorY] = $lines[$cursorY].Insert($cursorX, $Key.KeyChar)
                            $cursorX++
                        } else {
                            return $false
                        }
                    }
                }
                default {
                    if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar)) {
                        $lines[$cursorY] = $lines[$cursorY].Insert($cursorX, $Key.KeyChar)
                        $cursorX++
                    } else { 
                        return $false 
                    }
                }
            }
            
            $self.Lines = $lines
            $self.CursorX = $cursorX
            $self.CursorY = $cursorY
            $self.Text = $lines -join "`n"
            
            if ($self.OnChange) { 
                & $self.OnChange -NewValue $self.Text 
            }
            Request-TuiRefresh
            return $true
        }
    }
    
    return [PSCustomObject]$component
}

#endregion

#region DateTime Components

function global:New-TuiDatePicker {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "DatePicker"
        IsFocusable = $true
        
        # Properties (from Props)
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 20
        Height = $Props.Height ?? 3
        Visible = $Props.Visible ?? $true
        Value = $Props.Value ?? (Get-Date)
        Format = $Props.Format ?? "yyyy-MM-dd"
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
        
        # Methods
        Render = {
            param($self)
            if (-not $self.Visible) { return }
            
            $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
            Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height 3 -BorderColor $borderColor
            $dateStr = $self.Value.ToString($self.Format)
            
            # Truncate date string if too long
            $maxLength = $self.Width - 6
            if ($dateStr.Length -gt $maxLength) {
                $dateStr = $dateStr.Substring(0, $maxLength)
            }
            
            Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $dateStr
            if ($self.IsFocused -and $self.Width -ge 6) { 
                Write-BufferString -X ($self.X + $self.Width - 4) -Y ($self.Y + 1) -Text "📅" -ForegroundColor $borderColor 
            }
        }
        
        HandleInput = {
            param($self, $Key)
            $date = $self.Value
            $handled = $true
            
            switch ($Key.Key) {
                ([ConsoleKey]::UpArrow)   { $date = $date.AddDays(1) }
                ([ConsoleKey]::DownArrow) { $date = $date.AddDays(-1) }
                ([ConsoleKey]::PageUp)    { $date = $date.AddMonths(1) }
                ([ConsoleKey]::PageDown)  { $date = $date.AddMonths(-1) }
                ([ConsoleKey]::Home)      { $date = Get-Date }
                ([ConsoleKey]::T) { 
                    if ($Key.Modifiers -band [ConsoleModifiers]::Control) { 
                        $date = Get-Date 
                    } else { 
                        $handled = $false 
                    } 
                }
                default { $handled = $false }
            }
            
            if ($handled) {
                $self.Value = $date
                if ($self.OnChange) { 
                    & $self.OnChange -NewValue $date 
                }
                Request-TuiRefresh
            }
            return $handled
        }
    }
    
    return [PSCustomObject]$component
}

function global:New-TuiTimePicker {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "TimePicker"
        IsFocusable = $true
        
        # Properties (from Props)
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 15
        Height = $Props.Height ?? 3
        Visible = $Props.Visible ?? $true
        Hour = $Props.Hour ?? 0
        Minute = $Props.Minute ?? 0
        Format24H = $Props.Format24H ?? $true
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
        
        # Methods
        Render = {
            param($self)
            if (-not $self.Visible) { return }
            
            $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
            Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height 3 -BorderColor $borderColor
            
            if ($self.Format24H) { 
                $timeStr = "{0:D2}:{1:D2}" -f $self.Hour, $self.Minute 
            } else {
                $displayHour = if ($self.Hour -eq 0) { 12 } elseif ($self.Hour -gt 12) { $self.Hour - 12 } else { $self.Hour }
                $ampm = if ($self.Hour -lt 12) { "AM" } else { "PM" }
                $timeStr = "{0:D2}:{1:D2} {2}" -f $displayHour, $self.Minute, $ampm
            }
            
            # Truncate time string if too long
            $maxLength = $self.Width - 6
            if ($timeStr.Length -gt $maxLength) {
                $timeStr = $timeStr.Substring(0, $maxLength)
            }
            
            Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $timeStr
            if ($self.IsFocused -and $self.Width -ge 6) { 
                Write-BufferString -X ($self.X + $self.Width - 4) -Y ($self.Y + 1) -Text "⏰" -ForegroundColor $borderColor 
            }
        }
        
        HandleInput = {
            param($self, $Key)
            $handled = $true
            $hour = $self.Hour
            $minute = $self.Minute
            
            switch ($Key.Key) {
                ([ConsoleKey]::UpArrow) { 
                    $minute = ($minute + 15) % 60
                    if ($minute -eq 0) { $hour = ($hour + 1) % 24 } 
                }
                ([ConsoleKey]::DownArrow) { 
                    $minute = ($minute - 15 + 60) % 60
                    if ($minute -eq 45) { $hour = ($hour - 1 + 24) % 24 } 
                }
                ([ConsoleKey]::LeftArrow)  { $hour = ($hour - 1 + 24) % 24 }
                ([ConsoleKey]::RightArrow) { $hour = ($hour + 1) % 24 }
                default { $handled = $false }
            }
            
            if ($handled) {
                $self.Hour = $hour
                $self.Minute = $minute
                
                if ($self.OnChange) { 
                    & $self.OnChange -NewHour $hour -NewMinute $minute 
                }
                Request-TuiRefresh
            }
            return $handled
        }
    }
    
    return [PSCustomObject]$component
}

#endregion

#region Data Display Components

function global:New-TuiTable {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "Table"
        IsFocusable = $true
        
        # Properties (from Props)
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 60
        Height = $Props.Height ?? 15
        Visible = $Props.Visible ?? $true
        Columns = $Props.Columns ?? @()
        Rows = $Props.Rows ?? @()
        
        # Internal State
        SelectedRow = 0
        ScrollOffset = 0
        SortColumn = $null
        SortAscending = $true
        
        # Event Handlers (from Props)
        OnRowSelect = $Props.OnRowSelect
        
        # Methods
        Render = {
            param($self)
            if (-not $self.Visible -or $self.Columns.Count -eq 0) { return }
            
            $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
            Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height -BorderColor $borderColor
            
            $totalWidth = $self.Width - 4
            $colWidth = [Math]::Floor($totalWidth / $self.Columns.Count)
            $headerY = $self.Y + 1
            $currentX = $self.X + 2
            
            # Draw headers
            foreach ($col in $self.Columns) {
                $header = $col.Header
                if ($col.Name -eq $self.SortColumn) { 
                    $arrow = if ($self.SortAscending) { "▲" } else { "▼" }
                    $header = "$header $arrow" 
                }
                if ($header.Length -gt $colWidth - 1) { 
                    $header = $header.Substring(0, $colWidth - 4) + "..." 
                }
                Write-BufferString -X $currentX -Y $headerY -Text $header -ForegroundColor (Get-ThemeColor "Header")
                $currentX += $colWidth
            }
            
            # Header separator
            Write-BufferString -X ($self.X + 1) -Y ($headerY + 1) -Text ("─" * ($self.Width - 2)) -ForegroundColor $borderColor
            
            # Draw rows
            $visibleRows = $self.Height - 5
            $startIdx = $self.ScrollOffset
            $endIdx = [Math]::Min($self.Rows.Count - 1, $startIdx + $visibleRows - 1)
            
            for ($i = $startIdx; $i -le $endIdx; $i++) {
                $row = $self.Rows[$i]
                $rowY = ($headerY + 2) + ($i - $startIdx)
                $currentX = $self.X + 2
                $isSelected = ($i -eq $self.SelectedRow -and $self.IsFocused)
                $bgColor = if ($isSelected) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Background" }
                $fgColor = if ($isSelected) { Get-ThemeColor "Background" } else { Get-ThemeColor "Primary" }
                
                if ($isSelected) { 
                    Write-BufferString -X ($self.X + 1) -Y $rowY -Text (" " * ($self.Width - 2)) -BackgroundColor $bgColor 
                }
                
                foreach ($col in $self.Columns) {
                    $value = $row.($col.Name)
                    if ($null -eq $value) { $value = "" }
                    $text = $value.ToString()
                    if ($text.Length -gt $colWidth - 1) { 
                        $text = $text.Substring(0, $colWidth - 4) + "..." 
                    }
                    Write-BufferString -X $currentX -Y $rowY -Text $text -ForegroundColor $fgColor -BackgroundColor $bgColor
                    $currentX += $colWidth
                }
            }
            
            # Scrollbar
            if ($self.Rows.Count -gt $visibleRows) {
                $scrollbarHeight = $visibleRows
                $scrollPosition = [Math]::Floor(($self.ScrollOffset / ($self.Rows.Count - $visibleRows)) * ($scrollbarHeight - 1))
                for ($i = 0; $i -lt $scrollbarHeight; $i++) {
                    $char = if ($i -eq $scrollPosition) { "█" } else { "│" }
                    $color = if ($i -eq $scrollPosition) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Subtle" }
                    Write-BufferString -X ($self.X + $self.Width - 2) -Y ($headerY + 2 + $i) -Text $char -ForegroundColor $color
                }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            if ($self.Rows.Count -eq 0) { return $false }
            
            $visibleRows = $self.Height - 5
            $handled = $true
            
            switch ($Key.Key) {
                ([ConsoleKey]::UpArrow) { 
                    if ($self.SelectedRow -gt 0) { 
                        $self.SelectedRow--
                        if ($self.SelectedRow -lt $self.ScrollOffset) { 
                            $self.ScrollOffset = $self.SelectedRow 
                        }
                        Request-TuiRefresh 
                    } 
                }
                ([ConsoleKey]::DownArrow) { 
                    if ($self.SelectedRow -lt $self.Rows.Count - 1) { 
                        $self.SelectedRow++
                        if ($self.SelectedRow -ge $self.ScrollOffset + $visibleRows) { 
                            $self.ScrollOffset = $self.SelectedRow - $visibleRows + 1 
                        }
                        Request-TuiRefresh 
                    } 
                }
                ([ConsoleKey]::PageUp) { 
                    $self.SelectedRow = [Math]::Max(0, $self.SelectedRow - $visibleRows)
                    $self.ScrollOffset = [Math]::Max(0, $self.ScrollOffset - $visibleRows)
                    Request-TuiRefresh 
                }
                ([ConsoleKey]::PageDown) { 
                    $self.SelectedRow = [Math]::Min($self.Rows.Count - 1, $self.SelectedRow + $visibleRows)
                    $maxScroll = [Math]::Max(0, $self.Rows.Count - $visibleRows)
                    $self.ScrollOffset = [Math]::Min($maxScroll, $self.ScrollOffset + $visibleRows)
                    Request-TuiRefresh 
                }
                ([ConsoleKey]::Home) { 
                    $self.SelectedRow = 0
                    $self.ScrollOffset = 0
                    Request-TuiRefresh 
                }
                ([ConsoleKey]::End) { 
                    $self.SelectedRow = $self.Rows.Count - 1
                    $self.ScrollOffset = [Math]::Max(0, $self.Rows.Count - $visibleRows)
                    Request-TuiRefresh 
                }
                ([ConsoleKey]::Enter) { 
                    if ($self.OnRowSelect) { 
                        & $self.OnRowSelect -Row $self.Rows[$self.SelectedRow] -Index $self.SelectedRow 
                    } 
                }
                default {
                    if ($Key.KeyChar -match '\d') {
                        $colIndex = [int]$Key.KeyChar.ToString() - 1
                        if ($colIndex -ge 0 -and $colIndex -lt $self.Columns.Count) {
                            $colName = $self.Columns[$colIndex].Name
                            if ($self.SortColumn -eq $colName) { 
                                $self.SortAscending = -not $self.SortAscending 
                            } else { 
                                $self.SortColumn = $colName
                                $self.SortAscending = $true 
                            }
                            $self.Rows = $self.Rows | Sort-Object -Property $colName -Descending:(-not $self.SortAscending)
                            Request-TuiRefresh
                        }
                    } else { 
                        $handled = $false 
                    }
                }
            }
            return $handled
        }
    }
    
    return [PSCustomObject]$component
}

function global:New-TuiChart {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "Chart"
        IsFocusable = $false
        
        # Properties (from Props)
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 40
        Height = $Props.Height ?? 10
        Visible = $Props.Visible ?? $true
        ChartType = $Props.ChartType ?? "Bar"
        Data = $Props.Data ?? @()
        ShowValues = $Props.ShowValues ?? $true
        
        # Methods
        Render = {
            param($self)
            if (-not $self.Visible -or $self.Data.Count -eq 0) { return }
            
            switch ($self.ChartType) {
                "Bar" {
                    $maxValue = ($self.Data | Measure-Object -Property Value -Maximum).Maximum
                    if ($maxValue -eq 0) { $maxValue = 1 }
                    $chartHeight = $self.Height - 2
                    $barWidth = [Math]::Floor(($self.Width - 4) / $self.Data.Count)
                    
                    for ($i = 0; $i -lt $self.Data.Count; $i++) {
                        $item = $self.Data[$i]
                        $barHeight = [Math]::Floor(($item.Value / $maxValue) * $chartHeight)
                        $barX = $self.X + 2 + ($i * $barWidth)
                        
                        for ($y = 0; $y -lt $barHeight; $y++) { 
                            $barY = $self.Y + $self.Height - 2 - $y
                            Write-BufferString -X $barX -Y $barY -Text ("█" * ($barWidth - 1)) -ForegroundColor (Get-ThemeColor "Accent") 
                        }
                        
                        if ($item.Label -and $barWidth -gt 3) { 
                            $label = $item.Label
                            if ($label.Length -gt $barWidth - 1) { 
                                $label = $label.Substring(0, $barWidth - 2) 
                            }
                            Write-BufferString -X $barX -Y ($self.Y + $self.Height - 1) -Text $label -ForegroundColor (Get-ThemeColor "Subtle") 
                        }
                        
                        if ($self.ShowValues -and $barHeight -gt 0) { 
                            $valueText = $item.Value.ToString()
                            Write-BufferString -X $barX -Y ($self.Y + $self.Height - 3 - $barHeight) -Text $valueText -ForegroundColor (Get-ThemeColor "Primary") 
                        }
                    }
                }
                "Sparkline" {
                    $width = $self.Width - 2
                    $height = $self.Height - 1
                    $maxValue = ($self.Data | Measure-Object -Maximum).Maximum
                    if ($maxValue -eq 0) { $maxValue = 1 }
                    
                    $sparkChars = @(" ", " ", "▂", "▃", "▄", "▅", "▆", "▇", "█")
                    $sparkline = ""
                    
                    foreach ($value in $self.Data) { 
                        $normalized = ($value / $maxValue)
                        $charIndex = [Math]::Floor($normalized * ($sparkChars.Count - 1))
                        $sparkline += $sparkChars[$charIndex] 
                    }
                    
                    if ($sparkline.Length -gt $width) { 
                        $sparkline = $sparkline.Substring($sparkline.Length - $width) 
                    } else { 
                        $sparkline = $sparkline.PadLeft($width) 
                    }
                    
                    Write-BufferString -X ($self.X + 1) -Y ($self.Y + [Math]::Floor($height / 2)) -Text $sparkline -ForegroundColor (Get-ThemeColor "Accent")
                }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            return $false
        }
    }
    
    return [PSCustomObject]$component
}

#endregion

#region Container Components

function global:New-TuiPanel {
    param([hashtable]$Props = @{})
    
    $componentDef = @{
        Type = "Panel"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 40
        Height = $Props.Height ?? 20
        Visible = $Props.Visible ?? $true
        IsFocusable = $Props.IsFocusable ?? $false
        Children = @()
        
        # Layout properties
        Layout = $Props.Layout ?? 'Stack'
        Orientation = $Props.Orientation ?? 'Vertical'
        Spacing = $Props.Spacing ?? 1
        Padding = $Props.Padding ?? 1
        ShowBorder = $Props.ShowBorder ?? $false
        Title = $Props.Title
        
        # Methods
        AddChild = {
            param($self, $Child)
            $self.Children += $Child
            # Immediately recalculate layout
            & $self._RecalculateLayout -self $self
        }
        
        RemoveChild = {
            param($self, $Child)
            $self.Children = @($self.Children | Where-Object { $_ -ne $Child })
            & $self._RecalculateLayout -self $self
        }
        
        _RecalculateLayout = {
            param($self)
            
            # Calculate content area
            $contentX = $self.X + $self.Padding
            $contentY = $self.Y + $self.Padding
            $contentWidth = $self.Width - ($self.Padding * 2)
            $contentHeight = $self.Height - ($self.Padding * 2)
            
            if ($self.ShowBorder) {
                $contentX++
                $contentY++
                $contentWidth -= 2
                $contentHeight -= 2
            }
            
            # Apply layout
            switch ($self.Layout) {
                'Stack' {
                    $currentX = $contentX
                    $currentY = $contentY
                    
                    foreach ($child in $self.Children) {
                        if (-not $child.Visible) { continue }
                        
                        $child.X = $currentX
                        $child.Y = $currentY
                        
                        # Constrain child size to panel
                        if ($self.Orientation -eq 'Vertical') {
                            $child.Width = [Math]::Min($child.Width, $contentWidth)
                            $currentY += $child.Height + $self.Spacing
                        } else {
                            $child.Height = [Math]::Min($child.Height, $contentHeight)
                            $currentX += $child.Width + $self.Spacing
                        }
                    }
                }
                
                'Grid' {
                    # Simple grid - auto columns based on width
                    if ($self.Children.Count -eq 0) { return }
                    
                    # Estimate columns based on average child width
                    $avgWidth = 20
                    if ($self.Children[0].Width) {
                        $avgWidth = $self.Children[0].Width
                    }
                    
                    $cols = [Math]::Max(1, [Math]::Floor($contentWidth / ($avgWidth + $self.Spacing)))
                    $cellWidth = [Math]::Floor(($contentWidth - ($cols - 1) * $self.Spacing) / $cols)
                    
                    $row = 0
                    $col = 0
                    
                    foreach ($child in $self.Children) {
                        if (-not $child.Visible) { continue }
                        
                        $child.X = $contentX + ($col * ($cellWidth + $self.Spacing))
                        $child.Y = $contentY + ($row * ($child.Height + $self.Spacing))
                        $child.Width = [Math]::Min($child.Width, $cellWidth)
                        
                        $col++
                        if ($col -ge $cols) {
                            $col = 0
                            $row++
                        }
                    }
                }
            }
        }
        
        Render = {
            param($self)
            if (-not $self.Visible) { return }
            
            # Draw border if requested
            if ($self.ShowBorder) {
                $borderColor = if ($self.IsFocused) {
                    Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
                } else {
                    Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
                }
                
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -BorderColor $borderColor -Title $self.Title
            }
            
            # Render children
            foreach ($child in $self.Children) {
                if ($child.Visible -and $child.Render) {
                    & $child.Render -self $child
                }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            # Panels don't handle input directly, but could implement focus management
            return $false
        }
    }
    
    # Convert to PSCustomObject to make scriptblocks callable as methods
    $component = [PSCustomObject]$componentDef
    
    # Initial layout calculation
    & $component._RecalculateLayout -self $component
    
    return $component
}

#endregion

Export-ModuleMember -Function @(
    # Basic Components
    'New-TuiLabel',
    'New-TuiButton',
    'New-TuiTextBox',
    'New-TuiCheckBox',
    'New-TuiDropdown',
    'New-TuiProgressBar',
    'New-TuiTextArea',
    # DateTime Components
    'New-TuiDatePicker',
    'New-TuiTimePicker',
    # Data Display Components
    'New-TuiTable',
    'New-TuiChart',
    # Container Components
    'New-TuiPanel'
)
```

### 2. Corrected `advanced-data-components.psm1`

This version restores all the detailed implementation for `New-TuiDataTable` and `New-TuiTreeView` and correctly casts the final objects.

```powershell
# Advanced Data Components Module
# Enhanced data display components with sorting, filtering, and pagination

#region Advanced Table Component

function global:New-TuiDataTable {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "DataTable"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 80
        Height = $Props.Height ?? 20
        Title = $Props.Title
        ShowBorder = $Props.ShowBorder ?? $true
        Data = $Props.Data ?? @()
        Columns = $Props.Columns ?? @()
        SelectedRow = 0
        ScrollOffset = 0
        SortColumn = $null
        SortDirection = "Ascending"
        FilterText = ""
        FilterColumn = $null
        PageSize = 0  # 0 = auto-calculate
        CurrentPage = 0
        ShowHeader = $Props.ShowHeader ?? $true
        ShowFooter = $Props.ShowFooter ?? $true
        ShowRowNumbers = $Props.ShowRowNumbers ?? $false
        AllowSort = $Props.AllowSort ?? $true
        AllowFilter = $Props.AllowFilter ?? $true
        AllowSelection = $Props.AllowSelection ?? $true
        MultiSelect = $Props.MultiSelect ?? $false
        SelectedRows = @()
        IsFocusable = $Props.IsFocusable ?? $true
        FilteredData = @()
        ProcessedData = @()
        
        # Event handlers from Props
        OnRowSelect = $Props.OnRowSelect
        OnSelectionChange = $Props.OnSelectionChange
        
        ProcessData = {
            param($self)
            # Filter data
            if ([string]::IsNullOrWhiteSpace($self.FilterText)) {
                $self.FilteredData = $self.Data
            } else {
                if ($self.FilterColumn) {
                    # Filter specific column
                    $self.FilteredData = @($self.Data | Where-Object {
                        $value = $_."$($self.FilterColumn)"
                        $value -and $value.ToString() -like "*$($self.FilterText)*"
                    })
                } else {
                    # Filter all columns
                    $self.FilteredData = @($self.Data | Where-Object {
                        $row = $_
                        $matched = $false
                        foreach ($col in $self.Columns) {
                            if ($col.Filterable -ne $false) {
                                $value = $row."$($col.Name)"
                                if ($value -and $value.ToString() -like "*$($self.FilterText)*") {
                                    $matched = $true
                                    break
                                }
                            }
                        }
                        $matched
                    })
                }
            }
            
            # Sort data
            if ($self.SortColumn -and $self.AllowSort) {
                $self.ProcessedData = $self.FilteredData | Sort-Object -Property $self.SortColumn -Descending:($self.SortDirection -eq "Descending")
            } else {
                $self.ProcessedData = $self.FilteredData
            }
            
            # Reset selection if needed
            if ($self.SelectedRow -ge $self.ProcessedData.Count) {
                $self.SelectedRow = [Math]::Max(0, $self.ProcessedData.Count - 1)
            }
            
            # Calculate page size if auto
            if ($self.PageSize -eq 0) {
                $headerLines = if ($self.ShowHeader) { 3 } else { 0 }
                $footerLines = if ($self.ShowFooter) { 2 } else { 0 }
                $filterLines = if ($self.AllowFilter) { 2 } else { 0 }
                $borderAdjust = if ($self.ShowBorder) { 2 } else { 0 }
                $self.PageSize = $self.Height - $headerLines - $footerLines - $filterLines - $borderAdjust
            }
            
            # Adjust current page
            $totalPages = [Math]::Ceiling($self.ProcessedData.Count / [Math]::Max(1, $self.PageSize))
            if ($self.CurrentPage -ge $totalPages) {
                $self.CurrentPage = [Math]::Max(0, $totalPages - 1)
            }
        }
        
        Render = {
            param($self)
            
            # Process data first
            & $self.ProcessData -self $self
            
            # Only draw border if ShowBorder is true
            $contentX = $self.X
            $contentY = $self.Y
            $contentWidth = $self.Width
            $contentHeight = $self.Height
            
            if ($self.ShowBorder) {
                $borderColor = if ($self.IsFocusable -and $self.IsFocused) { 
                    Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
                } else { 
                    Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
                }
                
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -BorderColor $borderColor -Title " $($self.Title ?? 'Data Table') "
                
                # Adjust content area for border
                $contentX = $self.X + 1
                $contentY = $self.Y + 1
                $contentWidth = $self.Width - 2
                $contentHeight = $self.Height - 2
            }
            
            $currentY = $contentY
            $innerWidth = $contentWidth
            
            # Filter bar
            if ($self.AllowFilter) {
                $filterBg = if ($self.FilterText) { Get-ThemeColor "Warning" -Default ([ConsoleColor]::Yellow) } else { Get-ThemeColor "Background" -Default ([ConsoleColor]::Black) }
                $filterFg = if ($self.FilterText) { Get-ThemeColor "Background" -Default ([ConsoleColor]::Black) } else { Get-ThemeColor "Subtle" -Default ([ConsoleColor]::DarkGray) }
                
                Write-BufferString -X ($contentX + 1) -Y $currentY -Text "Filter: " -ForegroundColor (Get-ThemeColor "Primary" -Default ([ConsoleColor]::White))
                
                $filterDisplayText = if ($self.FilterText) { $self.FilterText } else { "Type to filter..." }
                Write-BufferString -X ($contentX + 9) -Y $currentY -Text $filterDisplayText `
                    -ForegroundColor $filterFg -BackgroundColor $filterBg
                
                if ($self.FilterColumn) {
                    $colName = ($self.Columns | Where-Object { $_.Name -eq $self.FilterColumn }).Header ?? $self.FilterColumn
                    Write-BufferString -X ($contentX + $contentWidth - 19) -Y $currentY `
                        -Text "Column: $colName" -ForegroundColor (Get-ThemeColor "Info" -Default ([ConsoleColor]::Blue))
                }
                
                $currentY += 2
            }
            
            # Calculate column widths
            $totalDefinedWidth = ($self.Columns | Where-Object { $_.Width } | Measure-Object -Property Width -Sum).Sum ?? 0
            $flexColumns = @($self.Columns | Where-Object { -not $_.Width })
            $columnSeparators = [Math]::Max(0, $self.Columns.Count - 1)
            $remainingWidth = $innerWidth - $totalDefinedWidth - ($self.ShowRowNumbers ? 5 : 0) - $columnSeparators
            $flexWidth = if ($flexColumns.Count -gt 0) { [Math]::Floor($remainingWidth / $flexColumns.Count) } else { 0 }
            
            foreach ($col in $flexColumns) {
                $col.CalculatedWidth = [Math]::Max(5, $flexWidth)
            }
            foreach ($col in $self.Columns | Where-Object { $_.Width }) {
                $col.CalculatedWidth = $_.Width
            }
            
            # Header
            if ($self.ShowHeader) {
                $headerX = $contentX
                
                if ($self.ShowRowNumbers) {
                    Write-BufferString -X $headerX -Y $currentY -Text "#".PadRight(4) `
                        -ForegroundColor (Get-ThemeColor "Header" -Default ([ConsoleColor]::Cyan))
                    $headerX += 5
                }
                
                foreach ($col in $self.Columns) {
                    $headerText = $col.Header ?? $col.Name
                    $width = $col.CalculatedWidth
                    
                    if ($self.AllowSort -and $col.Sortable -ne $false -and $col.Name -eq $self.SortColumn) {
                        $sortIndicator = if ($self.SortDirection -eq "Ascending") { "▲" } else { "▼" }
                        $headerText = "$headerText $sortIndicator"
                    }
                    
                    if ($headerText.Length -gt $width) {
                        $maxLength = [Math]::Max(0, $width - 3)
                        $headerText = $headerText.Substring(0, $maxLength) + "..."
                    }
                    
                    $alignedText = switch ($col.Align) {
                        "Right" { $headerText.PadLeft($width) }
                        "Center" { 
                            $padding = $width - $headerText.Length
                            $leftPad = [Math]::Floor($padding / 2)
                            $rightPad = $padding - $leftPad
                            " " * $leftPad + $headerText + " " * $rightPad
                        }
                        default { $headerText.PadRight($width) }
                    }
                    
                    Write-BufferString -X $headerX -Y $currentY -Text $alignedText `
                        -ForegroundColor (Get-ThemeColor "Header" -Default ([ConsoleColor]::Cyan))
                    
                    $headerX += $width + 1
                }
                
                $currentY++
                
                $separatorColor = Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
                Write-BufferString -X $contentX -Y $currentY `
                    -Text ("─" * $contentWidth) -ForegroundColor $separatorColor
                $currentY++
            }
            
            # Data rows
            $startIdx = $self.CurrentPage * $self.PageSize
            $endIdx = [Math]::Min($startIdx + $self.PageSize - 1, $self.ProcessedData.Count - 1)
            
            for ($i = $startIdx; $i -le $endIdx; $i++) {
                $row = $self.ProcessedData[$i]
                $rowX = $contentX
                
                $isSelected = if ($self.MultiSelect) {
                    $self.SelectedRows -contains $i
                } else {
                    $i -eq $self.SelectedRow
                }
                
                $rowBg = if ($isSelected) { Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan) } else { Get-ThemeColor "Background" -Default ([ConsoleColor]::Black) }
                $rowFg = if ($isSelected) { Get-ThemeColor "Background" -Default ([ConsoleColor]::Black) } else { Get-ThemeColor "Primary" -Default ([ConsoleColor]::White) }
                
                if ($isSelected) {
                    Write-BufferString -X $rowX -Y $currentY -Text (" " * $contentWidth) `
                        -BackgroundColor $rowBg
                }
                
                if ($self.ShowRowNumbers) {
                    Write-BufferString -X $rowX -Y $currentY -Text ($i + 1).ToString().PadRight(4) `
                        -ForegroundColor (Get-ThemeColor "Subtle" -Default ([ConsoleColor]::DarkGray)) -BackgroundColor $rowBg
                    $rowX += 5
                }
                
                foreach ($col in $self.Columns) {
                    $value = $row."$($col.Name)"
                    $width = $col.CalculatedWidth
                    
                    $displayValue = if ($col.Format -and $value -ne $null) {
                        & $col.Format $value
                    } elseif ($value -ne $null) {
                        $value.ToString()
                    } else {
                        ""
                    }
                    
                    if ($displayValue.Length -gt $width) {
                        $maxLength = [Math]::Max(0, $width - 3)
                        if ($maxLength -le 0) {
                            $displayValue = "..."
                        } else {
                            $displayValue = $displayValue.Substring(0, $maxLength) + "..."
                        }
                    }
                    
                    $alignedValue = switch ($col.Align) {
                        "Right" { $displayValue.PadLeft($width) }
                        "Center" { 
                            $padding = $width - $displayValue.Length
                            $leftPad = [Math]::Floor($padding / 2)
                            $rightPad = $padding - $leftPad
                            " " * $leftPad + $displayValue + " " * $rightPad
                        }
                        default { $displayValue.PadRight($width) }
                    }
                    
                    $cellFg = if ($col.Color -and -not $isSelected) {
                        $colorName = & $col.Color $value $row
                        Get-ThemeColor $colorName -Default ([ConsoleColor]::White)
                    } else {
                        $rowFg
                    }
                    
                    Write-BufferString -X $rowX -Y $currentY -Text $alignedValue `
                        -ForegroundColor $cellFg -BackgroundColor $rowBg
                    
                    $rowX += $width + 1
                }
                
                $currentY++
            }
            
            # Empty state
            if ($self.ProcessedData.Count -eq 0) {
                $emptyMessage = if ($self.FilterText) {
                    "No results match the filter"
                } else {
                    "No data to display"
                }
                $msgX = $contentX + [Math]::Floor(($contentWidth - $emptyMessage.Length) / 2)
                $msgY = $contentY + [Math]::Floor($contentHeight / 2)
                Write-BufferString -X $msgX -Y $msgY -Text $emptyMessage `
                    -ForegroundColor (Get-ThemeColor "Subtle" -Default ([ConsoleColor]::DarkGray))
            }
            
            # Footer
            if ($self.ShowFooter) {
                $footerY = $contentY + $contentHeight - 1
                
                $statusText = "$($self.ProcessedData.Count) rows"
                if ($self.FilterText) {
                    $statusText += " (filtered from $($self.Data.Count))"
                }
                if ($self.MultiSelect) {
                    $statusText += " | $($self.SelectedRows.Count) selected"
                }
                Write-BufferString -X ($contentX + 1) -Y $footerY -Text $statusText `
                    -ForegroundColor (Get-ThemeColor "Subtle" -Default ([ConsoleColor]::DarkGray))
                
                if ($self.ProcessedData.Count -gt $self.PageSize) {
                    $totalPages = [Math]::Ceiling($self.ProcessedData.Count / [Math]::Max(1, $self.PageSize))
                    $pageText = "Page $($self.CurrentPage + 1)/$totalPages"
                    Write-BufferString -X ($contentX + $contentWidth - $pageText.Length - 1) -Y $footerY `
                        -Text $pageText -ForegroundColor (Get-ThemeColor "Info" -Default ([ConsoleColor]::Blue))
                }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            
            if ($Key.Modifiers -band [ConsoleModifiers]::Control) {
                switch ($Key.Key) {
                    ([ConsoleKey]::F) {
                        $self.FilterMode = -not $self.FilterMode
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::S) {
                        if ($self.AllowSort) {
                            $sortableCols = @($self.Columns | Where-Object { $_.Sortable -ne $false })
                            if ($sortableCols.Count -gt 0) {
                                $currentIdx = [array]::IndexOf($sortableCols.Name, $self.SortColumn)
                                $nextIdx = ($currentIdx + 1) % $sortableCols.Count
                                $self.SortColumn = $sortableCols[$nextIdx].Name
                                & $self.ProcessData -self $self
                                Request-TuiRefresh
                            }
                        }
                        return $true
                    }
                    ([ConsoleKey]::A) {
                        if ($self.MultiSelect) {
                            if ($self.SelectedRows.Count -eq $self.ProcessedData.Count) {
                                $self.SelectedRows = @()
                            } else {
                                $self.SelectedRows = @(0..($self.ProcessedData.Count - 1))
                            }
                            if ($self.OnSelectionChange) {
                                & $self.OnSelectionChange -SelectedRows $self.SelectedRows
                            }
                            Request-TuiRefresh
                        }
                        return $true
                    }
                }
            }
            
            if ($self.FilterMode) {
                switch ($Key.Key) {
                    ([ConsoleKey]::Escape) {
                        $self.FilterMode = $false
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::Enter) {
                        $self.FilterMode = $false
                        & $self.ProcessData -self $self
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::Backspace) {
                        if ($self.FilterText.Length -gt 0) {
                            $self.FilterText = $self.FilterText.Substring(0, $self.FilterText.Length - 1)
                            & $self.ProcessData -self $self
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    default {
                        if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar)) {
                            $self.FilterText += $Key.KeyChar
                            & $self.ProcessData -self $self
                            Request-TuiRefresh
                            return $true
                        }
                    }
                }
                return $false
            }
            
            switch ($Key.Key) {
                ([ConsoleKey]::UpArrow) {
                    if ($self.SelectedRow -gt 0) {
                        $self.SelectedRow--
                        if ($self.SelectedRow -lt ($self.CurrentPage * $self.PageSize)) {
                            $self.CurrentPage--
                        }
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::DownArrow) {
                    if ($self.SelectedRow -lt ($self.ProcessedData.Count - 1)) {
                        $self.SelectedRow++
                        if ($self.SelectedRow -ge (($self.CurrentPage + 1) * $self.PageSize)) {
                            $self.CurrentPage++
                        }
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::PageUp) {
                    if ($self.CurrentPage -gt 0) {
                        $self.CurrentPage--
                        $self.SelectedRow = $self.CurrentPage * $self.PageSize
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::PageDown) {
                    $totalPages = [Math]::Ceiling($self.ProcessedData.Count / [Math]::Max(1, $self.PageSize))
                    if ($self.CurrentPage -lt ($totalPages - 1)) {
                        $self.CurrentPage++
                        $self.SelectedRow = $self.CurrentPage * $self.PageSize
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::Home) {
                    $self.SelectedRow = 0
                    $self.CurrentPage = 0
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::End) {
                    $self.SelectedRow = $self.ProcessedData.Count - 1
                    $self.CurrentPage = [Math]::Floor($self.SelectedRow / [Math]::Max(1, $self.PageSize))
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::Spacebar) {
                    if ($self.MultiSelect) {
                        if ($self.SelectedRows -contains $self.SelectedRow) {
                            $self.SelectedRows = @($self.SelectedRows | Where-Object { $_ -ne $self.SelectedRow })
                        } else {
                            $self.SelectedRows += $self.SelectedRow
                        }
                        if ($self.OnSelectionChange) {
                            & $self.OnSelectionChange -SelectedRows $self.SelectedRows
                        }
                        Request-TuiRefresh
                    } elseif ($self.AllowSort) {
                        if ($self.SortDirection -eq "Ascending") {
                            $self.SortDirection = "Descending"
                        } else {
                            $self.SortDirection = "Ascending"
                        }
                        & $self.ProcessData -self $self
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::Enter) {
                    if ($self.OnRowSelect -and $self.ProcessedData.Count -gt 0) {
                        $selectedData = if ($self.MultiSelect) {
                            @($self.SelectedRows | ForEach-Object { $self.ProcessedData[$_] })
                        } else {
                            $self.ProcessedData[$self.SelectedRow]
                        }
                        & $self.OnRowSelect -SelectedData $selectedData -SelectedIndex $self.SelectedRow
                    }
                    return $true
                }
                ([ConsoleKey]::F) {
                    if ($self.AllowFilter) {
                        $self.FilterMode = $true
                        Request-TuiRefresh
                    }
                    return $true
                }
                default {
                    if ($Key.KeyChar -match '\d' -and $self.AllowSort) {
                        $colIndex = [int]$Key.KeyChar.ToString() - 1
                        if ($colIndex -ge 0 -and $colIndex -lt $self.Columns.Count) {
                            $col = $self.Columns[$colIndex]
                            if ($col.Sortable -ne $false) {
                                if ($self.SortColumn -eq $col.Name) {
                                    $self.SortDirection = if ($self.SortDirection -eq "Ascending") { "Descending" } else { "Ascending" }
                                } else {
                                    $self.SortColumn = $col.Name
                                    $self.SortDirection = "Ascending"
                                }
                                & $self.ProcessData -self $self
                                Request-TuiRefresh
                            }
                        }
                        return $true
                    }
                }
            }
            
            return $false
        }
    }
    
    $componentObject = [PSCustomObject]$component
    & $componentObject.ProcessData -self $componentObject
    
    return $componentObject
}

#endregion

#region Tree View Component

function global:New-TuiTreeView {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "TreeView"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 40
        Height = $Props.Height ?? 20
        RootNode = $Props.RootNode ?? @{ Name = "Root"; Children = @(); Expanded = $true }
        SelectedNode = $null
        SelectedPath = @()
        FlattenedNodes = @()
        ScrollOffset = 0
        ShowRoot = $Props.ShowRoot ?? $true
        IsFocusable = $true
        
        FlattenTree = {
            param($self)
            $flattened = @()
            
            $processNode = {
                param($Node, $Level, $Parent)
                
                $node.Parent = $Parent
                $node.Level = $Level
                
                if ($self.ShowRoot -or $Level -gt 0) {
                    $flattened += $Node
                }
                
                if ($Node.Expanded -and $Node.Children) {
                    foreach ($child in $Node.Children) {
                        & $processNode $child ($Level + 1) $Node
                    }
                }
            }
            
            & $processNode $self.RootNode 0 $null
            $self.FlattenedNodes = $flattened
        }
        
        Render = {
            param($self)
            
            & $self.FlattenTree -self $self
            
            $borderColor = if ($self.IsFocused) { 
                Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
            } else { 
                Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
            }
            
            Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                -BorderColor $borderColor -Title " Tree View "
            
            $visibleHeight = $self.Height - 2
            $startIdx = $self.ScrollOffset
            $endIdx = [Math]::Min($self.FlattenedNodes.Count - 1, $startIdx + $visibleHeight - 1)
            
            $currentY = $self.Y + 1
            
            for ($i = $startIdx; $i -le $endIdx; $i++) {
                $node = $self.FlattenedNodes[$i]
                $isSelected = ($node -eq $self.SelectedNode)
                
                $indent = "  " * $node.Level
                
                $expandIcon = if ($node.Children -and $node.Children.Count -gt 0) {
                    if ($node.Expanded) { "▼" } else { "▶" }
                } else {
                    " "
                }
                
                $nodeIcon = if ($node.Icon) { 
                    $node.Icon 
                } elseif ($node.Children -and $node.Children.Count -gt 0) {
                    if ($node.Expanded) { "📂" } else { "📁" }
                } else {
                    "📄"
                }
                
                $fg = if ($isSelected) { Get-ThemeColor "Background" -Default ([ConsoleColor]::Black) } else { Get-ThemeColor "Primary" -Default ([ConsoleColor]::White) }
                $bg = if ($isSelected) { Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan) } else { Get-ThemeColor "Background" -Default ([ConsoleColor]::Black) }
                
                if ($isSelected) {
                    Write-BufferString -X ($self.X + 1) -Y $currentY -Text (" " * ($self.Width - 2)) `
                        -BackgroundColor $bg
                }
                
                $nodeText = "$indent$expandIcon $nodeIcon $($node.Name)"
                if ($nodeText.Length -gt ($self.Width - 3)) {
                    $nodeText = $nodeText.Substring(0, $self.Width - 6) + "..."
                }
                
                Write-BufferString -X ($self.X + 1) -Y $currentY -Text $nodeText `
                    -ForegroundColor $fg -BackgroundColor $bg
                
                $currentY++
            }
            
            if ($self.FlattenedNodes.Count -gt $visibleHeight) {
                $scrollHeight = $visibleHeight
                $scrollPos = if ($self.FlattenedNodes.Count -gt 1) {
                    $selectedIdx = [array]::IndexOf($self.FlattenedNodes, $self.SelectedNode)
                    [Math]::Floor(($selectedIdx / ($self.FlattenedNodes.Count - 1)) * ($scrollHeight - 1))
                } else { 0 }
                
                for ($i = 0; $i -lt $scrollHeight; $i++) {
                    $char = if ($i -eq $scrollPos) { "█" } else { "│" }
                    $color = if ($i -eq $scrollPos) { Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan) } else { Get-ThemeColor "Subtle" -Default ([ConsoleColor]::DarkGray) }
                    Write-BufferString -X ($self.X + $self.Width - 2) -Y ($self.Y + 1 + $i) `
                        -Text $char -ForegroundColor $color
                }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            
            if ($self.FlattenedNodes.Count -eq 0) { return $false }
            
            $currentIdx = if ($self.SelectedNode) {
                [array]::IndexOf($self.FlattenedNodes, $self.SelectedNode)
            } else { 0 }
            
            switch ($Key.Key) {
                ([ConsoleKey]::UpArrow) {
                    if ($currentIdx -gt 0) {
                        $currentIdx--
                        $self.SelectedNode = $self.FlattenedNodes[$currentIdx]
                        if ($currentIdx -lt $self.ScrollOffset) {
                            $self.ScrollOffset = $currentIdx
                        }
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::DownArrow) {
                    if ($currentIdx -lt ($self.FlattenedNodes.Count - 1)) {
                        $currentIdx++
                        $self.SelectedNode = $self.FlattenedNodes[$currentIdx]
                        $visibleHeight = $self.Height - 2
                        if ($currentIdx -ge ($self.ScrollOffset + $visibleHeight)) {
                            $self.ScrollOffset = $currentIdx - $visibleHeight + 1
                        }
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::LeftArrow) {
                    if ($self.SelectedNode) {
                        if ($self.SelectedNode.Expanded -and $self.SelectedNode.Children) {
                            $self.SelectedNode.Expanded = $false
                            Request-TuiRefresh
                        } elseif ($self.SelectedNode.Parent) {
                            $self.SelectedNode = $self.SelectedNode.Parent
                            Request-TuiRefresh
                        }
                    }
                    return $true
                }
                ([ConsoleKey]::RightArrow) {
                    if ($self.SelectedNode -and $self.SelectedNode.Children -and $self.SelectedNode.Children.Count -gt 0) {
                        if (-not $self.SelectedNode.Expanded) {
                            $self.SelectedNode.Expanded = $true
                            Request-TuiRefresh
                        } else {
                            $self.SelectedNode = $self.SelectedNode.Children[0]
                            Request-TuiRefresh
                        }
                    }
                    return $true
                }
                ([ConsoleKey]::Spacebar) {
                    if ($self.SelectedNode -and $self.SelectedNode.Children -and $self.SelectedNode.Children.Count -gt 0) {
                        $self.SelectedNode.Expanded = -not $self.SelectedNode.Expanded
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::Enter) {
                    if ($self.OnNodeSelect -and $self.SelectedNode) {
                        $path = @()
                        $current = $self.SelectedNode
                        while ($current) {
                            $path = @($current.Name) + $path
                            $current = $current.Parent
                        }
                        & $self.OnNodeSelect -Node $self.SelectedNode -Path $path
                    }
                    return $true
                }
            }
            
            return $false
        }
    }
    
    return [PSCustomObject]$component
}

#endregion

Export-ModuleMember -Function @(
    'New-TuiDataTable',
    'New-TuiTreeView'
)
```

### 3. Corrected `advanced-input-components.psm1`

This version restores all the detailed implementation for the advanced input components and correctly casts the final objects.

```powershell
# Advanced Input Components Module
# Enhanced input components from the TUI Upgrade Roadmap

#region DateTime Components with Calendar Grid

function global:New-TuiCalendarPicker {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "CalendarPicker"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 30
        Height = $Props.Height ?? 10
        Value = $Props.Value ?? (Get-Date)
        Mode = $Props.Mode ?? "Date"  # Date, DateTime, Time
        IsFocusable = $true
        CurrentView = "Day"  # Day, Month, Year
        SelectedDate = $Props.Value ?? (Get-Date)
        ViewDate = $Props.Value ?? (Get-Date)
        
        Render = {
            param($self)
            
            $borderColor = if ($self.IsFocused) { 
                Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
            } else { 
                Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
            }
            
            # Main container
            Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                -BorderColor $borderColor -Title " Calendar "
            
            # Header with navigation
            $headerY = $self.Y + 1
            $monthYear = $self.ViewDate.ToString("MMMM yyyy")
            $headerX = $self.X + [Math]::Floor(($self.Width - $monthYear.Length) / 2)
            
            Write-BufferString -X ($self.X + 2) -Y $headerY -Text "◄" -ForegroundColor $borderColor
            Write-BufferString -X $headerX -Y $headerY -Text $monthYear -ForegroundColor (Get-ThemeColor "Header")
            Write-BufferString -X ($self.X + $self.Width - 3) -Y $headerY -Text "►" -ForegroundColor $borderColor
            
            # Day headers
            $dayHeaderY = $headerY + 2
            $days = @("Su", "Mo", "Tu", "We", "Th", "Fr", "Sa")
            $dayWidth = 4
            $startX = $self.X + 2
            
            for ($i = 0; $i -lt $days.Count; $i++) {
                Write-BufferString -X ($startX + ($i * $dayWidth)) -Y $dayHeaderY `
                    -Text $days[$i] -ForegroundColor (Get-ThemeColor "Subtle")
            }
            
            # Calendar grid
            $firstDay = Get-Date -Year $self.ViewDate.Year -Month $self.ViewDate.Month -Day 1
            $startDayOfWeek = [int]$firstDay.DayOfWeek
            $daysInMonth = [DateTime]::DaysInMonth($self.ViewDate.Year, $self.ViewDate.Month)
            
            $currentDay = 1
            $calendarY = $dayHeaderY + 1
            
            for ($week = 0; $week -lt 6; $week++) {
                if ($currentDay -gt $daysInMonth) { break }
                
                for ($dayOfWeek = 0; $dayOfWeek -lt 7; $dayOfWeek++) {
                    $x = $startX + ($dayOfWeek * $dayWidth)
                    
                    if ($week -eq 0 -and $dayOfWeek -lt $startDayOfWeek) {
                        continue
                    }
                    
                    if ($currentDay -le $daysInMonth) {
                        $isSelected = ($currentDay -eq $self.SelectedDate.Day -and 
                                     $self.ViewDate.Month -eq $self.SelectedDate.Month -and 
                                     $self.ViewDate.Year -eq $self.SelectedDate.Year)
                        
                        $isToday = ($currentDay -eq (Get-Date).Day -and 
                                  $self.ViewDate.Month -eq (Get-Date).Month -and 
                                  $self.ViewDate.Year -eq (Get-Date).Year)
                        
                        $fg = if ($isSelected) { 
                            Get-ThemeColor "Background" 
                        } elseif ($isToday) { 
                            Get-ThemeColor "Accent" 
                        } else { 
                            Get-ThemeColor "Primary" 
                        }
                        
                        $bg = if ($isSelected) { 
                            Get-ThemeColor "Accent" 
                        } else { 
                            Get-ThemeColor "Background" 
                        }
                        
                        $dayText = $currentDay.ToString().PadLeft(2)
                        Write-BufferString -X $x -Y ($calendarY + $week) -Text $dayText `
                            -ForegroundColor $fg -BackgroundColor $bg
                        
                        $currentDay++
                    }
                }
            }
            
            # Time picker if in DateTime mode
            if ($self.Mode -eq "DateTime") {
                $timeY = $self.Y + $self.Height - 2
                $timeStr = $self.SelectedDate.ToString("HH:mm")
                Write-BufferString -X ($self.X + 2) -Y $timeY -Text "Time: $timeStr" `
                    -ForegroundColor (Get-ThemeColor "Primary")
            }
        }
        
        HandleInput = {
            param($self, $Key)
            
            $handled = $true
            $date = $self.SelectedDate
            $viewDate = $self.ViewDate
            
            switch ($Key.Key) {
                ([ConsoleKey]::LeftArrow) {
                    if ($Key.Modifiers -band [ConsoleModifiers]::Control) {
                        # Previous month
                        $self.ViewDate = $viewDate.AddMonths(-1)
                    } else {
                        # Previous day
                        $date = $date.AddDays(-1)
                        if ($date.Month -ne $viewDate.Month) {
                            $self.ViewDate = $date
                        }
                    }
                }
                ([ConsoleKey]::RightArrow) {
                    if ($Key.Modifiers -band [ConsoleModifiers]::Control) {
                        # Next month
                        $self.ViewDate = $viewDate.AddMonths(1)
                    } else {
                        # Next day
                        $date = $date.AddDays(1)
                        if ($date.Month -ne $viewDate.Month) {
                            $self.ViewDate = $date
                        }
                    }
                }
                ([ConsoleKey]::UpArrow) {
                    $date = $date.AddDays(-7)
                    if ($date.Month -ne $viewDate.Month) {
                        $self.ViewDate = $date
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    $date = $date.AddDays(7)
                    if ($date.Month -ne $viewDate.Month) {
                        $self.ViewDate = $date
                    }
                }
                ([ConsoleKey]::PageUp) {
                    $self.ViewDate = $viewDate.AddMonths(-1)
                    $date = Get-Date -Year $self.ViewDate.Year -Month $self.ViewDate.Month `
                        -Day ([Math]::Min($date.Day, [DateTime]::DaysInMonth($self.ViewDate.Year, $self.ViewDate.Month)))
                }
                ([ConsoleKey]::PageDown) {
                    $self.ViewDate = $viewDate.AddMonths(1)
                    $date = Get-Date -Year $self.ViewDate.Year -Month $self.ViewDate.Month `
                        -Day ([Math]::Min($date.Day, [DateTime]::DaysInMonth($self.ViewDate.Year, $self.ViewDate.Month)))
                }
                ([ConsoleKey]::Home) {
                    $date = Get-Date
                    $self.ViewDate = $date
                }
                ([ConsoleKey]::Enter) {
                    if ($self.OnSelect) {
                        & $self.OnSelect -Date $date
                    }
                }
                default {
                    $handled = $false
                }
            }
            
            if ($handled) {
                $self.SelectedDate = $date
                if ($self.OnChange) {
                    & $self.OnChange -NewValue $date
                }
                Request-TuiRefresh
            }
            
            return $handled
        }
    }
    
    return [PSCustomObject]$component
}

#endregion

#region Enhanced Dropdown with Search

function global:New-TuiSearchableDropdown {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "SearchableDropdown"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 30
        Height = $Props.Height ?? 3
        Options = $Props.Options ?? @()
        Value = $Props.Value
        Placeholder = $Props.Placeholder ?? "Type to search..."
        MaxDisplayItems = $Props.MaxDisplayItems ?? 5
        AllowCustomValue = $Props.AllowCustomValue ?? $false
        IsFocusable = $true
        IsOpen = $false
        SearchText = ""
        FilteredOptions = @()
        SelectedIndex = 0
        
        Render = {
            param($self)
            
            $borderColor = if ($self.IsFocused) { 
                Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
            } else { 
                Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
            }
            
            # Main dropdown box
            Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                -BorderColor $borderColor
            
            # Display text
            $displayText = ""
            if ($self.IsOpen) {
                $displayText = $self.SearchText
                if ([string]::IsNullOrEmpty($displayText) -and -not $self.IsFocused) {
                    $displayText = $self.Placeholder
                }
            } else {
                if ($self.Value) {
                    $selected = $self.Options | Where-Object { $_.Value -eq $self.Value } | Select-Object -First 1
                    if ($selected) {
                        $displayText = $selected.Display
                    } else {
                        $displayText = $self.Value.ToString()
                    }
                } else {
                    $displayText = "Select..."
                }
            }
            
            Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $displayText
            
            # Dropdown indicator
            $indicator = if ($self.IsOpen) { "▲" } else { "▼" }
            Write-BufferString -X ($self.X + $self.Width - 3) -Y ($self.Y + 1) -Text $indicator `
                -ForegroundColor $borderColor
            
            # Cursor for search mode
            if ($self.IsOpen -and $self.IsFocused) {
                $cursorX = $self.X + 2 + $self.SearchText.Length
                if ($cursorX -lt ($self.X + $self.Width - 3)) {
                    Write-BufferString -X $cursorX -Y ($self.Y + 1) -Text "_" `
                        -BackgroundColor (Get-ThemeColor "Accent")
                }
            }
            
            # Options dropdown
            if ($self.IsOpen -and $self.FilteredOptions.Count -gt 0) {
                $dropHeight = [Math]::Min($self.FilteredOptions.Count, $self.MaxDisplayItems) + 2
                Write-BufferBox -X $self.X -Y ($self.Y + $self.Height) -Width $self.Width -Height $dropHeight `
                    -BorderColor $borderColor -BackgroundColor (Get-ThemeColor "Background")
                
                $startIdx = 0
                if ($self.SelectedIndex -ge $self.MaxDisplayItems) {
                    $startIdx = $self.SelectedIndex - $self.MaxDisplayItems + 1
                }
                
                $endIdx = [Math]::Min($startIdx + $self.MaxDisplayItems - 1, $self.FilteredOptions.Count - 1)
                
                for ($i = $startIdx; $i -le $endIdx; $i++) {
                    $option = $self.FilteredOptions[$i]
                    $y = $self.Y + $self.Height + 1 + ($i - $startIdx)
                    
                    $isSelected = ($i -eq $self.SelectedIndex)
                    $fg = if ($isSelected) { Get-ThemeColor "Background" } else { Get-ThemeColor "Primary" }
                    $bg = if ($isSelected) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Background" }
                    
                    $text = $option.Display
                    if ($text.Length -gt ($self.Width - 4)) {
                        $text = $text.Substring(0, $self.Width - 7) + "..."
                    }
                    
                    # Highlight matching text
                    if ($self.SearchText.Length -gt 0 -and -not $isSelected) {
                        $matchIndex = $text.IndexOf($self.SearchText, [StringComparison]::OrdinalIgnoreCase)
                        if ($matchIndex -ge 0) {
                            # Draw text before match
                            if ($matchIndex -gt 0) {
                                Write-BufferString -X ($self.X + 2) -Y $y `
                                    -Text $text.Substring(0, $matchIndex) -ForegroundColor $fg
                            }
                            
                            # Draw matching text highlighted
                            Write-BufferString -X ($self.X + 2 + $matchIndex) -Y $y `
                                -Text $text.Substring($matchIndex, $self.SearchText.Length) `
                                -ForegroundColor (Get-ThemeColor "Warning")
                            
                            # Draw text after match
                            $afterMatch = $matchIndex + $self.SearchText.Length
                            if ($afterMatch -lt $text.Length) {
                                Write-BufferString -X ($self.X + 2 + $afterMatch) -Y $y `
                                    -Text $text.Substring($afterMatch) -ForegroundColor $fg
                            }
                            
                            continue
                        }
                    }
                    
                    Write-BufferString -X ($self.X + 2) -Y $y -Text $text `
                        -ForegroundColor $fg -BackgroundColor $bg
                }
                
                # Scrollbar if needed
                if ($self.FilteredOptions.Count -gt $self.MaxDisplayItems) {
                    $scrollHeight = $self.MaxDisplayItems
                    $scrollPos = [Math]::Floor(($self.SelectedIndex / ($self.FilteredOptions.Count - 1)) * ($scrollHeight - 1))
                    
                    for ($i = 0; $i -lt $scrollHeight; $i++) {
                        $char = if ($i -eq $scrollPos) { "█" } else { "│" }
                        $color = if ($i -eq $scrollPos) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Subtle" }
                        Write-BufferString -X ($self.X + $self.Width - 2) -Y ($self.Y + $self.Height + 1 + $i) `
                            -Text $char -ForegroundColor $color
                    }
                }
            }
        }
        
        FilterOptions = {
            if ([string]::IsNullOrEmpty($this.SearchText)) {
                $this.FilteredOptions = $this.Options
            } else {
                $this.FilteredOptions = @($this.Options | Where-Object {
                    $_.Display -like "*$($this.SearchText)*"
                })
                
                # Add custom value option if allowed and no exact match
                if ($this.AllowCustomValue) {
                    $exactMatch = $this.FilteredOptions | Where-Object { $_.Display -eq $this.SearchText }
                    if (-not $exactMatch) {
                        $this.FilteredOptions = @(@{
                            Display = $this.SearchText
                            Value = $this.SearchText
                            IsCustom = $true
                        }) + $this.FilteredOptions
                    }
                }
            }
            
            # Reset selection to first item
            $this.SelectedIndex = 0
        }
        
        HandleInput = {
            param($self, $Key)
            
            if (-not $self.IsOpen) {
                switch ($Key.Key) {
                    { $_ -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar, [ConsoleKey]::DownArrow) } {
                        $self.IsOpen = $true
                        $self.SearchText = ""
                        & $self.FilterOptions
                        Request-TuiRefresh
                        return $true
                    }
                }
                return $false
            }
            
            # Handle open dropdown
            switch ($Key.Key) {
                ([ConsoleKey]::Escape) {
                    $self.IsOpen = $false
                    $self.SearchText = ""
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::Enter) {
                    if ($self.FilteredOptions.Count -gt 0) {
                        $selected = $self.FilteredOptions[$self.SelectedIndex]
                        if ($self.OnChange) {
                            & $self.OnChange -NewValue $selected.Value -Option $selected
                        }
                        $self.Value = $selected.Value
                        $self.IsOpen = $false
                        $self.SearchText = ""
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::UpArrow) {
                    if ($self.SelectedIndex -gt 0) {
                        $self.SelectedIndex--
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::DownArrow) {
                    if ($self.SelectedIndex -lt ($self.FilteredOptions.Count - 1)) {
                        $self.SelectedIndex++
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::Backspace) {
                    if ($self.SearchText.Length -gt 0) {
                        $self.SearchText = $self.SearchText.Substring(0, $self.SearchText.Length - 1)
                        & $self.FilterOptions
                        Request-TuiRefresh
                    }
                    return $true
                }
                default {
                    if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar)) {
                        $self.SearchText += $Key.KeyChar
                        & $self.FilterOptions
                        Request-TuiRefresh
                        return $true
                    }
                }
            }
            
            return $false
        }
    }
    
    return [PSCustomObject]$component
}

#endregion

#region Multi-Select Components

function global:New-TuiMultiSelect {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "MultiSelect"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 30
        Height = $Props.Height ?? 10
        Options = $Props.Options ?? @()
        SelectedValues = $Props.SelectedValues ?? @()
        Title = $Props.Title ?? "Select items"
        AllowSelectAll = $Props.AllowSelectAll ?? $true
        IsFocusable = $true
        SelectedIndex = 0
        ScrollOffset = 0
        
        Render = {
            param($self)
            
            $borderColor = if ($self.IsFocused) { 
                Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
            } else { 
                Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
            }
            
            Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                -BorderColor $borderColor -Title " $($self.Title) "
            
            # Select all option
            $currentY = $self.Y + 1
            if ($self.AllowSelectAll) {
                $allSelected = $self.Options.Count -eq $self.SelectedValues.Count
                $checkbox = if ($allSelected) { "[X]" } else { "[ ]" }
                $fg = if ($self.SelectedIndex -eq -1) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
                Write-BufferString -X ($self.X + 2) -Y $currentY -Text "$checkbox Select All" `
                    -ForegroundColor $fg
                $currentY += 2
            }
            
            # Options
            $visibleHeight = $self.Height - 4
            if ($self.AllowSelectAll) { $visibleHeight -= 2 }
            
            $startIdx = $self.ScrollOffset
            $endIdx = [Math]::Min($self.Options.Count - 1, $startIdx + $visibleHeight - 1)
            
            for ($i = $startIdx; $i -le $endIdx; $i++) {
                $option = $self.Options[$i]
                $isChecked = $self.SelectedValues -contains $option.Value
                $isHighlighted = ($i -eq $self.SelectedIndex)
                
                $checkbox = if ($isChecked) { "[X]" } else { "[ ]" }
                $fg = if ($isHighlighted) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Primary" }
                
                $text = "$checkbox $($option.Display)"
                if ($text.Length -gt ($self.Width - 4)) {
                    $text = $text.Substring(0, $self.Width - 7) + "..."
                }
                
                Write-BufferString -X ($self.X + 2) -Y $currentY -Text $text -ForegroundColor $fg
                $currentY++
            }
            
            # Status line
            $statusY = $self.Y + $self.Height - 2
            $statusText = "$($self.SelectedValues.Count) of $($self.Options.Count) selected"
            Write-BufferString -X ($self.X + 2) -Y $statusY -Text $statusText `
                -ForegroundColor (Get-ThemeColor "Subtle")
        }
        
        HandleInput = {
            param($self, $Key)
            
            $maxIndex = $self.Options.Count - 1
            if ($self.AllowSelectAll) { $maxIndex++ }
            
            switch ($Key.Key) {
                ([ConsoleKey]::UpArrow) {
                    if ($self.AllowSelectAll -and $self.SelectedIndex -eq 0) {
                        $self.SelectedIndex = -1
                    } elseif ($self.SelectedIndex -gt 0 -or ($self.AllowSelectAll -and $self.SelectedIndex -gt -1)) {
                        $self.SelectedIndex--
                        if ($self.SelectedIndex -ge 0 -and $self.SelectedIndex -lt $self.ScrollOffset) {
                            $self.ScrollOffset = $self.SelectedIndex
                        }
                    }
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::DownArrow) {
                    if ($self.SelectedIndex -lt ($self.Options.Count - 1)) {
                        $self.SelectedIndex++
                        $visibleHeight = $self.Height - 4
                        if ($self.AllowSelectAll) { $visibleHeight -= 2 }
                        if ($self.SelectedIndex -ge ($self.ScrollOffset + $visibleHeight)) {
                            $self.ScrollOffset = $self.SelectedIndex - $visibleHeight + 1
                        }
                    }
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::Spacebar) {
                    if ($self.SelectedIndex -eq -1 -and $self.AllowSelectAll) {
                        # Toggle all
                        if ($self.SelectedValues.Count -eq $self.Options.Count) {
                            $self.SelectedValues = @()
                        } else {
                            $self.SelectedValues = @($self.Options | ForEach-Object { $_.Value })
                        }
                    } elseif ($self.SelectedIndex -ge 0) {
                        # Toggle individual
                        $option = $self.Options[$self.SelectedIndex]
                        if ($self.SelectedValues -contains $option.Value) {
                            $self.SelectedValues = @($self.SelectedValues | Where-Object { $_ -ne $option.Value })
                        } else {
                            $self.SelectedValues += $option.Value
                        }
                    }
                    
                    if ($self.OnChange) {
                        & $self.OnChange -SelectedValues $self.SelectedValues
                    }
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::Enter) {
                    if ($self.OnSubmit) {
                        & $self.OnSubmit -SelectedValues $self.SelectedValues
                    }
                    return $true
                }
            }
            
            return $false
        }
    }
    
    return [PSCustomObject]$component
}

#endregion

#region Numeric Input Components

function global:New-TuiNumberInput {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "NumberInput"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 20
        Height = $Props.Height ?? 3
        Value = $Props.Value ?? 0
        Min = $Props.Min ?? 0
        Max = $Props.Max ?? 100
        Step = $Props.Step ?? 1
        DecimalPlaces = $Props.DecimalPlaces ?? 0
        IsFocusable = $true
        TextValue = ($Props.Value ?? 0).ToString()
        CursorPosition = 0
        
        Render = {
            param($self)
            
            $borderColor = if ($self.IsFocused) { 
                Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
            } else { 
                Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
            }
            
            Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                -BorderColor $borderColor
            
            # Value display
            $displayValue = $self.TextValue
            if ($displayValue.Length -gt ($self.Width - 6)) {
                $displayValue = $displayValue.Substring(0, $self.Width - 9) + "..."
            }
            
            Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $displayValue
            
            # Cursor
            if ($self.IsFocused -and $self.CursorPosition -le $displayValue.Length) {
                $cursorX = $self.X + 2 + $self.CursorPosition
                if ($cursorX -lt ($self.X + $self.Width - 4)) {
                    Write-BufferString -X $cursorX -Y ($self.Y + 1) -Text "_" `
                        -BackgroundColor (Get-ThemeColor "Accent")
                }
            }
            
            # Spinner buttons
            Write-BufferString -X ($self.X + $self.Width - 3) -Y ($self.Y + 1) -Text "▲" `
                -ForegroundColor $borderColor
            Write-BufferString -X ($self.X + $self.Width - 3) -Y ($self.Y + 1) -Text "▼" `
                -ForegroundColor $borderColor
            
            # Min/Max indicators
            if ($self.Value -le $self.Min) {
                Write-BufferString -X ($self.X + 1) -Y ($self.Y + 1) -Text "⊥" `
                    -ForegroundColor (Get-ThemeColor "Warning")
            }
            if ($self.Value -ge $self.Max) {
                Write-BufferString -X ($self.X + $self.Width - 2) -Y ($self.Y + 1) -Text "⊤" `
                    -ForegroundColor (Get-ThemeColor "Warning")
            }
        }
        
        ValidateAndUpdate = {
            try {
                $newValue = [double]$this.TextValue
                $newValue = [Math]::Max($this.Min, [Math]::Min($this.Max, $newValue))
                
                if ($this.DecimalPlaces -eq 0) {
                    $newValue = [Math]::Floor($newValue)
                } else {
                    $newValue = [Math]::Round($newValue, $this.DecimalPlaces)
                }
                
                $this.Value = $newValue
                $this.TextValue = $newValue.ToString("F$($this.DecimalPlaces)")
                
                if ($this.OnChange) {
                    & $this.OnChange -NewValue $newValue
                }
                
                return $true
            } catch {
                # Invalid input, restore previous value
                $this.TextValue = $this.Value.ToString("F$($this.DecimalPlaces)")
                return $false
            }
        }
        
        HandleInput = {
            param($self, $Key)
            
            switch ($Key.Key) {
                ([ConsoleKey]::UpArrow) {
                    $self.Value = [Math]::Min($self.Max, $self.Value + $self.Step)
                    $self.TextValue = $self.Value.ToString("F$($self.DecimalPlaces)")
                    $self.CursorPosition = $self.TextValue.Length
                    if ($self.OnChange) {
                        & $self.OnChange -NewValue $self.Value
                    }
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::DownArrow) {
                    $self.Value = [Math]::Max($self.Min, $self.Value - $self.Step)
                    $self.TextValue = $self.Value.ToString("F$($self.DecimalPlaces)")
                    $self.CursorPosition = $self.TextValue.Length
                    if ($self.OnChange) {
                        & $self.OnChange -NewValue $self.Value
                    }
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::LeftArrow) {
                    if ($self.CursorPosition -gt 0) {
                        $self.CursorPosition--
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::RightArrow) {
                    if ($self.CursorPosition -lt $self.TextValue.Length) {
                        $self.CursorPosition++
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::Home) {
                    $self.CursorPosition = 0
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::End) {
                    $self.CursorPosition = $self.TextValue.Length
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::Backspace) {
                    if ($self.CursorPosition -gt 0) {
                        $self.TextValue = $self.TextValue.Remove($self.CursorPosition - 1, 1)
                        $self.CursorPosition--
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::Delete) {
                    if ($self.CursorPosition -lt $self.TextValue.Length) {
                        $self.TextValue = $self.TextValue.Remove($self.CursorPosition, 1)
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::Enter) {
                    & $self.ValidateAndUpdate
                    Request-TuiRefresh
                    return $true
                }
                default {
                    if ($Key.KeyChar -and ($Key.KeyChar -match '[\d\.\-]')) {
                        $self.TextValue = $self.TextValue.Insert($self.CursorPosition, $Key.KeyChar)
                        $self.CursorPosition++
                        Request-TuiRefresh
                        return $true
                    }
                }
            }
            
            return $false
        }
    }
    
    return [PSCustomObject]$component
}

function global:New-TuiSlider {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "Slider"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 30
        Height = $Props.Height ?? 1
        Value = $Props.Value ?? 50
        Min = $Props.Min ?? 0
        Max = $Props.Max ?? 100
        Step = $Props.Step ?? 1
        ShowValue = $Props.ShowValue ?? $true
        IsFocusable = $true
        
        Render = {
            param($self)
            
            $fg = if ($self.IsFocused) { 
                Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
            } else { 
                Get-ThemeColor "Primary" -Default ([ConsoleColor]::White)
            }
            
            # Calculate position
            $range = $self.Max - $self.Min
            $percent = ($self.Value - $self.Min) / $range
            $trackWidth = $self.Width - 2
            $thumbPos = [Math]::Floor($trackWidth * $percent)
            
            # Draw track
            $track = "─" * $trackWidth
            Write-BufferString -X ($self.X + 1) -Y $self.Y -Text $track -ForegroundColor (Get-ThemeColor "Subtle")
            
            # Draw filled portion
            if ($thumbPos -gt 0) {
                $filled = "═" * $thumbPos
                Write-BufferString -X ($self.X + 1) -Y $self.Y -Text $filled -ForegroundColor $fg
            }
            
            # Draw thumb
            Write-BufferString -X ($self.X + 1 + $thumbPos) -Y $self.Y -Text "●" -ForegroundColor $fg
            
            # Draw bounds
            Write-BufferString -X $self.X -Y $self.Y -Text "[" -ForegroundColor $fg
            Write-BufferString -X ($self.X + $self.Width - 1) -Y $self.Y -Text "]" -ForegroundColor $fg
            
            # Show value
            if ($self.ShowValue) {
                $valueText = $self.Value.ToString()
                $valueX = $self.X + [Math]::Floor(($self.Width - $valueText.Length) / 2)
                Write-BufferString -X $valueX -Y ($self.Y + 1) -Text $valueText -ForegroundColor $fg
            }
        }
        
        HandleInput = {
            param($self, $Key)
            
            $handled = $true
            $oldValue = $self.Value
            
            switch ($Key.Key) {
                ([ConsoleKey]::LeftArrow) {
                    $self.Value = [Math]::Max($self.Min, $self.Value - $self.Step)
                }
                ([ConsoleKey]::RightArrow) {
                    $self.Value = [Math]::Min($self.Max, $self.Value + $self.Step)
                }
                ([ConsoleKey]::Home) {
                    $self.Value = $self.Min
                }
                ([ConsoleKey]::End) {
                    $self.Value = $self.Max
                }
                ([ConsoleKey]::PageDown) {
                    $largeStep = [Math]::Max($self.Step, ($self.Max - $self.Min) / 10)
                    $self.Value = [Math]::Max($self.Min, $self.Value - $largeStep)
                }
                ([ConsoleKey]::PageUp) {
                    $largeStep = [Math]::Max($self.Step, ($self.Max - $self.Min) / 10)
                    $self.Value = [Math]::Min($self.Max, $self.Value + $largeStep)
                }
                default {
                    $handled = $false
                }
            }
            
            if ($handled -and $self.Value -ne $oldValue) {
                if ($self.OnChange) {
                    & $self.OnChange -NewValue $self.Value
                }
                Request-TuiRefresh
            }
            
            return $handled
        }
    }
    
    return [PSCustomObject]$component
}

#endregion

Export-ModuleMember -Function @(
    'New-TuiCalendarPicker',
    'New-TuiSearchableDropdown',
    'New-TuiMultiSelect',
    'New-TuiNumberInput',
    'New-TuiSlider'
)
```