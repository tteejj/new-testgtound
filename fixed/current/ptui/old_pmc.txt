# Core Data Management Module

# Projects, tasks, todos, and command snippets

 

#region Data Model Initialization

 

# Initialize the unified data model

# This $script:Data structure is the source of truth.

# Get-DefaultSettings provides the initial values for $script:Data.Settings.

# Load-UnifiedData will then merge saved data into this structure.

 

function global:Get-DefaultSettings {

    return @{

        # Time Tracker Settings

        DefaultRate = 100.0 # Use double for currency/rate

        Currency = "USD"

        HoursPerDay = 8.0 # Use double for hours

        DaysPerWeek = 5

        TimeTrackerTemplates = @{

            "ADMIN" = @{ Name = "Administrative Tasks"; Id1 = "100"; Id2 = "ADM"; Client = "Internal"; Department = "Operations"; BillingType = "Non-Billable"; Status = "Active"; Budget = 0.0; Rate = 0.0; Notes = "General administrative tasks" }

            "MEETING" = @{ Name = "Meetings & Calls"; Id1 = "101"; Id2 = "MTG"; Client = "Internal"; Department = "Various"; BillingType = "Non-Billable"; Status = "Active"; Budget = 0.0; Rate = 0.0; Notes = "Team meetings and calls" }

            "TRAINING" = @{ Name = "Training & Learning"; Id1 = "102"; Id2 = "TRN"; Client = "Internal"; Department = "HR"; BillingType = "Non-Billable"; Status = "Active"; Budget = 0.0; Rate = 0.0; Notes = "Professional development" }

            "BREAK" = @{ Name = "Breaks & Personal"; Id1 = "103"; Id2 = "BRK"; Client = "Internal"; Department = "Personal"; BillingType = "Non-Billable"; Status = "Active"; Budget = 0.0; Rate = 0.0; Notes = "Breaks and personal time" }

        }

        # Todo Tracker Settings

        DefaultPriority = "Medium"

        DefaultCategory = "General"

        ShowCompletedDays = 7

        EnableTimeTracking = $true # Note: This setting is checked in Add-TodoTask

        AutoArchiveDays = 30

        # Command Snippets Settings

        CommandSnippets = @{

            EnableHotkeys = $true # Note: Actual hotkey binding is external to this script

            AutoCopyToClipboard = $true

            ShowInTaskList = $false # If true, command snippets would appear in regular task views

            DefaultCategory = "Commands"

            RecentLimit = 10

        }

        # Excel Integration Settings

        ExcelFormConfig = @{

            WorksheetName = "Project Info"

            StandardFields = @{

                "Id1" = @{ LabelCell = "A5"; ValueCell = "B5"; Label = "Project ID"; Field = "Id1" }

                "Id2" = @{ LabelCell = "A6"; ValueCell = "B6"; Label = "Task Code"; Field = "Id2" }

                "Name" = @{ LabelCell = "A7"; ValueCell = "B7"; Label = "Project Name"; Field = "Name" }

                "FullName" = @{ LabelCell = "A8"; ValueCell = "B8"; Label = "Full Description"; Field = "FullName" }

                "AssignedDate" = @{ LabelCell = "A9"; ValueCell = "B9"; Label = "Start Date"; Field = "AssignedDate" }

                "DueDate" = @{ LabelCell = "A10"; ValueCell = "B10"; Label = "End Date"; Field = "DueDate" }

                "Manager" = @{ LabelCell = "A11"; ValueCell = "B11"; Label = "Project Manager"; Field = "Manager" }

                "Budget" = @{ LabelCell = "A12"; ValueCell = "B12"; Label = "Budget"; Field = "Budget" }

                "Status" = @{ LabelCell = "A13"; ValueCell = "B13"; Label = "Status"; Field = "Status" }

                "Priority" = @{ LabelCell = "A14"; ValueCell = "B14"; Label = "Priority"; Field = "Priority" }

                "Department" = @{ LabelCell = "A15"; ValueCell = "B15"; Label = "Department"; Field = "Department" }

                "Client" = @{ LabelCell = "A16"; ValueCell = "B16"; Label = "Client"; Field = "Client" }

                "BillingType" = @{ LabelCell = "A17"; ValueCell = "B17"; Label = "Billing Type"; Field = "BillingType" }

                "Rate" = @{ LabelCell = "A18"; ValueCell = "B18"; Label = "Hourly Rate"; Field = "Rate" }

            }

        }

        # UI Theme (Legacy ConsoleColor names for Write-Host -ForegroundColor compatibility)

        Theme = @{

            Header = "Cyan"

            Success = "Green"

            Warning = "Yellow"

            Error = "Red"

            Info = "Blue"

            Accent = "Magenta"

            Subtle = "DarkGray"

        }

        QuickActionTipShown = $false # New setting for one-time tip

    }

}

 

# Define the $script:Data structure with defaults.

# Get-WeekStart must be loaded (from helper.ps1) before this script is sourced if main.ps1 calls it directly.

# However, Get-DefaultSettings is self-contained.

$script:Data = @{

    Projects = @{}     

    Tasks = @()        

    TimeEntries = @()  

    ActiveTimers = @{} 

    ArchivedTasks = @()

    ExcelCopyJobs = @{}

    CurrentWeek = Get-WeekStart (Get-Date) # Get-WeekStart is from helper.ps1

    Settings = Get-DefaultSettings

}

 

#endregion

 

#region Project Management

 

function global:Get-ProjectOrTemplate {

    param([string]$Key)

 

    if ([string]::IsNullOrEmpty($Key)) { return $null }

   

    if ($script:Data.Projects.ContainsKey($Key)) {

        return $script:Data.Projects[$Key]

    } elseif ($script:Data.Settings.TimeTrackerTemplates.ContainsKey($Key.ToUpper())) { # Template keys are often uppercase

        return $script:Data.Settings.TimeTrackerTemplates[$Key.ToUpper()]

    }

   

    return $null

}

 

function global:Show-ProjectsAndTemplates {

    param([switch]$Simple)

   

    Write-Host "`nProjects:" -ForegroundColor Yellow

    if (-not $script:Data.Projects -or $script:Data.Projects.Count -eq 0) {

        Write-Host "  No projects defined." -ForegroundColor Gray

    } else {

        foreach ($proj in $script:Data.Projects.GetEnumerator() | Sort-Object {$_.Value.Name}) {

            Write-Host "  [$($proj.Key)] $($proj.Value.Name)" -NoNewline

            if ($proj.Value.Client) { Write-Host " ($($proj.Value.Client))" -NoNewline }

            if (-not $Simple) { Write-Host " (Status: $($proj.Value.Status))" } else { Write-Host }

        }

    }

 

    Write-Host "`nTemplates:" -ForegroundColor Yellow

    if (-not $script:Data.Settings.TimeTrackerTemplates -or $script:Data.Settings.TimeTrackerTemplates.Count -eq 0) {

        Write-Host "  No templates defined." -ForegroundColor Gray

    } else {

        foreach ($tmpl in $script:Data.Settings.TimeTrackerTemplates.GetEnumerator()) {

            Write-Host "  [$($tmpl.Key)] $($tmpl.Value.Name)"

        }

    }

}

 

function global:Show-ProjectDetail {

    Write-Header "Project Details"

    Show-ProjectsAndTemplates -Simple

    $key = Read-Host "`nProject/Template Key for details (or Enter to cancel)"

    if ([string]::IsNullOrEmpty($key)) { Write-Info "Cancelled."; return }

 

    $project = Get-ProjectOrTemplate $key

    if ($project) {

        Clear-Host

        Write-Header "Details for: $($project.Name) (Key: $key)"

        # Update statistics for real projects before showing

        if ($script:Data.Projects.ContainsKey($key)) {

            Update-ProjectStatistics -ProjectKey $key

            $project = $script:Data.Projects[$key] # Re-fetch updated project

        }

       

        # Display properties dynamically

        $properties = $project.PSObject.Properties | Select-Object Name, Value | Where-Object { $_.Name -ne "PSParentPath" -and $_.Name -ne "PSChildName" } # Exclude default PS properties

        foreach ($prop in $properties) {

            # Skip empty notes, assuming it's an optional field

            if ($prop.Name -eq "Notes" -and [string]::IsNullOrEmpty($prop.Value)) { continue }

            Write-Host "  $($prop.Name.PadRight(18)): $($prop.Value)"

        }

       

        # Display budget status if applicable

        if ($project.BillingType -eq "Billable" -and $project.Budget -gt 0) {

            Write-Host "`nBudget Status:"

            $percentUsed = ($project.TotalHours / $project.Budget) * 100

            Write-Host "  Budget: $($project.Budget) hours, Used: $($project.TotalHours) hours ($([Math]::Round($percentUsed, 1))% used)"

            Show-BudgetWarning -ProjectKey $key # Use existing warning logic

        }

        Write-Host "`nPress any key to continue..."

        $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")

    } else {

        Write-Error "Project or Template '$key' not found."

    }

}

 

function global:Import-ProjectFromExcel {

    Write-Header "Import Project from Excel Form"

    Write-Warning "Excel import feature is not yet fully implemented in this version."

    Write-Info "Please refer to documentation for future updates."

    Write-Host "`nPress any key to continue..."

    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")

}

 

function global:Configure-ExcelForm {

    Write-Header "Configure Excel Form Import Mapping"

    Write-Warning "Excel configuration for import mapping is not yet fully implemented."

    Write-Info "This feature is under development."

    Write-Host "`nPress any key to continue..."

    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")

}

 

function global:Add-Project {

    Write-Header "Add New Project"

   

    $projectKeyInput = Read-Host "Project Key (short identifier)" # Renamed variable

    if ([string]::IsNullOrEmpty($projectKeyInput)) { Write-Error "Project key cannot be empty."; return }

    if ($script:Data.Projects.ContainsKey($projectKeyInput) -or $script:Data.Settings.TimeTrackerTemplates.ContainsKey($projectKeyInput.ToUpper())) {

        Write-Error "Project key '$projectKeyInput' already exists as a project or template."

        return

    }

   

    Write-Host "`nBasic Information:" -ForegroundColor Yellow

    $projectName = Read-Host "Project Name" # Renamed variable

    if ([string]::IsNullOrEmpty($projectName)) { Write-Error "Project name cannot be empty."; return }

    $id1 = Read-Host "ID1 (custom identifier, optional)"

    $id2 = Read-Host "ID2 (max 9 chars, optional)"

   

    Write-Host "`nClient & Department:" -ForegroundColor Yellow

    $client = Read-Host "Client Name (optional)"

    $department = Read-Host "Department (optional)"

   

    Write-Host "`nBilling Information:" -ForegroundColor Yellow

    Write-Host "Billing Type: [B]illable, [N]on-Billable, [F]ixed Price (default: Non-Billable)"

    $billingChoice = Read-Host "Choice (B/N/F)"

    $billingType = switch ($billingChoice.ToUpper()) {

        "B" { "Billable" }

        "F" { "Fixed Price" }

        default { "Non-Billable" }

    }

   

    $rate = 0.0

    $budget = 0.0

   

    if ($billingType -ne "Non-Billable") {

        $rateInput = Read-Host "Hourly Rate (default: $($script:Data.Settings.DefaultRate))"

        if (-not [string]::IsNullOrWhiteSpace($rateInput)) {

            try { $rate = [double]$rateInput } catch { Write-Warning "Invalid rate format, using 0.0."; $rate = 0.0 }

        } else {

            $rate = $script:Data.Settings.DefaultRate

        }

       

        $budgetInput = Read-Host "Budget Hours (0 for unlimited, optional)"

        if (-not [string]::IsNullOrWhiteSpace($budgetInput)) {

            try { $budget = [double]$budgetInput } catch { Write-Warning "Invalid budget format, using 0.0."; $budget = 0.0 }

        }

    }

   

    Write-Host "`nProject Status:" -ForegroundColor Yellow

    Write-Host "[A]ctive, [O]n Hold, [C]ompleted (default: Active)"

    $statusChoice = Read-Host "Status (A/O/C)"

    $status = switch ($statusChoice.ToUpper()) {

        "O" { "On Hold" }

        "C" { "Completed" }

        default { "Active" }

    }

   

    $notes = Read-Host "`nProject Notes (optional)"

   

    $startDate = (Get-Date).ToString("yyyy-MM-dd") # Default start date to today

   

    $script:Data.Projects[$projectKeyInput] = @{

        Name = $projectName

        Id1 = $id1

        Id2 = $id2

        Client = $client

        Department = $department

        BillingType = $billingType

        Rate = $rate

        Budget = $budget

        Status = $status

        Notes = $notes

        StartDate = $startDate

        TotalHours = 0.0     

        TotalBilled = 0.0    

        CompletedTasks = 0   

        ActiveTasks = 0      

        Manager = ""         

        Priority = "Medium"  

        DueDate = $null      

        CreatedDate = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")

    }

   

    Save-UnifiedData

    Write-Success "Project added: $projectKeyInput - $projectName"

}

 

function global:Edit-Project {

    Show-ProjectsAndTemplates -Simple

    Write-Host ""

    $projectKeyToEdit = Read-Host "Enter project key to edit" # Renamed variable

    if([string]::IsNullOrWhiteSpace($projectKeyToEdit)) { Write-Info "Edit cancelled."; return }

   

    if (-not $script:Data.Projects.ContainsKey($projectKeyToEdit)) {

        Write-Error "Project '$projectKeyToEdit' not found or cannot edit templates this way."

        return

    }

   

    $project = $script:Data.Projects[$projectKeyToEdit]

   

    Write-Header "Edit Project: $projectKeyToEdit ($($project.Name))"

    Write-Host "Leave field empty to keep current value." -ForegroundColor Gray

   

    $fieldPrompts = @(

        @{Prop="Name"; Prompt="New Name"; Current=$project.Name}

        @{Prop="Client"; Prompt="New Client"; Current=$project.Client}

        @{Prop="Department"; Prompt="New Department"; Current=$project.Department}

        @{Prop="Id1"; Prompt="New ID1"; Current=$project.Id1}

        @{Prop="Id2"; Prompt="New ID2 (max 9 chars)"; Current=$project.Id2}

        @{Prop="Status"; Prompt="New Status ([A]ctive, [O]n Hold, [C]ompleted)"; Current=$project.Status; Type="Status"}

        @{Prop="BillingType"; Prompt="New Billing Type ([B]illable, [N]on-Billable, [F]ixed Price)"; Current=$project.BillingType; Type="BillingType"}

        @{Prop="Rate"; Prompt="New Rate"; Current=$project.Rate; Type="Double"; Condition={$project.BillingType -ne "Non-Billable"}}

        @{Prop="Budget"; Prompt="New Budget Hours"; Current=$project.Budget; Type="Double"; Condition={$project.BillingType -ne "Non-Billable"}}

        @{Prop="Notes"; Prompt="New Notes (enter 'clear' to empty)"; Current=$project.Notes; Type="StringAllowClear"}

        @{Prop="StartDate"; Prompt="New Start Date (YYYY-MM-DD)"; Current=$project.StartDate; Type="Date"}

        @{Prop="DueDate"; Prompt="New Due Date (YYYY-MM-DD, or 'clear')"; Current=$project.DueDate; Type="DateAllowClear"}

        @{Prop="Manager"; Prompt="New Project Manager"; Current=$project.Manager}

        @{Prop="Priority"; Prompt="New Project Priority ([C]ritical, [H]igh, [M]edium, [L]ow)"; Current=$project.Priority; Type="ProjectPriority"}

    )

 

    $changesMade = $false

    foreach($field in $fieldPrompts) {

        if ($field.Condition -and -not (& $field.Condition)) { continue } # Skip if condition not met

 

        Write-Host "`nCurrent $($field.Prop): $($field.Current)"

        $newValue = Read-Host $field.Prompt

       

        if (-not [string]::IsNullOrWhiteSpace($newValue)) {

            $validUpdate = $true

            $oldFieldValue = $project.($field.Prop) # Store old value for comparison

            switch ($field.Type) {

                "Double" { try { $project.($field.Prop) = [double]$newValue } catch { Write-Warning "Invalid number for $($field.Prop). Not changed."; $validUpdate = $false } }

                "Status" {

                    $project.($field.Prop) = switch ($newValue.ToUpper()) {

                        "A" { "Active" } "O" { "On Hold" } "C" { "Completed" } default { $project.($field.Prop) }

                    }

                    if ($project.($field.Prop) -eq $field.Current -and $newValue.ToUpper() -notin @("A","O","C")) {$validUpdate = $false; Write-Warning "Invalid status. Not changed."}

                }

                "BillingType" {

                     $project.($field.Prop) = switch ($newValue.ToUpper()) {

                        "B" { "Billable" } "N" { "Non-Billable" } "F" { "Fixed Price"} default { $project.($field.Prop) }

                    }

                    if ($project.($field.($field.Prop)) -eq $field.Current -and $newValue.ToUpper() -notin @("B","N","F")) {$validUpdate = $false; Write-Warning "Invalid billing type. Not changed."}

                }

                "Date" { try { $project.($field.Prop) = ([datetime]::Parse($newValue)).ToString("yyyy-MM-dd") } catch { Write-Warning "Invalid date for $($field.Prop). Not changed."; $validUpdate = $false } }

                "DateAllowClear" {

                    if ($newValue.ToLower() -eq 'clear') { $project.($field.Prop) = $null }

                    else { try { $project.($field.Prop) = ([datetime]::Parse($newValue)).ToString("yyyy-MM-dd") } catch { Write-Warning "Invalid date for $($field.Prop). Not changed."; $validUpdate = $false } }

                }

                "StringAllowClear" { if ($newValue.ToLower() -eq 'clear') { $project.($field.Prop) = "" } else { $project.($field.Prop) = $newValue } }

                 "ProjectPriority" {

                    $project.($field.Prop) = switch ($newValue.ToUpper()) {

                        "C" { "Critical" } "H" { "High" } "M" { "Medium" } "L" { "Low" } default { $project.($field.Prop) }

                    }

                     if ($project.($field.Prop) -eq $field.Current -and $newValue.ToUpper() -notin @("C","H","M","L")) {$validUpdate = $false; Write-Warning "Invalid priority. Not changed."}

                }

                default { $project.($field.Prop) = $newValue }

            }

            if ($validUpdate -and $project.($field.Prop) -ne $oldFieldValue) { $changesMade = $true }

        }

    }

   

    if ($changesMade) {

        Save-UnifiedData

        Write-Success "Project '$projectKeyToEdit' updated!"

    } else {

        Write-Info "No changes made to project '$projectKeyToEdit'."

    }

}

 

function global:Update-ProjectStatistics {

    param([string]$ProjectKey)

   

    if (-not $script:Data.Projects.ContainsKey($ProjectKey)) { return }

    $project = $script:Data.Projects[$ProjectKey]

   

    $projectEntries = $script:Data.TimeEntries | Where-Object { $_.ProjectKey -eq $ProjectKey }

    $project.TotalHours = [Math]::Round(($projectEntries | Measure-Object -Property Hours -Sum).Sum, 2)

   

    $projectTasks = $script:Data.Tasks | Where-Object { $_.ProjectKey -eq $ProjectKey -and ($_.IsCommand -ne $true) }

    $project.CompletedTasks = ($projectTasks | Where-Object { $_.Completed }).Count

    $project.ActiveTasks = ($projectTasks | Where-Object { -not $_.Completed }).Count

}

 

function global:Export-Projects {

    Write-Header "Export Projects"

   

    if (-not $script:Data.Projects -or $script:Data.Projects.Count -eq 0) {

        Write-Warning "No projects to export."

        return

    }

 

    $exportData = @()

    foreach ($projEnum in $script:Data.Projects.GetEnumerator()) {

        $projValue = $projEnum.Value

        $exportData += [PSCustomObject]@{

            Key = $projEnum.Key

            Name = $projValue.Name

            Id1 = $projValue.Id1

            Id2 = $projValue.Id2

            Client = $projValue.Client

            Department = $projValue.Department

            Status = $projValue.Status

            BillingType = $projValue.BillingType

            Rate = $projValue.Rate

            Budget = $projValue.Budget

            TotalHours = $projValue.TotalHours

            ActiveTasks = $projValue.ActiveTasks

            CompletedTasks = $projValue.CompletedTasks

            StartDate = $projValue.StartDate

            DueDate = $projValue.DueDate

            Manager = $projValue.Manager

            ProjectPriority = $projValue.Priority

            Notes = $projValue.Notes

            CreatedDate = $projValue.CreatedDate

        }

    }

   

    $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"

    $exportFile = Join-Path ([Environment]::GetFolderPath("Desktop")) "Projects_Export_$timestamp.csv"

   

    try {

        $exportData | Export-Csv $exportFile -NoTypeInformation -Encoding UTF8

        Write-Success "Projects exported to: $exportFile"

        if ((Read-Host "Open file now? (Y/N)").ToUpper() -eq 'Y') { Start-Process $exportFile }

    } catch {

        Write-Error "Failed to export projects: $_"

    }

}

 

function global:Batch-ImportProjects {

    Write-Warning "Batch Import Projects feature not yet implemented."

}

 

function global:Show-ProjectSummary {

    Write-Header "Project Summary Report"

    if (-not $script:Data.Projects -or $script:Data.Projects.Count -eq 0) {

        Write-Warning "No projects available to summarize."

        return

    }

 

    $projectSummaryData = @()

    foreach ($key in ($script:Data.Projects.Keys | Sort-Object)) {

        Update-ProjectStatistics -ProjectKey $key

        $p = $script:Data.Projects[$key]

        $projectSummaryData += [PSCustomObject]@{

            Key = $key

            Name = $p.Name

            Client = $p.Client

            Status = $p.Status

            Budget = $p.Budget

            TotalHours = $p.TotalHours

            RemainingHours = if ($p.Budget -gt 0) { [Math]::Round($p.Budget - $p.TotalHours, 2) } else { "N/A" }

            Progress = if ($p.Budget -gt 0 -and $p.TotalHours -ge 0) {

                           if ($p.TotalHours -eq 0 -and $p.Budget -gt 0) { "0%" }

                           elseif ($p.TotalHours -gt 0) { "$([Math]::Round(($p.TotalHours / $p.Budget) * 100, 1))%" }

                           else { "N/A" }

                       } else { "N/A" }

            ActiveTasks = $p.ActiveTasks

        }

    }

 

    $projectSummaryData | Format-TableUnicode -Columns @(

        @{Name="Key"; Title="Key"; Width=10},

        @{Name="Name"; Title="Project Name"; Width=25},

        @{Name="Client"; Title="Client"; Width=15},   

        @{Name="Status"; Title="Status"; Width=12},

        @{Name="Budget"; Title="Budget (h)"; Width=10; Align="Right"},

        @{Name="TotalHours"; Title="Used (h)"; Width=10; Align="Right"},

        @{Name="RemainingHours"; Title="Rem (h)"; Width=10; Align="Right"},

        @{Name="Progress"; Title="Progress %"; Width=12; Align="Right"},

        @{Name="ActiveTasks"; Title="Active Tasks"; Width=12; Align="Right"}

    ) -Title "Project Summary" -BorderStyle "Rounded"

}

 

#endregion

 

#region Command Snippets System

 

function global:Add-CommandSnippet {

    Write-Header "Add Command Snippet"

   

    $snippetName = Read-Host "Command name/description"

    if ([string]::IsNullOrEmpty($snippetName)) {

        Write-Error "Command name cannot be empty!"

        return

    }

   

    Write-Host "`nEnter command (press Enter on an empty line to finish if content exists, or two empty lines if starting empty):" -ForegroundColor Gray

    $lines = @()

    $emptyLineCount = 0

    while ($true) {

        $line = Read-Host

        if ([string]::IsNullOrEmpty($line)) {

            $emptyLineCount++

            if ($emptyLineCount -ge 2 -or ($lines.Count -gt 0 -and $emptyLineCount -ge 1) ) {

                break

            }

        } else {

            $emptyLineCount = 0

        }

        $lines += $line

    }

   

    $commandText = $lines -join "`n"

    if ([string]::IsNullOrWhiteSpace($commandText)) {

        Write-Error "Command cannot be empty!"

        return

    }

   

    $existingCategories = $script:Data.Tasks |

        Where-Object { $_.IsCommand -eq $true -and (-not [string]::IsNullOrEmpty($_.Category)) } |

        Select-Object -ExpandProperty Category -Unique | Sort-Object

   

    if ($existingCategories) {

        Write-Host "`nExisting categories: $($existingCategories -join ', ')" -ForegroundColor DarkCyan

    }

    $category = Read-Host "Category (default: $($script:Data.Settings.CommandSnippets.DefaultCategory))"

    if ([string]::IsNullOrEmpty($category)) {

        $category = $script:Data.Settings.CommandSnippets.DefaultCategory

    }

   

    Write-Host "`nTags (comma-separated, optional):" -ForegroundColor Gray

    $tagsInput = Read-Host "Tags"

    $tags = if (-not [string]::IsNullOrWhiteSpace($tagsInput)) {

        $tagsInput -split ',' | ForEach-Object { $_.Trim() } | Where-Object { -not [string]::IsNullOrWhiteSpace($_) }

    } else { @() }

   

    $hotkey = ""

    if ($script:Data.Settings.CommandSnippets.EnableHotkeys) {

        Write-Host "`nAssign hotkey (optional, e.g., 'ctrl+1'):" -ForegroundColor Gray

        $hotkey = Read-Host "Hotkey"

    }

   

    $snippet = @{

        Id = New-TodoId

        Description = $snippetName

        Priority = "Low"

        Category = $category

        ProjectKey = $null

        StartDate = $null

        DueDate = $null

        Tags = $tags

        Progress = 0

        Completed = $false

        CreatedDate = [datetime]::Now.ToString("yyyy-MM-dd HH:mm:ss")

        CompletedDate = $null

        EstimatedTime = 0

        TimeSpent = 0

        Subtasks = @()

        Notes = $commandText

        LastModified = [datetime]::Now.ToString("yyyy-MM-dd HH:mm:ss")

        IsCommand = $true

        Hotkey = $hotkey

        LastUsed = $null

        UseCount = 0

    }

   

    $script:Data.Tasks += $snippet

    Save-UnifiedData

   

    Write-Success "Command snippet added: $snippetName"

   

    if ($script:Data.Settings.CommandSnippets.AutoCopyToClipboard) {

        if (Copy-ToClipboard $commandText) {

            Write-Info "Command copied to clipboard!"

        }

    }

}

 

function global:Get-CommandSnippet {

    param(

        [string]$Id,

        [string]$SearchTerm,

        [string]$CategoryFilter,

        [string[]]$TagsFilter 

    )

   

    $snippets = $script:Data.Tasks | Where-Object { $_.IsCommand -eq $true }

   

    if ($Id) {

        return $snippets | Where-Object { $_.Id -like "$Id*" } | Select-Object -First 1

    }

   

    if ($SearchTerm) {

        $snippets = $snippets | Where-Object {

            $_.Description -like "*$SearchTerm*" -or

            $_.Notes -like "*$SearchTerm*" -or

            ($_.Tags -and ($_.Tags -join " ") -like "*$SearchTerm*")

        }

    }

   

    if ($CategoryFilter) {

        $snippets = $snippets | Where-Object { $_.Category -eq $CategoryFilter }

    }

   

    if ($TagsFilter -and $TagsFilter.Count -gt 0) {

        $snippets = $snippets | Where-Object {

            $snippetTags = $_.Tags

            if (-not $snippetTags) { return $false }

            $foundAll = $true

            foreach ($tagToFind in $TagsFilter) {

                if ($tagToFind -notin $snippetTags) {

                    $foundAll = $false; break

                }

            }

            $foundAll

        }

    }

   

    return $snippets

}

 

#function global:Search-CommandSnippets {

#    Write-Header "Search Command Snippets"

   

#    $searchTerm = Read-Host "Search term (name, content, tags; leave empty for all)"

#    $categoryFilter = Read-Host "Filter by category (optional, exact match)"

#    $tagsInput = Read-Host "Filter by tags (comma-separated, AND logic; optional)"

#    $tagsFilter = if (-not [string]::IsNullOrWhiteSpace($tagsInput)) {

#        $tagsInput -split ',' | ForEach-Object {$_.Trim()} | Where-Object { -not [string]::IsNullOrWhiteSpace($_)}

#    } else { $null }

 

#    $snippets = Get-CommandSnippet -SearchTerm $searchTerm -CategoryFilter $categoryFilter -TagsFilter $tagsFilter |

#                Sort-Object UseCount -Descending, @{Expression = {if($_.LastUsed){try{[datetime]$_.LastUsed}catch{[datetime]::MinValue}}else#{[datetime]::MinValue}}; Descending = $true}, Description

   

#    if ($snippets.Count -eq 0) {

#        Write-Host "No snippets found matching your criteria." -ForegroundColor Gray

#        return

#    }

   

#    $tableData = $snippets | ForEach-Object {

#        [PSCustomObject]@{

#            ID = $_.Id.Substring(0, 6)

#            Name = $_.Description

#            Category = $_.Category

#            Tags = if ($_.Tags) { ($_.Tags -join ", ") } else { "" }

#            Used = $_.UseCount

#            Hotkey = if ($_.Hotkey) { $_.Hotkey } else { "-" }

#        }

#    }

   

#    $tableData | Format-TableUnicode -Columns @(

#        @{Name="ID"; Title="ID"; Width=8}

#        @{Name="Name"; Title="Name"; Width=30}

#        @{Name="Category"; Title="Category"; Width=15}

#        @{Name="Tags"; Title="Tags"; Width=20}

#        @{Name="Used"; Title="Used"; Width=6; Align="Right"}

#        @{Name="Hotkey"; Title="Hotkey"; Width=10}

#    ) -Title "Command Snippets"

   

#    Write-Host "`nEnter snippet ID to copy/execute, or press Enter to cancel."

#    $selectedId = Read-Host

   

#    if (-not [string]::IsNullOrWhiteSpace($selectedId)) {

#        Execute-CommandSnippet -Id $selectedId

#    }

#}

 

function global:Execute-CommandSnippet {

    param([string]$Id)

   

    $snippet = Get-CommandSnippet -Id $Id

    if (-not $snippet) {

        Write-Error "Snippet with ID starting '$Id' not found!"

        return

    }

   

    Write-Host "`nCommand: $($snippet.Description)" -ForegroundColor Cyan

    Write-Host "Category: $($snippet.Category)" -ForegroundColor Gray

    if ($snippet.Tags -and $snippet.Tags.Count -gt 0) {

        Write-Host "Tags: $($snippet.Tags -join ', ')" -ForegroundColor Gray

    }

   

    Write-Host "`nCommand content:" -ForegroundColor Yellow

    Write-Host $snippet.Notes -ForegroundColor White

   

    # Update usage stats

    $snippet.LastUsed = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")

    $snippet.UseCount = [int]$snippet.UseCount + 1

    Save-UnifiedData

   

    Write-Host "`n[C]opy to clipboard, [E]xecute (PowerShell), [B]oth, or [Enter] to cancel"

    $actionChoice = Read-Host

    

    switch ($actionChoice.ToUpper()) {

        "C" {

            if (Copy-ToClipboard $snippet.Notes) {

                Write-Success "Command copied to clipboard!"

            }

        }

        "E" {

            Write-Warning "Are you sure you want to execute this command in the current PowerShell session?"

            $confirmExecution = Read-Host "Type 'yes' to confirm"

            if ($confirmExecution -eq 'yes') {

                try {

                    Invoke-Expression $snippet.Notes

                    Write-Success "Command executed!"

                } catch {

                    Write-Error "Execution failed: $_"

                }

            } else { Write-Info "Execution cancelled."}

        }

        "B" {

            if (Copy-ToClipboard $snippet.Notes) {

                Write-Success "Command copied to clipboard!"

            }

            Write-Warning "Are you sure you want to execute this command in the current PowerShell session?"

            $confirmExecuteBoth = Read-Host "Type 'yes' to confirm execution"

            if ($confirmExecuteBoth -eq 'yes') {

                try {

                    Invoke-Expression $snippet.Notes

                    Write-Success "Command executed!"

                } catch {

                    Write-Error "Execution failed: $_"

                }

            } else { Write-Info "Execution (part of 'Both') cancelled."}

        }

        default { Write-Info "Action cancelled."}

    }

}

 

function global:Remove-CommandSnippet {

    param([string]$IdInput)

    

    $idToRemove = $IdInput

    if (-not $idToRemove) {

        Search-CommandSnippets

        $idToRemove = Read-Host "`nEnter snippet ID to delete (after viewing list if shown), or Enter to cancel"

        if ([string]::IsNullOrWhiteSpace($idToRemove)) { Write-Info "Deletion cancelled."; return }

    }

   

    $snippet = Get-CommandSnippet -Id $idToRemove

    if (-not $snippet) {

        Write-Error "Snippet with ID starting '$idToRemove' not found!"

        return

    }

   

    Write-Warning "Delete snippet: '$($snippet.Description)' (ID: $($snippet.Id.Substring(0,6)))?"

    $confirm = Read-Host "Type 'yes' to confirm"

   

    if ($confirm -eq 'yes') {

        $script:Data.Tasks = $script:Data.Tasks | Where-Object { $_.Id -ne $snippet.Id }

        Save-UnifiedData

        Write-Success "Snippet deleted!"

    } else { Write-Info "Deletion cancelled."}

}

 

function global:Manage-CommandSnippets {

    while ($true) {

        Write-Header "Command Snippets"

       

        $snippetCount = ($script:Data.Tasks | Where-Object { $_.IsCommand -eq $true }).Count

        Write-Host "Total snippets: $snippetCount" -ForegroundColor Gray

       

        $recentSnippets = Get-RecentCommandSnippets -Count 5

        if ($recentSnippets.Count -gt 0) {

            Write-Host "`nRecent snippets:" -ForegroundColor Yellow

            foreach ($snippet in $recentSnippets) {

                Write-Host "  [$($snippet.Id.Substring(0,6))] $($snippet.Description)" -NoNewline

                if ($snippet.Hotkey) {

                    Write-Host " ($($snippet.Hotkey))" -NoNewline -ForegroundColor DarkCyan

                }

                Write-Host " - Used: $($snippet.UseCount)" -ForegroundColor Gray

            }

        }

       

        Write-Host "`n[A]dd snippet"

        Write-Host "[S]earch/Browse snippets"

        Write-Host "[E]xecute by ID"

        Write-Host "[D]elete by ID"

        Write-Host "[L]ist Categories"

        Write-Host "List [H]otkeys"   

        Write-Host "[B]ack to Tools Menu"

       

        $choice = Read-Host "`nChoice"

       

        $actionTaken = $true

        switch ($choice.ToLower()) {

            "a" { Add-CommandSnippet }

            "s" { Search-CommandSnippets }

            "e" {

                $idToExecute = Read-Host "Snippet ID to execute"

                if (-not [string]::IsNullOrWhiteSpace($idToExecute)) {

                    Execute-CommandSnippet -Id $idToExecute

                } else { $actionTaken = $false }

            }

            "d" {

                $idToDelete = Read-Host "Snippet ID to delete"

                if (-not [string]::IsNullOrWhiteSpace($idToDelete)) {

                    Remove-CommandSnippet -IdInput $idToDelete

                } else { $actionTaken = $false }

            }

            "l" { Show-SnippetCategories }

            "h" { Show-SnippetHotkeys }   

            "b" { return }

            default {

                 if (-not [string]::IsNullOrEmpty($choice)) {

                    Write-Warning "Unknown command."

                 }

                 $actionTaken = $false

            }

        }

       

        if ($actionTaken) {

            Write-Host "`nPress Enter to continue..."

            Read-Host

        }

    }

}

 

function global:Get-RecentCommandSnippets {

    param([int]$Count = 10)

   

    $snippets = $script:Data.Tasks | Where-Object { $_.IsCommand -eq $true }

   

    $sortedSnippets = $snippets | Sort-Object @{

        Expression = { $_.UseCount }; Descending = $true # <-- MODIFIED

    }, @{

        Expression = { if ($_.LastUsed) { try {[DateTime]::Parse($_.LastUsed)} catch {[DateTime]::MinValue} } else { [DateTime]::MinValue } }

        Descending = $true

    }, Description

    

    return $sortedSnippets | Select-Object -First $Count

}

 

function global:Show-SnippetCategories {

    Write-Header "Snippet Categories"

   

    $snippets = $script:Data.Tasks | Where-Object { $_.IsCommand -eq $true }

    if ($snippets.Count -eq 0) {

        Write-Host "No snippets found to categorize." -ForegroundColor Gray

        return

    }

    $categories = $snippets | Group-Object Category | Sort-Object Count -Descending

   

    if ($categories.Count -eq 0) {

        Write-Host "No categories assigned to snippets." -ForegroundColor Gray

        return

    }

   

    Write-Host "Category usage:" -ForegroundColor Yellow

    foreach ($catGroup in $categories) {

        $categoryName = if ([string]::IsNullOrEmpty($catGroup.Name)) {"[Uncategorized]"} else {$catGroup.Name}

        Write-Host "  $categoryName $($catGroup.Count) snippet(s)"

       

        $topInCategory = $catGroup.Group | Sort-Object UseCount -Descending | Sort-Object Description | Select-Object -First 3

        foreach ($snippet in $topInCategory) {

            Write-Host "    - $($snippet.Description) (Used: $($snippet.UseCount))" -ForegroundColor Gray

        }

    }

}

 

 

 

function global:Show-SnippetHotkeys {

    Write-Header "Snippet Hotkeys"

   

    $snippetsWithHotkeys = $script:Data.Tasks | Where-Object { $_.IsCommand -eq $true -and (-not [string]::IsNullOrEmpty($_.Hotkey)) }

   

    if ($snippetsWithHotkeys.Count -eq 0) {

        Write-Host "No hotkeys assigned to any snippets." -ForegroundColor Gray

        return

    }

   

    Write-Host "Assigned hotkeys:" -ForegroundColor Yellow

    foreach ($snippet in $snippetsWithHotkeys | Sort-Object Hotkey) {

        Write-Host "  $($snippet.Hotkey): $($snippet.Description) (ID: $($snippet.Id.Substring(0,6)))"

    }

   

    Write-Warning "`nNote: Actual hotkey binding functionality requires an external keyboard hook implementation (not included in this script suite)."

}

 

function global:Edit-CommandSnippetSettings {

    Write-Header "Command Snippet Settings"

   

    if (-not $script:Data.Settings.CommandSnippets) {

        $script:Data.Settings.CommandSnippets = (Get-DefaultSettings).CommandSnippets

    }

    $csSettings = $script:Data.Settings.CommandSnippets

 

    Write-Host "Current settings:" -ForegroundColor Yellow

    Write-Host "  Enable Hotkeys:       $(if ($csSettings.EnableHotkeys) { 'Yes' } else { 'No' }) (Note: actual binding is external)"

    Write-Host "  Auto-Copy on Add:     $(if ($csSettings.AutoCopyToClipboard) { 'Yes' } else { 'No' })"

    Write-Host "  Show in Task List:   $(if ($csSettings.ShowInTaskList) { 'Yes' } else { 'No' })"

    Write-Host "  Default Category:    $($csSettings.DefaultCategory)"

    Write-Host "  Recent Snippets Limit: $($csSettings.RecentLimit)"

   

    Write-Host "`nLeave empty to keep current value." -ForegroundColor Gray

   

    $enableHotkeysInput = Read-Host "`nEnable hotkeys? (Y/N)"

    if (-not [string]::IsNullOrWhiteSpace($enableHotkeysInput)) {

        $csSettings.EnableHotkeys = ($enableHotkeysInput.ToUpper() -eq 'Y')

    }

   

    $autoCopyInput = Read-Host "`nAuto-copy to clipboard when adding a new snippet? (Y/N)"

    if (-not [string]::IsNullOrWhiteSpace($autoCopyInput)) {

        $csSettings.AutoCopyToClipboard = ($autoCopyInput.ToUpper() -eq 'Y')

    }

   

    $showInTasksInput = Read-Host "`nShow command snippets in the main task list views? (Y/N)"

    if (-not [string]::IsNullOrWhiteSpace($showInTasksInput)) {

        $csSettings.ShowInTaskList = ($showInTasksInput.ToUpper() -eq 'Y')

    }

   

    $newDefaultCategory = Read-Host "`nDefault category for new snippets (current: $($csSettings.DefaultCategory))"

    if (-not [string]::IsNullOrWhiteSpace($newDefaultCategory)) {

        $csSettings.DefaultCategory = $newDefaultCategory

    }

   

    $newRecentLimitStr = Read-Host "`nNumber of recent snippets to show (current: $($csSettings.RecentLimit))"

    if (-not [string]::IsNullOrWhiteSpace($newRecentLimitStr)) {

        try {

            $limit = [int]$newRecentLimitStr

            if ($limit -ge 0) { $csSettings.RecentLimit = $limit }

            else { Write-Warning "Limit must be non-negative. Not changed."}

        } catch {

            Write-Warning "Invalid number format for limit. Not changed."

        }

    }

   

    Save-UnifiedData

    Write-Success "Command Snippet settings updated!"

}

 

#endregion

 

#region Task Management Functions

 

function global:Add-TodoTask {

    Write-Header "Add New Task"

   

    $description = Read-Host "`nTask description"

    if ([string]::IsNullOrEmpty($description)) {

        Write-Error "Task description cannot be empty!"

        return

    }

   

    Write-Host "`nPriority: [C]ritical, [H]igh, [M]edium, [L]ow (default: $($script:Data.Settings.DefaultPriority))" -ForegroundColor Gray

    $priorityInput = Read-Host "Priority"

    $priority = switch ($priorityInput.ToUpper()) {

        "C" { "Critical" } "H" { "High" } "L" { "Low" } "M" { "Medium" }

        default { $script:Data.Settings.DefaultPriority }

    }

   

    $existingCategories = $script:Data.Tasks |

        Where-Object { ($_.IsCommand -ne $true) -and (-not [string]::IsNullOrEmpty($_.Category)) } |

        Select-Object -ExpandProperty Category -Unique | Sort-Object

    if ($existingCategories) {

        Write-Host "`nExisting categories: $($existingCategories -join ', ')" -ForegroundColor DarkCyan

    }

    $category = Read-Host "Category (default: $($script:Data.Settings.DefaultCategory))"

    if ([string]::IsNullOrEmpty($category)) {

        $category = $script:Data.Settings.DefaultCategory

    }

   

    Write-Host "`nLink to project? (Y/N)"

    $linkProjectChoice = Read-Host

    $projectKey = $null

    

    if ($linkProjectChoice.ToUpper() -eq 'Y') {

        Show-ProjectsAndTemplates -Simple

        $projectKeyInput = Read-Host "`nProject key (leave empty if none)"

        

        if (-not [string]::IsNullOrWhiteSpace($projectKeyInput)) {

            if (Get-ProjectOrTemplate $projectKeyInput) {

                $projectKey = $projectKeyInput

            } else {

                Write-Warning "Project '$projectKeyInput' not found. Task will be unassigned."

            }

        }

    }

   

    Write-Host "`nStart date (optional): Enter date (YYYY-MM-DD), 'today', 'tomorrow', or '+X' for X days from now" -ForegroundColor Gray

    $startDateInput = Read-Host "Start date"

    $startDate = $null

    if (-not [string]::IsNullOrWhiteSpace($startDateInput)) {

        try {

            $parsedDate = switch -Regex ($startDateInput.ToLower()) {

                '^today$' { [datetime]::Today }

                '^tomorrow$' { [datetime]::Today.AddDays(1) }

                '^\+(\d+)$' { [datetime]::Today.AddDays([int]$Matches[1]) }

                default { [datetime]::Parse($startDateInput) }

            }

            $startDate = $parsedDate.ToString("yyyy-MM-dd")

        }

        catch { Write-Warning "Invalid start date format '$startDateInput'. Start date not set." }

    }

   

    Write-Host "`nDue date (optional): Enter date (YYYY-MM-DD), 'today', 'tomorrow', or '+X' for X days from now" -ForegroundColor Gray

    $dueDateInput = Read-Host "Due date"

    $dueDate = $null

    if (-not [string]::IsNullOrWhiteSpace($dueDateInput)) {

        try {

            $parsedDueDate = switch -Regex ($dueDateInput.ToLower()) {

                '^today$' { [datetime]::Today }

                '^tomorrow$' { [datetime]::Today.AddDays(1) }

                '^\+(\d+)$' { [datetime]::Today.AddDays([int]$Matches[1]) }

                default { [datetime]::Parse($dueDateInput) }

            }

            $dueDate = $parsedDueDate.ToString("yyyy-MM-dd")

        }

        catch { Write-Warning "Invalid due date format '$dueDateInput'. Due date not set." }

    }

   

    Write-Host "`nTags (comma-separated, optional):" -ForegroundColor Gray

    $tagsInput = Read-Host "Tags"

    $tags = if (-not [string]::IsNullOrWhiteSpace($tagsInput)) {

        $tagsInput -split ',' | ForEach-Object { $_.Trim() } | Where-Object { -not [string]::IsNullOrWhiteSpace($_) }

    } else { @() }

   

    $estimatedTimeInput = Read-Host "`nEstimated time in hours (optional, e.g., 2.5)"

    $estimatedTime = 0.0

    if (-not [string]::IsNullOrWhiteSpace($estimatedTimeInput)) {

        try { $estimatedTime = [double]$estimatedTimeInput }

        catch { Write-Warning "Invalid estimate format. Set to 0." }

    }

   

    $subtasks = @()

    Write-Host "`nAdd subtasks? (Y/N)" -ForegroundColor Gray

    $addSubtasksChoice = Read-Host

    if ($addSubtasksChoice.ToUpper() -eq 'Y') {

        Write-Host "Enter subtasks (empty line to finish):" -ForegroundColor Gray

        while ($true) {

            $subtaskDesc = Read-Host "  Subtask"

            if ([string]::IsNullOrEmpty($subtaskDesc)) { break }

            $subtasks += @{ Description = $subtaskDesc; Completed = $false; CompletedDate = $null }

        }

    }

   

    $newTask = @{

        Id = New-TodoId

        Description = $description

        Priority = $priority

        Category = $category

        ProjectKey = $projectKey

        StartDate = $startDate

        DueDate = $dueDate

        Tags = $tags

        Progress = 0

        Completed = $false

        CreatedDate = [datetime]::Now.ToString("yyyy-MM-dd HH:mm:ss")

        CompletedDate = $null

        EstimatedTime = $estimatedTime

        TimeSpent = 0.0

        Subtasks = $subtasks

        Notes = ""

        LastModified = [datetime]::Now.ToString("yyyy-MM-dd HH:mm:ss")

        IsCommand = $false

    }

   

    $script:Data.Tasks += $newTask

   

    if ($projectKey) {

        Update-ProjectStatistics -ProjectKey $projectKey

    }

   

    Save-UnifiedData

   

    Write-Success "Task added successfully!"

    Write-Host "ID: $($newTask.Id)" -ForegroundColor DarkGray

   

    if ($script:Data.Settings.EnableTimeTracking -and $projectKey) {

        Write-Host "`nStart timer for this task? (Y/N)" -ForegroundColor Gray

        $startTimerChoice = Read-Host

        if ($startTimerChoice.ToUpper() -eq 'Y') {

            Start-Timer -ProjectKeyParam $projectKey -TaskIdParam $newTask.Id # Pass params correctly

        }

    }

}

 

function global:Quick-AddTask {

    param([string]$InputString)

    

    if (-not $InputString) {

        $InputString = Read-Host "Quick add task (e.g., 'My new task #work @urgent !High due:tomorrow project:PROJ1 est:2.5')"

        if([string]::IsNullOrWhiteSpace($InputString)) { Write-Info "Quick add cancelled."; return }

    }

   

    $description = $InputString

    $category = $script:Data.Settings.DefaultCategory

    $tags = @()

    $priority = $script:Data.Settings.DefaultPriority

    $dueDate = $null

    $startDate = $null

    $projectKey = $null

    $estimatedTime = 0.0

   

    if ($description -match '#(\S+)') {

        $category = $Matches[1]

        $description = $description -replace ('#' + [regex]::Escape($Matches[1])), ''

    }

   

    $tagMatches = [regex]::Matches($description, '@(\S+)')

    foreach ($match in $tagMatches) {

        $tags += $match.Groups[1].Value

        $description = $description -replace ('@' + [regex]::Escape($match.Groups[1].Value)), ''

    }

   

    if ($description -match '!(critical|high|medium|low|c|h|m|l)\b') {

        $priority = switch ($Matches[1].ToLower()) {

            "c" { "Critical" } "critical" { "Critical" }

            "h" { "High" } "high" { "High" }

            "l" { "Low" } "low" { "Low" }

            default { "Medium" }

        }

        $description = $description -replace ('!' + [regex]::Escape($Matches[1])), ''

    }

   

    if ($description -match 'project:(\S+)') {

        $extractedProjectKey = $Matches[1]

        if (Get-ProjectOrTemplate $extractedProjectKey) {

            $projectKey = $extractedProjectKey

        } else {

            Write-Warning "Unknown project: $extractedProjectKey - task will be unassigned."

        }

        $description = $description -replace ('project:' + [regex]::Escape($Matches[1])), ''

    }

   

    if ($description -match 'est:(\d+\.?\d*)') {

        try { $estimatedTime = [double]$Matches[1] } catch { $estimatedTime = 0.0 }

        $description = $description -replace ('est:' + [regex]::Escape($Matches[1])), ''

    }

   

    if ($description -match 'due:(\S+)') {

        $dueDateStr = $Matches[1]

        try {

            $parsedDueDate = switch -Regex ($dueDateStr.ToLower()) {

                '^today$' { [datetime]::Today }

                '^tomorrow$' { [datetime]::Today.AddDays(1) }

                '^mon(day)?$' { Get-NextWeekday 1 } '^tue(sday)?$' { Get-NextWeekday 2 }

                '^wed(nesday)?$' { Get-NextWeekday 3 } '^thu(rsday)?$' { Get-NextWeekday 4 }

                '^fri(day)?$' { Get-NextWeekday 5 } '^sat(urday)?$' { Get-NextWeekday 6 }

                '^sun(day)?$' { Get-NextWeekday 0 }

                '^\+(\d+)$' { [datetime]::Today.AddDays([int]$Matches[1]) }

                default { [datetime]::Parse($dueDateStr) }

            }

            $dueDate = $parsedDueDate.ToString("yyyy-MM-dd")

        }

        catch { Write-Warning "Invalid due date format '$dueDateStr'. Due date not set." }

        $description = $description -replace ('due:' + [regex]::Escape($Matches[1])), ''

    }

   

    $description = $description.Trim() -replace '\s+', ' '

    

    if ([string]::IsNullOrEmpty($description)) {

        Write-Error "Task description cannot be empty after parsing!"

        return

    }

   

    $newTask = @{

        Id = New-TodoId; Description = $description; Priority = $priority; Category = $category;

        ProjectKey = $projectKey; StartDate = $startDate; DueDate = $dueDate; Tags = $tags;

        Progress = 0; Completed = $false; CreatedDate = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss");

        CompletedDate = $null; EstimatedTime = $estimatedTime; TimeSpent = 0.0; Subtasks = @();

        Notes = ""; LastModified = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss"); IsCommand = $false

    }

   

    $script:Data.Tasks += $newTask

    if ($projectKey) { Update-ProjectStatistics -ProjectKey $projectKey }

    Save-UnifiedData

   

    Write-Success "Quick added: '$description'"

    if ($priority -ne $script:Data.Settings.DefaultPriority) { Write-Host "   Priority: $priority" -ForegroundColor Gray }

    if ($dueDate) { Write-Host "   Due: $(Format-TodoDate $dueDate)" -ForegroundColor Gray }

    if ($projectKey) { Write-Host "   Project: $((Get-ProjectOrTemplate $projectKey).Name)" -ForegroundColor Gray }

    if ($tags.Count -gt 0) { Write-Host "   Tags: $($tags -join ', ')" -ForegroundColor Gray }

    if ($estimatedTime -gt 0) { Write-Host "   Est. Time: ${estimatedTime}h" -ForegroundColor Gray }

}

 

function global:Complete-Task {

    param([string]$TaskIdInput)

    

    $idToComplete = $TaskIdInput

    if (-not $idToComplete) {

        Show-TasksView

        $idToComplete = Read-Host "`nEnter task ID to complete (or Enter to cancel)"

        if ([string]::IsNullOrWhiteSpace($idToComplete)) { Write-Info "Completion cancelled."; return }

    }

   

    $task = $script:Data.Tasks | Where-Object { $_.Id -like "$idToComplete*" -and ($_.IsCommand -ne $true) } | Select-Object -First 1

   

    if (-not $task) { Write-Error "Task with ID starting '$idToComplete' not found!"; return }

    if ($task.Completed) { Write-Info "Task '$($task.Description)' is already completed!"; return }

   

    if ($task.Subtasks -and ($task.Subtasks | Where-Object { -not $_.Completed }).Count -gt 0) {

        $uncompletedCount = ($task.Subtasks | Where-Object { -not $_.Completed }).Count

        Write-Warning "Task '$($task.Description)' has $uncompletedCount uncompleted subtask(s)."

        if ((Read-Host "Complete anyway? (Y/N)").ToUpper() -ne 'Y') {

            Write-Info "Task completion cancelled."; return

        }

    }

   

    $task.Completed = $true

    $task.Progress = 100

    $task.CompletedDate = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")

    $task.LastModified = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")

   

    if ($task.ProjectKey) { Update-ProjectStatistics -ProjectKey $task.ProjectKey }

    Save-UnifiedData

   

    Write-Success "Completed: $($task.Description)"

    if ($task.TimeSpent -gt 0) {

        Write-Host "   Time spent: $($task.TimeSpent) hours" -ForegroundColor Gray

        if ($task.EstimatedTime -gt 0 -and $task.TimeSpent -gt 0) {

            $efficiency = [Math]::Round(($task.EstimatedTime / $task.TimeSpent) * 100, 0)

            Write-Host "   Efficiency: $efficiency% of estimate" -ForegroundColor Gray

        }

    }

}

 

function global:Update-TaskProgress {

    param([string]$TaskIdInput)

    

    $idToUpdate = $TaskIdInput

    if (-not $idToUpdate) {

        Show-TasksView

        $idToUpdate = Read-Host "`nEnter task ID to update progress (or Enter to cancel)"

        if ([string]::IsNullOrWhiteSpace($idToUpdate)) { Write-Info "Progress update cancelled."; return }

    }

   

    $task = $script:Data.Tasks | Where-Object { $_.Id -like "$idToUpdate*" -and ($_.IsCommand -ne $true) } | Select-Object -First 1

   

    if (-not $task) { Write-Error "Task with ID starting '$idToUpdate' not found!"; return }

   

    Write-Host "`nTask: $($task.Description) (ID: $($task.Id.Substring(0,6)))" -ForegroundColor Cyan

    Write-Host "Current progress: $($task.Progress)%"

    Draw-ProgressBar -Percent $task.Progress; Write-Host ""

   

    if ($task.Subtasks -and $task.Subtasks.Count -gt 0) {

        $completedSubtasks = ($task.Subtasks | Where-Object { -not $_.Completed }).Count

        $calculatedProgress = [Math]::Round(($completedSubtasks / $task.Subtasks.Count) * 100, 0)

        Write-Host "Progress based on subtasks: $calculatedProgress% ($completedSubtasks/$($task.Subtasks.Count) completed)" -ForegroundColor Gray

       

        if ((Read-Host "`nUpdate based on: [S]ubtasks, or [M]anual entry? (S/M)").ToUpper() -eq 'S') {

            $task.Progress = $calculatedProgress

            if ($task.Progress -eq 100 -and (-not $task.Completed)) {

                $task.Completed = $true; $task.CompletedDate = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")

                Write-Info "Task auto-completed due to 100% subtask progress."

            } elseif ($task.Progress -lt 100 -and $task.Completed) {

                $task.Completed = $false; $task.CompletedDate = $null

                Write-Info "Task re-opened as subtask progress is less than 100%."

            }

            $task.LastModified = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")

            Save-UnifiedData

            Write-Success "Progress updated to $calculatedProgress% based on subtasks!"

            return

        }

    }

   

    $newProgressInput = Read-Host "New progress percentage (0-100)"

    try {

        $progressValue = [int]$newProgressInput

        if ($progressValue -lt 0 -or $progressValue -gt 100) { throw "Progress must be between 0 and 100." }

       

        $task.Progress = $progressValue

        if ($progressValue -eq 100 -and (-not $task.Completed)) {

            $task.Completed = $true; $task.CompletedDate = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")

            Write-Info "Task marked as completed."

        } elseif ($progressValue -lt 100 -and $task.Completed) {

            $task.Completed = $false; $task.CompletedDate = $null

            Write-Info "Task marked as not completed due to progress change."

        }

        $task.LastModified = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")

        Save-UnifiedData

        Write-Success "Progress updated to $progressValue%!"

    }

    catch { Write-Error "Invalid progress value! $_" }

}

 

function global:Edit-Task {

    param([string]$TaskIdInput)

    

    $idToEdit = $TaskIdInput

    if (-not $idToEdit) {

        Show-TasksView

        $idToEdit = Read-Host "`nEnter task ID to edit (or Enter to cancel)"

        if ([string]::IsNullOrWhiteSpace($idToEdit)) { Write-Info "Edit cancelled."; return }

    }

   

    $task = $script:Data.Tasks | Where-Object { $_.Id -like "$idToEdit*" -and ($_.IsCommand -ne $true) } | Select-Object -First 1

   

    if (-not $task) { Write-Error "Task with ID starting '$idToEdit' not found!"; return }

   

    Write-Header "Edit Task: $($task.Id.Substring(0,6)) - $($task.Description)"

    Write-Host "Leave field empty to keep current value." -ForegroundColor Gray

   

    $originalTaskSnapshot = $task.PSObject.Copy() # Create a snapshot for comparison

    $changesMade = $false

 

    $newDesc = Read-Host "Description (current: $($task.Description))"

    if (-not [string]::IsNullOrWhiteSpace($newDesc) -and $newDesc -ne $task.Description) { $task.Description = $newDesc }

   

    $newPriorityInput = Read-Host "Priority (current: $($task.Priority)) - [C]ritical, [H]igh, [M]edium, [L]ow"

    if (-not [string]::IsNullOrWhiteSpace($newPriorityInput)) {

        $task.Priority = switch ($newPriorityInput.ToUpper()) {

            "C" { "Critical" } "H" { "High" } "M" { "Medium" } "L" { "Low" } default { $task.Priority }

        }

    }

 

    $newCategory = Read-Host "Category (current: $($task.Category))"

    if (-not [string]::IsNullOrWhiteSpace($newCategory) -and $newCategory -ne $task.Category) { $task.Category = $newCategory }

 

    $currentProjectName = if ($task.ProjectKey) { (Get-ProjectOrTemplate $task.ProjectKey).Name } else { 'None' }

    Write-Host "Project (current: $currentProjectName - key: $($task.ProjectKey))"

    Show-ProjectsAndTemplates -Simple

    $newProjectKeyInput = Read-Host "New project key (or 'none' to remove, 'clear' for same effect)"

    if (-not [string]::IsNullOrWhiteSpace($newProjectKeyInput)) {

        if ($newProjectKeyInput.ToLower() -in @('none', 'clear')) { $task.ProjectKey = $null }

        elseif (Get-ProjectOrTemplate $newProjectKeyInput) { $task.ProjectKey = $newProjectKeyInput }

        else { Write-Warning "Project key '$newProjectKeyInput' not found. Project not changed." }

    }

   

    $currentDueDateDisplay = if ($task.DueDate) { Format-TodoDate $task.DueDate } else { 'None' }

    $newDueDateInput = Read-Host "Due Date (current: $currentDueDateDisplay) - YYYY-MM-DD, today, +X, or 'clear'"

    if (-not [string]::IsNullOrWhiteSpace($newDueDateInput)) {

        if ($newDueDateInput.ToLower() -eq 'clear') { $task.DueDate = $null }

        else {

            try {

                $parsedDueDate = switch -Regex ($newDueDateInput.ToLower()) {

                    '^today$' { [datetime]::Today } '^tomorrow$' { [datetime]::Today.AddDays(1) }

                    '^\+(\d+)$' { [datetime]::Today.AddDays([int]$Matches[1]) }

                    default { [datetime]::Parse($newDueDateInput) }

                }

                $task.DueDate = $parsedDueDate.ToString("yyyy-MM-dd")

            } catch { Write-Warning "Invalid date format '$newDueDateInput'. Due date not changed." }

        }

    }

 

    $newEstimateInput = Read-Host "Estimated Time (current: $($task.EstimatedTime)h)"

    if (-not [string]::IsNullOrWhiteSpace($newEstimateInput)) {

        try { $task.EstimatedTime = [double]$newEstimateInput }

        catch { Write-Warning "Invalid number for estimate. Not changed." }

    }

 

    $currentTagsDisplay = if ($task.Tags -and $task.Tags.Count -gt 0) { $task.Tags -join ', ' } else { "None" }

    $newTagsInput = Read-Host "Tags (current: $currentTagsDisplay) - comma-separated, or 'clear'"

    if ($newTagsInput -ne $null) {

        if ($newTagsInput.ToLower() -eq 'clear' -or [string]::IsNullOrWhiteSpace($newTagsInput)) { $task.Tags = @() }

        else { $task.Tags = $newTagsInput -split ',' | ForEach-Object { $_.Trim() } | Where-Object { -not [string]::IsNullOrWhiteSpace($_) } }

    }

   

    $editNotesChoice = Read-Host "Edit notes? Current: $(if ([string]::IsNullOrWhiteSpace($task.Notes)) { 'No notes' } else { 'Has notes' }) (Y/N)"

    if ($editNotesChoice.ToUpper() -eq 'Y') {

        Write-Host "Current notes:" ; Write-Host $task.Notes -ForegroundColor Gray

        $newNotes = Read-Host "New notes (enter 'clear' to empty)"

        if ($newNotes.ToLower() -eq 'clear') { $task.Notes = "" }

        elseif ($newNotes -ne $task.Notes) { $task.Notes = $newNotes }

    }

 

    # Check if any actual changes were made by comparing with the snapshot

    foreach($prop in $originalTaskSnapshot.PSObject.Properties.Name){

        if($task.$prop -ne $originalTaskSnapshot.$prop){

            $changesMade = $true

            break

        }

    }

    if (($task.Tags | ConvertTo-Json) -ne ($originalTaskSnapshot.Tags | ConvertTo-Json)) { $changesMade = $true }

 

 

    if ($changesMade) {

        $task.LastModified = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")

        if ($originalTaskSnapshot.ProjectKey -and $originalTaskSnapshot.ProjectKey -ne $task.ProjectKey) {

            Update-ProjectStatistics -ProjectKey $originalTaskSnapshot.ProjectKey

        }

        if ($task.ProjectKey) { Update-ProjectStatistics -ProjectKey $task.ProjectKey }

        Save-UnifiedData

        Write-Success "Task '$($task.Description)' updated!"

    } else {

        Write-Info "No changes made to task '$($task.Description)'."

    }

}

 

function global:Manage-Subtasks {

    param([string]$TaskIdInput)

    

    $idForSubtasks = $TaskIdInput

    if (-not $idForSubtasks) {

        Show-TasksView

        $idForSubtasks = Read-Host "`nEnter task ID to manage subtasks (or Enter to cancel)"

        if ([string]::IsNullOrWhiteSpace($idForSubtasks)) { Write-Info "Subtask management cancelled."; return }

    }

   

    $task = $script:Data.Tasks | Where-Object { $_.Id -like "$idForSubtasks*" -and ($_.IsCommand -ne $true) } | Select-Object -First 1

   

    if (-not $task) { Write-Error "Task with ID starting '$idForSubtasks' not found!"; return }

    if ($null -eq $task.Subtasks -or -not ($task.Subtasks -is [System.Array])) { $task.Subtasks = @() }

 

    while ($true) {

        Clear-Host

        Write-Header "Manage Subtasks for: $($task.Description) (ID: $($task.Id.Substring(0,6)))"

       

        if ($task.Subtasks.Count -eq 0) { Write-Host "`nNo subtasks yet." -ForegroundColor Gray }

        else {

            Write-Host "`nSubtasks:"

            for ($i = 0; $i -lt $task.Subtasks.Count; $i++) {

                $subtask = $task.Subtasks[$i]

                $icon = if ($subtask.Completed) { "" } else { "" }

                $color = if ($subtask.Completed) { (Get-ThemeProperty "Palette.SubtleFG") } else { (Get-ThemeProperty "Palette.PrimaryFG") }

                Write-Host "  [$i] $(Apply-PSStyle -Text "$icon $($subtask.Description)" -FG $color)"

            }

            $completedCount = ($task.Subtasks | Where-Object { $_.Completed }).Count

            Write-Host "`nProgress from subtasks: $completedCount/$($task.Subtasks.Count) completed" -ForegroundColor Green

        }

       

        Write-Host "`n[A]dd subtask, [T]oggle complete, [E]dit subtask, [D]elete subtask, [B]ack"

        $choice = Read-Host "Choice"

        $actionTaken = $true

 

        switch ($choice.ToLower()) {

            "a" {

                $desc = Read-Host "New subtask description"

                if (-not [string]::IsNullOrWhiteSpace($desc)) {

                    $task.Subtasks += @{ Description = $desc; Completed = $false; CompletedDate = $null }

                    Write-Success "Subtask added!" # Moved inside the if block

                } else { Write-Info "Subtask not added (empty description)."; $actionTaken = $false }

 

            }

            "t" {

                if ($task.Subtasks.Count -eq 0) { Write-Error "No subtasks to toggle!"; $actionTaken = $false; break }

                $indexInput = Read-Host "Subtask number to toggle"

                try {

                    $idx = [int]$indexInput

                    if ($idx -ge 0 -and $idx -lt $task.Subtasks.Count) {

                        $task.Subtasks[$idx].Completed = -not $task.Subtasks[$idx].Completed

                        $task.Subtasks[$idx].CompletedDate = if ($task.Subtasks[$idx].Completed) { (Get-Date).ToString("yyyy-MM-dd HH:mm:ss") } else { $null }

                        Write-Success "Subtask completion toggled!"

                    } else { Write-Error "Invalid index!"; $actionTaken = $false }

                } catch { Write-Error "Invalid index format!"; $actionTaken = $false }

            }

            "e" {

                 if ($task.Subtasks.Count -eq 0) { Write-Error "No subtasks to edit!"; $actionTaken = $false; break }

                 $indexInput = Read-Host "Subtask number to edit"

                 try {

                    $idx = [int]$indexInput

                    if ($idx -ge 0 -and $idx -lt $task.Subtasks.Count) {

                        $newSubDesc = Read-Host "New description for '$($task.Subtasks[$idx].Description)'"

                        if(-not [string]::IsNullOrWhiteSpace($newSubDesc)){

                            $task.Subtasks[$idx].Description = $newSubDesc

                            Write-Success "Subtask description updated."

                        } else { Write-Info "Description not changed (empty input)."; $actionTaken = $false}

                    } else { Write-Error "Invalid index!"; $actionTaken = $false }

                 } catch { Write-Error "Invalid index format!"; $actionTaken = $false }

            }

            "d" {

                if ($task.Subtasks.Count -eq 0) { Write-Error "No subtasks to delete!"; $actionTaken = $false; break }

                $indexToDelete = Read-Host "Subtask number to delete"

                try {

                    $idx = [int]$indexToDelete

                    if ($idx -ge 0 -and $idx -lt $task.Subtasks.Count) {

                        Write-Warning "Delete subtask '$($task.Subtasks[$idx].Description)'?"

                        if((Read-Host "Confirm (Y/N)").ToUpper() -eq 'Y'){

                            $task.Subtasks = @($task.Subtasks | Select-Object -Index (0..($task.Subtasks.Count-1) | Where-Object { $_ -ne $idx }))

                            Write-Success "Subtask deleted!"

                        } else { Write-Info "Deletion cancelled."; $actionTaken = $false}

                    } else { Write-Error "Invalid index!"; $actionTaken = $false }

                } catch { Write-Error "Invalid index format!"; $actionTaken = $false }

            }

            "b" { return }

            default {

                if (-not [string]::IsNullOrEmpty($choice)) { Write-Warning "Unknown command." }

                $actionTaken = $false

            }

        }

        if ($actionTaken) {

            if ($task.Subtasks.Count -gt 0) {

                $completedSubtasksCount = ($task.Subtasks | Where-Object { $_.Completed }).Count

                $task.Progress = [Math]::Round(($completedSubtasksCount / $task.Subtasks.Count) * 100, 0)

            } else {

                 if (-not $task.Completed -and $task.Progress -ne 100) { $task.Progress = 0 }

            }

            if ($task.Progress -eq 100 -and (-not $task.Completed)) {

                 $task.Completed = $true; $task.CompletedDate = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")

            } elseif ($task.Progress -lt 100 -and $task.Completed) {

                 $task.Completed = $false; $task.CompletedDate = $null

            }

            $task.LastModified = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")

            Save-UnifiedData

            if ($choice.ToLower() -ne "b") { Start-Sleep -Seconds 1 }

        }

    }

}

 

function global:Remove-Task {

    param([string]$TaskIdInput)

    

    $idToRemove = $TaskIdInput

    if (-not $idToRemove) {

        Show-TasksView

        $idToRemove = Read-Host "`nEnter task ID to delete (or Enter to cancel)"

        if ([string]::IsNullOrWhiteSpace($idToRemove)) { Write-Info "Deletion cancelled."; return }

    }

   

    $task = $script:Data.Tasks | Where-Object { $_.Id -like "$idToRemove*" -and ($_.IsCommand -ne $true) } | Select-Object -First 1

   

    if (-not $task) { Write-Error "Task with ID starting '$idToRemove' not found!"; return }

   

    Write-Warning "Permanently delete task: '$($task.Description)' (ID: $($task.Id.Substring(0,6)))?"

    if ($task.TimeSpent -gt 0) { Write-Warning "This task has $($task.TimeSpent) hours logged! This time will NOT be deleted from project totals unless manually adjusted." }

    if ($task.Subtasks -and $task.Subtasks.Count -gt 0) { Write-Warning "This task has $($task.Subtasks.Count) subtask(s) which will also be deleted."}

   

    if ((Read-Host "Type 'yes' to confirm deletion").ToLower() -eq 'yes') {

        $originalProjectKey = $task.ProjectKey

        $script:Data.Tasks = $script:Data.Tasks | Where-Object { $_.Id -ne $task.Id }

       

        if ($originalProjectKey) { Update-ProjectStatistics -ProjectKey $originalProjectKey }

        Save-UnifiedData

        Write-Success "Task '$($task.Description)' deleted!"

    } else {

        Write-Info "Deletion cancelled."

    }

}

 

function global:Archive-CompletedTasks {

    $completedTasks = $script:Data.Tasks | Where-Object { $_.Completed -and ($_.IsCommand -ne $true) }

    

    if ($completedTasks.Count -eq 0) { Write-Info "No completed tasks to archive."; return }

 

    $cutoffDate = [datetime]::Today.AddDays(-$script:Data.Settings.AutoArchiveDays)

    $tasksToAutoArchive = $completedTasks | Where-Object {

        (-not [string]::IsNullOrEmpty($_.CompletedDate)) -and ([datetime]::Parse($_.CompletedDate).Date -lt $cutoffDate.Date)

    }

   

    $tasksToConsider = $tasksToAutoArchive

    $archiveMode = "automatic"

 

    if ($tasksToAutoArchive.Count -eq 0) {

        Write-Info "No tasks old enough for automatic archiving (older than $($script:Data.Settings.AutoArchiveDays) days)."

        if ((Read-Host "`nArchive all $($completedTasks.Count) completed task(s) manually now? (Y/N)").ToUpper() -eq 'Y') {

            $tasksToConsider = $completedTasks

            $archiveMode = "manual"

        } else {

            Write-Info "Archive operation cancelled."; return

        }

    } else {

        if ((Read-Host "Archive $($tasksToAutoArchive.Count) task(s) older than $($script:Data.Settings.AutoArchiveDays) days? (Y/N)").ToUpper() -ne 'Y') {

            Write-Info "Automatic archive cancelled."; return

        }

    }

   

    if ($tasksToConsider.Count -eq 0) { Write-Info "No tasks selected for archiving."; return }

 

    if ($null -eq $script:Data.ArchivedTasks) { $script:Data.ArchivedTasks = @() }

    $script:Data.ArchivedTasks += $tasksToConsider

 

    $idsToArchive = $tasksToConsider | ForEach-Object {$_.Id}

    $script:Data.Tasks = $script:Data.Tasks | Where-Object { $_.Id -notin $idsToArchive }

   

    $affectedProjects = $tasksToConsider | Where-Object { -not [string]::IsNullOrEmpty($_.ProjectKey) } | Select-Object -ExpandProperty ProjectKey -Unique

    foreach ($projectKey in $affectedProjects) { Update-ProjectStatistics -ProjectKey $projectKey }

   

    Save-UnifiedData

    Write-Success "Archived $($tasksToConsider.Count) task(s) ($archiveMode)."

}

 

function global:View-TaskArchive {

    Clear-Host

    Write-Header "Archived Tasks"

   

    if (-not $script:Data.ArchivedTasks -or $script:Data.ArchivedTasks.Count -eq 0) {

        Write-Host "`n   No archived tasks." -ForegroundColor Gray

        return

    }

   

    $groupedByMonth = $script:Data.ArchivedTasks |

        Where-Object {-not [string]::IsNullOrEmpty($_.CompletedDate)} |

        Group-Object { try { [datetime]::Parse($_.CompletedDate).ToString("yyyy-MM") } catch { "InvalidDate" } } |

        Sort-Object Name -Descending

   

    foreach ($monthGroup in $groupedByMonth) {

        $monthYearDisplay = if ($monthGroup.Name -eq "InvalidDate") { "[Tasks with Invalid Completion Dates]" }

                           else { try { [datetime]::ParseExact($monthGroup.Name, "yyyy-MM", $null).ToString("MMMM yyyy") } catch { $monthGroup.Name } }

        Write-Host "`n   $monthYearDisplay ($($monthGroup.Count) items)" -ForegroundColor Yellow

       

        foreach ($task in $monthGroup.Group | Sort-Object @{Expression={if([string]::IsNullOrEmpty($_.CompletedDate)) {[DateTime]::MinValue} else {[DateTime]::Parse($_.CompletedDate)}}; Descending=$true}) {

            Write-Host "      $($task.Description) (ID: $($task.Id.Substring(0,6)))" -ForegroundColor DarkGray

            $completedDateDisplay = if ($task.CompletedDate) { try {([datetime]::Parse($task.CompletedDate)).ToString('MMM dd, yyyy HH:mm')} catch{"N/A"}} else { "N/A" }

            Write-Host "       Completed: $completedDateDisplay" -ForegroundColor DarkGray

           

            if ($task.TimeSpent -gt 0) {

                Write-Host "       Time Spent: $($task.TimeSpent)h" -ForegroundColor DarkGray -NoNewline

                if ($task.EstimatedTime -gt 0) { Write-Host " (Est: $($task.EstimatedTime)h)" -ForegroundColor DarkGray }

                else { Write-Host }

            }

            if ($task.ProjectKey) {

                $project = Get-ProjectOrTemplate $task.ProjectKey

                if ($project) { Write-Host "       Project: $($project.Name) (Key: $($task.ProjectKey))" -ForegroundColor DarkGray }

            }

        }

    }

   

    $totalArchived = $script:Data.ArchivedTasks.Count

    $totalTimeSpent = ($script:Data.ArchivedTasks | Measure-Object -Property TimeSpent -Sum).Sum

    $totalEstimatedTime = ($script:Data.ArchivedTasks | Measure-Object -Property EstimatedTime -Sum).Sum

    

    Write-Host "`n" ("=" * 60) -ForegroundColor DarkGray

    Write-Host "  Total archived: $totalArchived tasks" -ForegroundColor Green

    if ($totalTimeSpent -gt 0) {

        Write-Host "  Total time spent on archived: $totalTimeSpent hours" -ForegroundColor Green

        if ($totalEstimatedTime -gt 0 -and $totalTimeSpent -gt 0) {

            $efficiency = [Math]::Round(($totalEstimatedTime / $totalTimeSpent) * 100, 0)

            Write-Host "  Average efficiency (archived): $efficiency% of estimates" -ForegroundColor Green

        }

    }

   

    Write-Host "`nPress any key to continue..." -ForegroundColor Gray

    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")

}

 

function global:Edit-TaskSettings {

    Write-Header "Task Settings"

    Write-Host "Leave empty to keep current value." -ForegroundColor Gray

 

    $settings = $script:Data.Settings

    

    $newPriorityInput = Read-Host "`nDefault Priority (current: $($settings.DefaultPriority)) - [C]ritical, [H]igh, [M]edium, [L]ow"

    if (-not [string]::IsNullOrWhiteSpace($newPriorityInput)) {

        $settings.DefaultPriority = switch ($newPriorityInput.ToUpper()) {

            "C" { "Critical" } "H" { "High" } "M" { "Medium" } "L" { "Low" }

            default { $settings.DefaultPriority }

        }

    }

 

    $newCategoryInput = Read-Host "`nDefault Category (current: $($settings.DefaultCategory))"

    if (-not [string]::IsNullOrWhiteSpace($newCategoryInput)) {

        $settings.DefaultCategory = $newCategoryInput

    }

 

    $newShowDaysInput = Read-Host "`nDays to show completed tasks in active views (current: $($settings.ShowCompletedDays))"

    if (-not [string]::IsNullOrWhiteSpace($newShowDaysInput)) {

        try {

            $days = [int]$newShowDaysInput

            if ($days -ge 0) { $settings.ShowCompletedDays = $days }

            else { Write-Warning "Days must be non-negative. Not changed."}

        }

        catch { Write-Warning "Invalid number for ShowCompletedDays. Not changed." }

    }

   

    $newArchiveDaysInput = Read-Host "`nDays until completed tasks are auto-archived (current: $($settings.AutoArchiveDays))"

    if (-not [string]::IsNullOrWhiteSpace($newArchiveDaysInput)) {

        try {

            $days = [int]$newArchiveDaysInput

            if ($days -ge 0) { $settings.AutoArchiveDays = $days }

            else { Write-Warning "Days must be non-negative. Not changed."}

        }

        catch { Write-Warning "Invalid number for AutoArchiveDays. Not changed." }

    }

 

    $enableTimeTrackingInput = Read-Host "`nEnable time tracking integration for tasks (Y/N) (current: $(if($settings.EnableTimeTracking){'Yes'}else{'No'}))"

    if(-not [string]::IsNullOrWhiteSpace($enableTimeTrackingInput)){

        $settings.EnableTimeTracking = $enableTimeTrackingInput.ToUpper() -eq 'Y'

    }

 

    Save-UnifiedData

    Write-Success "Task settings updated!"

}

 

#endregion

 

#region Task Status Functions

 

function global:Get-TaskStatus {

    param($Task)

   

    if ($Task.Completed) { return "Completed" }

    if ($Task.Progress -ge 100) { return "Done (Pending Confirmation)" }

    if ($Task.Progress -gt 0) { return "In Progress" }

 

    if (-not [string]::IsNullOrEmpty($Task.DueDate)) {

        try {

            $dueDate = [datetime]::Parse($Task.DueDate).Date

            $today = [datetime]::Today.Date

            $daysUntil = ($dueDate - $today).Days

            if ($daysUntil -lt 0) { return "Overdue" }

            if ($daysUntil -eq 0) { return "Due Today" }

            if ($daysUntil -gt 0 -and $daysUntil -le 3) { return "Due Soon" }

        } catch { }

    }

    if (-not [string]::IsNullOrEmpty($Task.StartDate)) {

         try {

            $startDate = [datetime]::Parse($Task.StartDate).Date

            $today = [datetime]::Today.Date

            if ($startDate -gt $today) { return "Scheduled" }

        } catch { }

    }

    return "Pending"

}

 

function global:Get-PriorityInfo {

    param($Priority)

    switch ($Priority) {

        "Critical" { return @{ Color = (Get-ThemeProperty "Palette.ErrorFG"); Icon = "" } }

        "High" { return @{ Color = (Get-ThemeProperty "Palette.ErrorFG"); Icon = "" } }

        "Medium" { return @{ Color = (Get-ThemeProperty "Palette.WarningFG"); Icon = "" } }

        "Low" { return @{ Color = (Get-ThemeProperty "Palette.SuccessFG"); Icon = "" } }

        default { return @{ Color = (Get-ThemeProperty "Palette.SubtleFG"); Icon = "" } }

    }

}

 

#endregion

 

#region Display Functions (Task Specific Views)

 

function global:Show-TasksView {

    param(

        [string]$Filter = "",

        [string]$SortBy = "Smart",

        [switch]$ShowCompleted,

        [string]$View = "Default" 

    )

   

    $tasksToDisplay = $script:Data.Tasks

    if (-not $script:Data.Settings.CommandSnippets.ShowInTaskList) {

        $tasksToDisplay = $tasksToDisplay | Where-Object { $_.IsCommand -ne $true }

    }

 

    if ($Filter) {

        $tasksToDisplay = $tasksToDisplay | Where-Object {

            $_.Description -like "*$Filter*" -or

            $_.Category -like "*$Filter*" -or

            ($_.Tags -and ($_.Tags -join ' ') -like "*$Filter*") -or

            ($_.ProjectKey -and (Get-ProjectOrTemplate $_.ProjectKey) -and (Get-ProjectOrTemplate $_.ProjectKey).Name -like "*$Filter*") -or

            $_.Id -like "*$Filter*"

        }

    }

   

    if (-not $ShowCompleted) {

        $cutoffDate = [datetime]::Today.AddDays(-$script:Data.Settings.ShowCompletedDays)

        $tasksToDisplay = $tasksToDisplay | Where-Object {

            (-not $_.Completed) -or

            ((-not [string]::IsNullOrEmpty($_.CompletedDate)) -and ([datetime]::Parse($_.CompletedDate).Date -ge $cutoffDate.Date))

        }

    }

    

    $sortedTasks = switch ($SortBy.ToLower()) {

        "smart" {

            $tasksToDisplay | Sort-Object @{Expression={

                $status = Get-TaskStatus $_

                switch($status) {

                    "Overdue" { 1 } "Due Today" { 2 } "Due Soon" { 3 }

                    "In Progress" { 4 } "Done (Pending Confirmation)" {4} "Pending" { 5 } "Scheduled" { 6 }

                    "Completed" { 7 } default { 8 }

                }

            }}, @{Expression={

                switch($_.Priority) {

                    "Critical" { 1 } "High" { 2 } "Medium" { 3 } "Low" { 4 } default { 5 }

                }

            }}, @{Expression={

                if([string]::IsNullOrEmpty($_.DueDate)) {

                    [DateTime]::MaxValue

                } else {

                    try { [DateTime]::Parse($_.DueDate) } catch { [DateTime]::MaxValue }

                }

            }}, @{Expression={

                if([string]::IsNullOrEmpty($_.CreatedDate)) {

                    [DateTime]::MinValue

                } else {

                    try { [DateTime]::Parse($_.CreatedDate) } catch { [DateTime]::MinValue }

                }

            }}

        }

        "priority" {

            $tasksToDisplay | Sort-Object @{Expression={

                switch($_.Priority) {

                    "Critical" { 1 } "High" { 2 } "Medium" { 3 } "Low" { 4 } default { 5 }

                }

            }}, @{Expression={

                if([string]::IsNullOrEmpty($_.DueDate)) {

                    [DateTime]::MaxValue

                } else {

                    try { [DateTime]::Parse($_.DueDate) } catch { [DateTime]::MaxValue }

                }

            }}, @{Expression={

                if([string]::IsNullOrEmpty($_.CreatedDate)) {

                    [DateTime]::MinValue

                } else {

                    try { [DateTime]::Parse($_.CreatedDate) } catch { [DateTime]::MinValue }

                }

            }}

        }

        "duedate" {

            $tasksToDisplay | Sort-Object @{Expression={

                if([string]::IsNullOrEmpty($_.DueDate)) {

                    [DateTime]::MaxValue

                } else {

                    try { [DateTime]::Parse($_.DueDate) } catch { [DateTime]::MaxValue }

                }

            }}, @{Expression={

                switch($_.Priority) {

                    "Critical" { 1 } "High" { 2 } "Medium" { 3 } "Low" { 4 } default { 5 }

                }

            }}

        }

        "created" {

            $tasksToDisplay | Sort-Object @{Expression={

                if([string]::IsNullOrEmpty($_.CreatedDate)) {

                    [DateTime]::MinValue

                } else {

                    try { [DateTime]::Parse($_.CreatedDate) } catch { [DateTime]::MinValue }

                }

            }; Descending = $true}

        }

        "category" {

            $tasksToDisplay | Sort-Object @{Expression={

                if([string]::IsNullOrEmpty($_.Category)) { "zzz" } else { $_.Category }

            }}, @{Expression={

                switch($_.Priority) {

                    "Critical" { 1 } "High" { 2 } "Medium" { 3 } "Low" { 4 } default { 5 }

                }

            }}

        }

        "project" {

            $tasksToDisplay | Sort-Object @{Expression={

                if([string]::IsNullOrEmpty($_.ProjectKey)) { "zzz" } else { $_.ProjectKey }

            }}, @{Expression={

                switch($_.Priority) {

                    "Critical" { 1 } "High" { 2 } "Medium" { 3 } "Low" { 4 } default { 5 }

                }

            }}

        }

        default { $tasksToDisplay }

    }

   

    if ($sortedTasks.Count -eq 0) {

        Write-Host "`n   No tasks found matching current filters." -ForegroundColor Yellow

        Show-TaskStatistics $tasksToDisplay

        return

    }

   

    switch ($View.ToLower()) {

        "kanban" { Show-KanbanView $sortedTasks }

        "timeline" { Show-TimelineView $sortedTasks }

        "project" { Show-ProjectTaskView $sortedTasks }

        default { Show-TaskListView $sortedTasks }

    }

   

    Show-TaskStatistics $sortedTasks

}

 

 

function global:Show-TaskListView {

    param($TasksToDisplay)

    

    $groups = $TasksToDisplay | Group-Object Category | Sort-Object Name

   

    foreach ($group in $groups) {

        $categoryName = if ([string]::IsNullOrEmpty($group.Name)) { "[Uncategorized]" } else { $group.Name }

        Write-Host "`n   $categoryName ($($group.Count) tasks)" -ForegroundColor (Get-ThemeProperty "Palette.AccentFG")

        Write-Host "  " ("-" * ($categoryName.Length + 15)) -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG")

        

        foreach ($task in $group.Group) { Show-TaskItem $task }

    }

}

 

function global:Show-TaskItem {

    param($Task)

   

    $icon = if ($Task.Completed) { Apply-PSStyle -Text "" -FG (Get-ThemeProperty "Palette.SuccessFG") } else { "" }

    $priorityInfo = Get-PriorityInfo $Task.Priority

    $id = $Task.Id.Substring(0, 6)

    $status = Get-TaskStatus $Task

    

    Write-Host "  $icon [$id] " -NoNewline

    Write-Host (Apply-PSStyle -Text $priorityInfo.Icon -FG $priorityInfo.Color) -NoNewline

    Write-Host " " -NoNewline

   

    $descriptionText = $Task.Description

    if ($Task.Completed) {

        Write-Host (Apply-PSStyle -Text $descriptionText -FG (Get-ThemeProperty "Palette.SubtleFG"))

    } else {

        $statusColor = switch ($status) {

            "Overdue" { Get-ThemeProperty "Palette.ErrorFG" }

            "Due Today" { Get-ThemeProperty "Palette.WarningFG" }

            "Due Soon" { Get-ThemeProperty "Palette.InfoFG" }

            "In Progress" { Get-ThemeProperty "Palette.InfoFG" }

            "Done (Pending Confirmation)" { Get-ThemeProperty "Palette.SuccessFG"}

            default { Get-ThemeProperty "Palette.PrimaryFG" }

        }

        Write-Host (Apply-PSStyle -Text $descriptionText -FG $statusColor)

    }

   

    Write-Host "      " -NoNewline

    $detailsParts = @()

 

    if ($status -notin @("Pending", "Completed", "Done (Pending Confirmation)")) {

        $badgeColor = switch ($status) {

            "Overdue" { Get-ThemeProperty "Palette.ErrorFG" }

            "Due Today" { Get-ThemeProperty "Palette.WarningFG" }

            "Due Soon" { Get-ThemeProperty "Palette.InfoFG" }

            "In Progress" { Get-ThemeProperty "Palette.InfoFG" }

            "Scheduled" { Get-ThemeProperty "Palette.AccentFG" }

            default { Get-ThemeProperty "Palette.SubtleFG" }

        }

        $detailsParts += Apply-PSStyle -Text "[$status]" -FG $badgeColor

    }

   

    if (-not [string]::IsNullOrEmpty($Task.DueDate)) {

        $dueDateObj = try {[datetime]::Parse($Task.DueDate)} catch {$null}

        if($dueDateObj){

            $dueDateStr = Format-TodoDate $Task.DueDate

            $daysUntil = ($dueDateObj.Date - [datetime]::Today.Date).Days

            $dateColor = if ($daysUntil -lt 0 -and !$Task.Completed) { Get-ThemeProperty "Palette.ErrorFG" }

                        elseif ($daysUntil -eq 0 -and !$Task.Completed) { Get-ThemeProperty "Palette.WarningFG" }

                        elseif ($daysUntil -gt 0 -and $daysUntil -le 3 -and !$Task.Completed) { Get-ThemeProperty "Palette.InfoFG" }

                        else { Get-ThemeProperty "Palette.SubtleFG" }

            $detailsParts += Apply-PSStyle -Text " $dueDateStr" -FG $dateColor

        }

    }

   

    if ($Task.ProjectKey) {

        $project = Get-ProjectOrTemplate $Task.ProjectKey

        if ($project) {

            $detailsParts += Apply-PSStyle -Text "  $($project.Name)" -FG (Get-ThemeProperty "Palette.AccentFG")

        }

    }

   

    if ($Task.Tags -and $Task.Tags.Count -gt 0) {

        $detailsParts += Apply-PSStyle -Text "  $($Task.Tags -join ', ')" -FG (Get-ThemeProperty "Palette.InfoFG")

    }

   

    if ($Task.Progress -gt 0 -and -not $Task.Completed) {

        $detailsParts += Apply-PSStyle -Text " $($Task.Progress)%" -FG (Get-ThemeProperty "Palette.SuccessFG")

    }

   

    if ($Task.TimeSpent -gt 0) {

        $detailsParts += Apply-PSStyle -Text "  $($Task.TimeSpent)h" -FG (Get-ThemeProperty "Palette.InfoFG")

    }

   

    if ($detailsParts.Count -gt 0) {

        Write-Host ($detailsParts -join (Apply-PSStyle -Text " | " -FG (Get-ThemeProperty "Palette.SubtleFG")))

    } else { Write-Host }

 

    if ($Task.Subtasks -and $Task.Subtasks.Count -gt 0) {

        $completedSubtasks = ($Task.Subtasks | Where-Object { $_.Completed }).Count

        Write-Host "       Subtasks: $completedSubtasks/$($Task.Subtasks.Count) completed" -ForegroundColor (Get-ThemeProperty "Palette.InfoFG")

    }

}

 

function global:Show-KanbanView {

    param($TasksToDisplay)

    

    $columns = @{

        "To Do" = $TasksToDisplay | Where-Object { (-not $_.Completed) -and ($_.Progress -eq 0) -and (Get-TaskStatus $_) -notin @("Scheduled", "Overdue", "Due Today", "Due Soon") }

        "Scheduled/Due" = $TasksToDisplay | Where-Object { (-not $_.Completed) -and ($_.Progress -eq 0) -and (Get-TaskStatus $_) -in @("Scheduled", "Overdue", "Due Today", "Due Soon") }

        "In Progress" = $TasksToDisplay | Where-Object { (-not $_.Completed) -and ($_.Progress -gt 0) -and ($_.Progress -lt 100) }

        "Done" = $TasksToDisplay | Where-Object { $_.Completed -or ($_.Progress -eq 100) }

    }

    $columnOrder = @("To Do", "Scheduled/Due", "In Progress", "Done")

    $columnColors = @{

        "To Do" = (Get-ThemeProperty "Palette.PrimaryFG")

        "Scheduled/Due" = (Get-ThemeProperty "Palette.WarningFG")

        "In Progress" = (Get-ThemeProperty "Palette.InfoFG")

        "Done" = (Get-ThemeProperty "Palette.SuccessFG")

    }

 

    Write-Host "`n  KANBAN BOARD" -ForegroundColor (Get-ThemeProperty "Palette.InfoFG")

    Write-Host "  " ("=" * (($columnOrder.Count * 22) + $columnOrder.Count -1)) -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG")

    

    $maxItems = 0

    if ($columns.Values.Count -gt 0) {

        $maxItems = ($columns.Values | ForEach-Object { $_.Count } | Measure-Object -Maximum).Maximum

        if ($null -eq $maxItems) {$maxItems = 0}

    }

    if ($maxItems -eq 0) { Write-Host "  No tasks to display in Kanban view." ; return}

 

    $colWidth = 20

    $border = Get-BorderStyleChars

    

    $headerTopLine = "  $($border.TopLeft)"

    $headerTextLine = "  $($border.Vertical)"

    $headerSeparatorLine = "  $($border.TLeft)"

    foreach($colName in $columnOrder){

        $headerTopLine += ($border.Horizontal * $colWidth) + $border.TTop

        $headerTextLine += " $(Apply-PSStyle -Text $colName.ToUpper().PadRight($colWidth -1) -FG $columnColors[$colName])$($border.Vertical)"

        $headerSeparatorLine += ($border.Horizontal * $colWidth) + $border.Cross

    }

    Write-Host ($headerTopLine.Substring(0, $headerTopLine.Length-1) + $border.TopRight)

    Write-Host $headerTextLine

    Write-Host ($headerSeparatorLine.Substring(0, $headerSeparatorLine.Length-1) + $border.TRight)

    

    for ($i = 0; $i -lt $maxItems; $i++) {

        Write-Host "  $($border.Vertical)" -NoNewline

        foreach ($columnName in $columnOrder) {

            $itemsInColumn = $columns[$columnName]

            if ($i -lt $itemsInColumn.Count) {

                $item = $itemsInColumn[$i]

                $text = "$($item.Id.Substring(0,4)): $($item.Description)"

                if ($text.Length -gt ($colWidth - 2)) {

                    $text = $text.Substring(0, $colWidth - 3) + ""

                }

                $priorityInfo = Get-PriorityInfo $item.Priority

                Write-Host " $(Apply-PSStyle -Text $priorityInfo.Icon -FG $priorityInfo.Color)$($text.PadRight($colWidth - 2))" -NoNewline

            } else {

                Write-Host (" ".PadRight($colWidth)) -NoNewline

            }

            Write-Host "$($border.Vertical)" -NoNewline

        }

        Write-Host

    }

   

    $footerLine = "  $($border.BottomLeft)"

    foreach($colName in $columnOrder){

        $footerLine += ($border.Horizontal * $colWidth) + $border.TBottom

    }

    Write-Host ($footerLine.Substring(0, $footerLine.Length-1) + $border.BottomRight)

}

 

function global:Show-TimelineView {

    param($TasksToDisplay)

    

    Write-Host "`n   TIMELINE VIEW" -ForegroundColor (Get-ThemeProperty "Palette.InfoFG")

    Write-Host "  " ("=" * 60) -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG")

    

    $today = [datetime]::Today.Date

    $groups = @{

        "Overdue" = $TasksToDisplay | Where-Object { (-not [string]::IsNullOrEmpty($_.DueDate)) -and ([datetime]::Parse($_.DueDate).Date -lt $today) -and (-not $_.Completed) }

        "Today" = $TasksToDisplay | Where-Object { (-not [string]::IsNullOrEmpty($_.DueDate)) -and ([datetime]::Parse($_.DueDate).Date -eq $today) -and (-not $_.Completed) }

        "This Week" = $TasksToDisplay | Where-Object {

            (-not [string]::IsNullOrEmpty($_.DueDate)) -and

            ([datetime]::Parse($_.DueDate).Date -gt $today) -and

            ([datetime]::Parse($_.DueDate).Date -le $today.AddDays(6)) -and

            (-not $_.Completed)

        }

        "Next Week" = $TasksToDisplay | Where-Object {

            (-not [string]::IsNullOrEmpty($_.DueDate)) -and

            ([datetime]::Parse($_.DueDate).Date -gt $today.AddDays(6)) -and

            ([datetime]::Parse($_.DueDate).Date -le $today.AddDays(13)) -and

            (-not $_.Completed)

        }

        "Later" = $TasksToDisplay | Where-Object {

            (-not [string]::IsNullOrEmpty($_.DueDate)) -and

            ([datetime]::Parse($_.DueDate).Date -gt $today.AddDays(13)) -and

            (-not $_.Completed)

        }

        "No Date" = $TasksToDisplay | Where-Object { [string]::IsNullOrEmpty($_.DueDate) -and (-not $_.Completed) }

        "Completed" = $TasksToDisplay | Where-Object {$_.Completed}

    }

   

    foreach ($period in @("Overdue", "Today", "This Week", "Next Week", "Later", "No Date", "Completed")) {

        $itemsInPeriod = $groups[$period]

        if ($itemsInPeriod.Count -eq 0) { continue }

       

        $color = switch ($period) {

            "Overdue" { Get-ThemeProperty "Palette.ErrorFG" } "Today" { Get-ThemeProperty "Palette.WarningFG" }

            "This Week" { Get-ThemeProperty "Palette.InfoFG" } "Next Week" { Get-ThemeProperty "Palette.AccentFG" }

            "Later" { Get-ThemeProperty "Palette.AccentFG" } "No Date" { Get-ThemeProperty "Palette.SubtleFG" }

            "Completed" { Get-ThemeProperty "Palette.SuccessFG"}

        }

       

        Write-Host "`n   $period ($($itemsInPeriod.Count))" -ForegroundColor $color

       

        foreach ($task in $itemsInPeriod | Sort-Object @{Expression={if([string]::IsNullOrEmpty($_.DueDate)) {[DateTime]::MaxValue} else {[DateTime]::Parse($_.DueDate)}}}, Priority) {

            $priorityInfo = Get-PriorityInfo $task.Priority

            Write-Host "     $(Apply-PSStyle -Text $priorityInfo.Icon -FG $priorityInfo.Color) " -NoNewline

           

            if ((-not [string]::IsNullOrEmpty($task.DueDate)) -and $period -ne "No Date" -and $period -ne "Completed") {

                $date = try {[datetime]::Parse($task.DueDate)} catch {$null}

                if($date) {Write-Host "$($date.ToString('MMM dd')) - " -NoNewline -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG")}

            }

           

            $taskDescColor = if ($task.Completed) { (Get-ThemeProperty "Palette.SubtleFG") } else { $color }

            Write-Host (Apply-PSStyle -Text "$($task.Id.Substring(0,4)): $($task.Description)" -FG $taskDescColor) -NoNewline

           

            if ($task.ProjectKey) {

                $project = Get-ProjectOrTemplate $task.ProjectKey

                if ($project) { Write-Host (Apply-PSStyle -Text " [$($project.Name)]" -FG (Get-ThemeProperty "Palette.AccentFG")) -NoNewline }

            }

            Write-Host

        }

    }

}

 

function global:Show-ProjectTaskView {

    param($TasksToDisplay)

    

    Write-Host "`n    PROJECT VIEW" -ForegroundColor (Get-ThemeProperty "Palette.InfoFG")

    Write-Host "  " ("=" * 60) -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG")

    

    $groups = $TasksToDisplay | Group-Object ProjectKey | Sort-Object @{ Expression = { if ([string]::IsNullOrEmpty($_.Name)) { "zzz_NoProject" } else { (Get-ProjectOrTemplate $_.Name).Name } } }

    

    foreach ($group in $groups) {

        $projectKey = $group.Name

        $project = if ($projectKey) { Get-ProjectOrTemplate $projectKey } else { $null }

        $projectName = if ($project) { $project.Name } else { "[No Project]" }

       

        $activeCount = ($group.Group | Where-Object { -not $_.Completed }).Count

        $completedCount = ($group.Group | Where-Object { $_.Completed }).Count

        

        Write-Host "`n   $projectName " -NoNewline -ForegroundColor (Get-ThemeProperty "Palette.AccentFG")

        Write-Host "($activeCount active, $completedCount completed)" -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG")

        

        $totalTasksInGroup = $group.Group.Count

        $progressPercent = 0

        if ($totalTasksInGroup -gt 0) {

            $progressPercent = [Math]::Round(($completedCount / $totalTasksInGroup) * 100, 0)

        }

       

        Draw-ProgressBar -Percent $progressPercent; Write-Host ""

       

        foreach ($task in $group.Group | Sort-Object Completed, @{Expression={if([string]::IsNullOrEmpty($_.DueDate)) {[DateTime]::MaxValue} else {[DateTime]::Parse($_.DueDate)}}}, Priority) {

            Show-TaskItem $task

        }

       

        $totalEstimated = ($group.Group | Measure-Object -Property EstimatedTime -Sum).Sum

        $totalSpent = ($group.Group | Measure-Object -Property TimeSpent -Sum).Sum

       

        if ($totalEstimated -gt 0 -or $totalSpent -gt 0) {

            Write-Host "  " ("-" * 40) -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG")

            if ($totalEstimated -gt 0) { Write-Host "  Est. for these tasks: $totalEstimated hours" -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG") }

            if ($totalSpent -gt 0) {

                Write-Host "  Spent on these tasks: $totalSpent hours" -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG")

                if ($totalEstimated -gt 0 -and $totalSpent -gt 0) {

                    $efficiency = [Math]::Round(($totalEstimated / $totalSpent) * 100, 0)

                    Write-Host "  Efficiency for these: $efficiency%" -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG")

                }

            }

        }

    }

}

 

function global:Show-TaskStatistics {

    param($TasksToDisplay)

    if(-not $TasksToDisplay -or $TasksToDisplay.Count -eq 0) {

        Write-Host "`nNo tasks to show statistics for." -ForegroundColor Gray

        return

    }

   

    $stats = @{

        Total = $TasksToDisplay.Count

        Completed = ($TasksToDisplay | Where-Object { $_.Completed }).Count

        Critical = ($TasksToDisplay | Where-Object { $_.Priority -eq "Critical" -and -not $_.Completed }).Count

        High = ($TasksToDisplay | Where-Object { $_.Priority -eq "High" -and -not $_.Completed }).Count

        Medium = ($TasksToDisplay | Where-Object { $_.Priority -eq "Medium" -and -not $_.Completed }).Count

        Low = ($TasksToDisplay | Where-Object { $_.Priority -eq "Low" -and -not $_.Completed }).Count

        Overdue = ($TasksToDisplay | Where-Object {

            (-not [string]::IsNullOrEmpty($_.DueDate)) -and ([datetime]::Parse($_.DueDate).Date -lt [datetime]::Today.Date) -and (-not $_.Completed)

        }).Count

        DueToday = ($TasksToDisplay | Where-Object {

            (-not [string]::IsNullOrEmpty($_.DueDate)) -and ([datetime]::Parse($_.DueDate).Date -eq [datetime]::Today.Date) -and (-not $_.Completed)

        }).Count

        InProgress = ($TasksToDisplay | Where-Object { $_.Progress -gt 0 -and $_.Progress -lt 100 -and (-not $_.Completed) }).Count

    }

   

    Write-Host "`n" ("=" * 70) -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG")

    $statLine = @("   Total: $($stats.Total)")

    $statLine += Apply-PSStyle -Text " Done: $($stats.Completed)" -FG (Get-ThemeProperty "Palette.SuccessFG")

    if ($stats.Critical -gt 0) { $statLine += Apply-PSStyle -Text " Critical: $($stats.Critical)" -FG (Get-ThemeProperty "Palette.ErrorFG") }

    if ($stats.High -gt 0) { $statLine += Apply-PSStyle -Text " High: $($stats.High)" -FG (Get-ThemeProperty "Palette.ErrorFG") }

    if ($stats.Medium -gt 0) { $statLine += Apply-PSStyle -Text " Med: $($stats.Medium)" -FG (Get-ThemeProperty "Palette.WarningFG") }

    if ($stats.Low -gt 0) { $statLine += Apply-PSStyle -Text " Low: $($stats.Low)" -FG (Get-ThemeProperty "Palette.SuccessFG") }

    if ($stats.InProgress -gt 0) { $statLine += Apply-PSStyle -Text " In Progress: $($stats.InProgress)" -FG (Get-ThemeProperty "Palette.InfoFG") }

    if ($stats.DueToday -gt 0) { $statLine += Apply-PSStyle -Text " Due Today: $($stats.DueToday)" -FG (Get-ThemeProperty "Palette.WarningFG") }

    if ($stats.Overdue -gt 0) { $statLine += Apply-PSStyle -Text "  Overdue: $($stats.Overdue)" -FG (Get-ThemeProperty "Palette.ErrorFG") }

   

    Write-Host ($statLine -join (" " + (Apply-PSStyle -Text "|" -FG (Get-ThemeProperty "Palette.SubtleFG")) + " "))

}

 

function global:Show-TaskManagementMenu {

    $filterString = ""

    $sortByOption = "Smart"

    $showCompletedTasks = $false

    $viewModeOption = "Default"

    

    while ($true) {

        Clear-Host

        Write-Header "Task Management"

       

        Show-TasksView -Filter $filterString -SortBy $sortByOption -ShowCompleted:$showCompletedTasks -View $viewModeOption

       

        Write-Host "`n" ("=" * 70) -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG")

        $statusLine = " "

        if ($filterString) { $statusLine += Apply-PSStyle -Text "Filter: '$filterString' | " -FG (Get-ThemeProperty "Palette.InfoFG") }

        $statusLine += "Sort: $sortByOption | View: $viewModeOption | "

        $statusLine += if ($showCompletedTasks) { "Showing: All (inc. all completed)" } else { "Showing: Active / Recent Completed (last $($script:Data.Settings.ShowCompletedDays) days)" }

        Write-Host $statusLine

       

        Write-Host "`nActions: [A]dd, [C]omplete, [E]dit, [D]elete, [P]rogress, [ST]Subtasks"

        Write-Host "Display: [F]ilter, [S]ort, [V]iew Mode, [T]oggle Completed Visibility"

        Write-Host "Archive: View [AR]chived, [ARC]hive Now"

        Write-Host "Quick Entry: 'qa <task details>', 'c <id>', 'e <id>', 'd <id>'"

        Write-Host "`n[B] Back to Dashboard"

       

        $choice = Read-Host "`nCommand"

       

        if ($choice -match '^qa\s+(.+)') { Quick-AddTask -InputString $Matches[1]; continue }

        if ($choice -match '^([cde]|st|p)\s+(.+)') {

            $cmd = $Matches[1].ToLower(); $id = $Matches[2]

            switch ($cmd) {

                "c" { Complete-Task -TaskIdInput $id } "d" { Remove-Task -TaskIdInput $id }

                "e" { Edit-Task -TaskIdInput $id } "p" { Update-TaskProgress -TaskIdInput $id }

                "st" { Manage-Subtasks -TaskIdInput $id }

            }

            Write-Host "`nPress Enter to continue..." ; Read-Host; continue

        }

       

        $actionProcessed = $true

        switch ($choice.ToLower()) {

            "a" { Add-TodoTask } "c" { Complete-Task } "e" { Edit-Task } "d" { Remove-Task }

            "p" { Update-TaskProgress } "st" { Manage-Subtasks }

            "f" { $filterString = Read-Host "Filter (empty to clear)"; if ([string]::IsNullOrEmpty($filterString)) { $filterString = "" } }

            "s" {

                Write-Host "Sort by: [S]mart, [P]riority, [D]ue date, [C]reated, c[A]tegory, p[R]oject"

                $sortChoice = Read-Host "Choice"; $sortByOption = switch ($sortChoice.ToLower()) {

                    "p" { "Priority" } "d" { "DueDate" } "c" { "Created" } "a" { "Category" }

                    "r" { "Project" } default { "Smart" }

                }

            }

            "v" {

                Write-Host "View mode: [D]efault List, [K]anban, [T]imeline, [P]roject-grouped"

                $viewChoice = Read-Host "Choice"; $viewModeOption = switch ($viewChoice.ToLower()) {

                    "k" { "Kanban" } "t" { "Timeline" } "p" { "Project" } default { "Default" }

                }

            }

            "t" { $showCompletedTasks = -not $showCompletedTasks }

            "arc" { Archive-CompletedTasks } "ar" { View-TaskArchive }

            "b" { return }

            default {

                if (-not [string]::IsNullOrEmpty($choice)) { Write-Warning "Unknown command." }

                $actionProcessed = $false

            }

        }

        if ($actionProcessed -and $choice.ToLower() -ne "b") { Write-Host "`nPress Enter to continue..."; Read-Host }

    }

}

 

function global:Show-TaskAnalytics {

    Write-Header "Task Analytics"

 

    $allTasks = $script:Data.Tasks | Where-Object { $_.IsCommand -ne $true }

    if ($allTasks.Count -eq 0) { Write-Warning "No tasks available for analytics."; return }

 

    $completedTasks = $allTasks | Where-Object { $_.Completed }

    $activeTasks = $allTasks | Where-Object { -not $_.Completed }

   

    Write-Host "Overall:"

    Write-Host "  Total Tasks: $($allTasks.Count)"

    Write-Host "  Active Tasks: $($activeTasks.Count)" -ForegroundColor (Get-ThemeProperty "Palette.WarningFG")

    Write-Host "  Completed Tasks: $($completedTasks.Count)" -ForegroundColor (Get-ThemeProperty "Palette.SuccessFG")

 

    if ($allTasks.Count -gt 0) {

        $completionRate = [Math]::Round(($completedTasks.Count / $allTasks.Count) * 100, 1)

        Write-Host "  Completion Rate: $completionRate%"

    }

 

    $today = [DateTime]::Today.Date

    $startOfWeek = Get-WeekStart $today

    $startOfMonth = $today.AddDays(-($today.Day - 1))

 

    $completedThisWeek = $completedTasks | Where-Object { (-not [string]::IsNullOrEmpty($_.CompletedDate)) -and ([datetime]::Parse($_.CompletedDate).Date -ge $startOfWeek.Date) }

    $completedThisMonth = $completedTasks | Where-Object { (-not [string]::IsNullOrEmpty($_.CompletedDate)) -and ([datetime]::Parse($_.CompletedDate).Date -ge $startOfMonth.Date) }

 

    Write-Host "`nCompletion Trends:"

    Write-Host "  Completed this Week (since $($startOfWeek.ToString('MMM dd'))): $($completedThisWeek.Count)"

    Write-Host "  Completed this Month ($($startOfMonth.ToString('MMMM'))): $($completedThisMonth.Count)"

 

    Write-Host "`nActive Tasks by Priority:"

    $activeTasks | Group-Object Priority | Sort-Object @{Expression={@{"Critical"=1;"High"=2;"Medium"=3;"Low"=4}[$_.Name]}} | ForEach-Object {

        Write-Host "  $($_.Name): $($_.Count)"

    }

 

    Write-Host "`nActive Tasks by Category:"

    $activeTasks | Group-Object Category | Sort-Object Name | ForEach-Object {

        $catName = if ([string]::IsNullOrEmpty($_.Name)) {"[Uncategorized]"} else {$_.Name} # Corrected

        Write-Host "  $catName $($_.Count)"

    }

   

    $overdueTasks = $activeTasks | Where-Object { (-not [string]::IsNullOrEmpty($_.DueDate)) -and ([datetime]::Parse($_.DueDate).Date -lt $today.Date) }

    if ($overdueTasks.Count -gt 0) {

        Write-Host "`nOverdue Tasks: $($overdueTasks.Count)" -ForegroundColor (Get-ThemeProperty "Palette.ErrorFG")

        $avgOverdueDays = $overdueTasks | ForEach-Object { ($today.Date - ([datetime]::Parse($_.DueDate).Date)).Days } | Measure-Object -Average

        if ($avgOverdueDays.Average -and $avgOverdueDays.Average -gt 0) {

            Write-Host "  Average Overdue by: $([Math]::Round($avgOverdueDays.Average,1)) days"

        }

    }

    Write-Host "`nEstimated vs. Spent Time (Completed Tasks):"

    $completedWithTime = $completedTasks | Where-Object {$_.TimeSpent -gt 0 -and $_.EstimatedTime -gt 0}

    if($completedWithTime.Count -gt 0){

        $totalEst = ($completedWithTime | Measure-Object EstimatedTime -Sum).Sum

        $totalSpent = ($completedWithTime | Measure-Object TimeSpent -Sum).Sum

        Write-Host "  Total Estimated (completed w/ time): $totalEst hours"

        Write-Host "  Total Spent (completed w/ time): $totalSpent hours"

        if($totalSpent -gt 0) {

            $overallEfficiency = [Math]::Round(($totalEst / $totalSpent) * 100, 1)

            Write-Host "  Overall Efficiency: $overallEfficiency%"

        }

    } else { Write-Host "  Not enough data for efficiency calculation."}

}

 

#endregion

##########################################################################################################################################################################################################################################################################################################################################################################################################################################

# Core Time Management Module

# Handles time entries, timers, time-based reporting, and time-related settings.

 

#region Time Entry and Timers

 

function global:Add-ManualTimeEntry {

    Write-Header "Manual Time Entry"

  

    Show-ProjectsAndTemplates -Simple

   

    $projectKeyInput = Read-Host "`nProject/Template Key (or Enter to cancel)" # Renamed variable

    if ([string]::IsNullOrWhiteSpace($projectKeyInput)) { Write-Info "Manual time entry cancelled."; return }

    $project = Get-ProjectOrTemplate $projectKeyInput

  

    if (-not $project) { Write-Error "Project or Template '$projectKeyInput' not found."; return }

  

    $dateStr = Read-Host "Date (YYYY-MM-DD, 'today', 'yesterday', or press Enter for today)"

    $entryDate = $null # Renamed variable

    if ([string]::IsNullOrWhiteSpace($dateStr)) {

        $entryDate = (Get-Date).Date

    } else {

        try {

            $entryDate = switch -regex ($dateStr.ToLower()) {

                'today' { [DateTime]::Today }

                'yesterday' { [DateTime]::Today.AddDays(-1) }

                default { [DateTime]::Parse($dateStr) }

            }

        } catch { Write-Error "Invalid date format '$dateStr'."; return }

    }

  

    Write-Host "Enter time as hours (e.g., 2.5) or time range (e.g., 09:00-11:30)"

    $timeInput = Read-Host "Time"

  

    $hours = 0.0

    $startTime = ""

    $endTime = ""

  

    if ($timeInput -match '(\d{1,2}:\d{2})-(\d{1,2}:\d{2})') {

        try {

            $start = [DateTime]::Parse("$($entryDate.ToString("yyyy-MM-dd")) $($Matches[1])")

            $end = [DateTime]::Parse("$($entryDate.ToString("yyyy-MM-dd")) $($Matches[2])")

            if ($end -lt $start) { $end = $end.AddDays(1) } # Handle overnight

            $hours = ($end - $start).TotalHours

            $startTime = $Matches[1]; $endTime = $Matches[2]

            Write-Info "Calculated hours: $([Math]::Round($hours, 2))"

        } catch { Write-Error "Invalid time range format '$timeInput'."; return }

    } else {

        try { $hours = [double]$timeInput }

        catch { Write-Error "Invalid hours format '$timeInput'."; return }

    }

    if ($hours -le 0) { Write-Error "Hours must be greater than zero."; return }

 

    $description = Read-Host "Description (optional)"

  

    $taskId = $null

    if ((Read-Host "`nLink to a task? (Y/N)").ToUpper() -eq 'Y') {

        $projectTasks = $script:Data.Tasks | Where-Object { $_.ProjectKey -eq $projectKeyInput -and (-not $_.Completed) -and ($_.IsCommand -ne $true) } | Sort-Object Description

        if ($projectTasks.Count -gt 0) {

            Write-Host "`nActive tasks for project '$($project.Name)':"

            $projectTasks | ForEach-Object { Write-Host "  [$($_.Id.Substring(0,6))] $($_.Description)" }

            $taskIdInput = Read-Host "`nTask ID (partial ok, or Enter to skip)"

            if(-not [string]::IsNullOrWhiteSpace($taskIdInput)){

                $matchedTask = $script:Data.Tasks | Where-Object { $_.Id -like "$taskIdInput*" -and ($_.IsCommand -ne $true) } | Select-Object -First 1

                if ($matchedTask) {

                    $taskId = $matchedTask.Id

                    $matchedTask.TimeSpent = [Math]::Round($matchedTask.TimeSpent + $hours, 2)

                    Write-Info "Linked to task: $($matchedTask.Description)"

                } else { Write-Warning "Task not found, proceeding without task link." }

            }

        } else { Write-Info "No active tasks for this project to link." }

    }

  

    $entry = @{

        Id = New-TodoId; ProjectKey = $projectKeyInput; TaskId = $taskId; Date = $entryDate.ToString("yyyy-MM-dd");

        Hours = [Math]::Round($hours, 2); Description = $description; StartTime = ""; EndTime = "";

        EnteredAt = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")

    }

  

    if ($null -eq $script:Data.TimeEntries) { $script:Data.TimeEntries = @() }

    $script:Data.TimeEntries += $entry

 

    if ($script:Data.Projects.ContainsKey($projectKeyInput)) { Update-ProjectStatistics -ProjectKey $projectKeyInput }

    Save-UnifiedData

  

    Write-Success "Time entry added: $($entry.Hours) hours for $($project.Name) on $($entryDate.ToString('yyyy-MM-dd'))"

    Show-BudgetWarning -ProjectKey $projectKeyInput

}

 

function global:Start-Timer {

    param(

        [string]$ProjectKeyParam, # Renamed to avoid conflict

        [string]$TaskIdParam,     # Renamed to avoid conflict

        [string]$DescriptionParam # Renamed to avoid conflict

    )

  

    $projectKeyForTimer = $ProjectKeyParam # Renamed variable

    $taskIdForTimer = $TaskIdParam       # Renamed variable

    $descriptionForTimer = $DescriptionParam # Renamed variable

 

    if (-not $projectKeyForTimer -and -not $taskIdForTimer) {

        Write-Header "Start Timer"

        $choice = Read-Host "[P] Timer for Project/Template, [T] Timer for Task, or [C]ancel?"

      

        if ($choice.ToUpper() -eq 'T') {

            $activeTasks = $script:Data.Tasks | Where-Object { (-not $_.Completed) -and ($_.IsCommand -ne $true) }

            if ($activeTasks.Count -eq 0) { Write-Warning "No active tasks available."; return }

           

            $groupedTasks = $activeTasks | Group-Object ProjectKey | Sort-Object @{ Expression = { if ([string]::IsNullOrEmpty($_.Name)) { "zzz" } else { (Get-ProjectOrTemplate $_.Name).Name } } } # Renamed variable

            foreach ($group in $groupedTasks) {

                $projectName = if ($group.Name) { (Get-ProjectOrTemplate $group.Name).Name } else { "[No Project]" }

                Write-Host "`n$projectName" -ForegroundColor (Get-ThemeProperty "Palette.AccentFG")

                foreach ($taskItem in $group.Group | Sort-Object @{Expression={@{"Critical"=1;"High"=2;"Medium"=3;"Low"=4}[$_.Priority]}}, Description) {

                    $priorityInfo = Get-PriorityInfo $taskItem.Priority

                    Write-Host "  $(Apply-PSStyle -Text $priorityInfo.Icon -FG $priorityInfo.Color) [$($taskItem.Id.Substring(0,6))] $($taskItem.Description)"

                }

            }

            $taskIdInput = Read-Host "`nTask ID to start timer for (partial ok, or Enter to cancel)"

            if([string]::IsNullOrWhiteSpace($taskIdInput)) { Write-Info "Timer start cancelled."; return}

            $taskForTimer = $script:Data.Tasks | Where-Object { $_.Id -like "$taskIdInput*" -and ($_.IsCommand -ne $true) } | Select-Object -First 1

          

            if (-not $taskForTimer) { Write-Error "Task not found."; return }

            $taskIdForTimer = $taskForTimer.Id

            $projectKeyForTimer = $taskForTimer.ProjectKey

            if (-not $projectKeyForTimer) { Write-Error "Selected task is not linked to a project. Cannot start project-based timer."; return }

        } elseif ($choice.ToUpper() -eq 'P') {

            Show-ProjectsAndTemplates -Simple

            $projectKeyInput = Read-Host "`nProject/Template Key for timer (or Enter to cancel)" # Renamed variable

            if([string]::IsNullOrWhiteSpace($projectKeyInput)) { Write-Info "Timer start cancelled."; return}

            if (-not (Get-ProjectOrTemplate $projectKeyInput)) { Write-Error "Project/Template not found."; return }

            $projectKeyForTimer = $projectKeyInput

        } else { Write-Info "Timer start cancelled."; return }

    }

  

    if (-not $descriptionForTimer) { # Only prompt if not passed as param

        $descriptionForTimer = Read-Host "Timer Description (optional)"

    }

  

    $timerMapKey = if ($taskIdForTimer) { $taskIdForTimer } else { $projectKeyForTimer } # Renamed variable

    if ($script:Data.ActiveTimers.ContainsKey($timerMapKey)) {

        Write-Warning "Timer already running for this item ($timerMapKey)!"

        return

    }

  

    $timer = @{

        StartTime = Get-Date; ProjectKey = $projectKeyForTimer; TaskId = $taskIdForTimer; Description = $descriptionForTimer

    }

  

    $script:Data.ActiveTimers[$timerMapKey] = $timer

    Save-UnifiedData

  

    Write-Success "Timer started!"

    $projectDisplay = Get-ProjectOrTemplate $projectKeyForTimer # Renamed variable

    Write-Host "Project: $($projectDisplay.Name)" -ForegroundColor Gray

    if ($taskIdForTimer) {

        $taskDisplay = $script:Data.Tasks | Where-Object { $_.Id -eq $taskIdForTimer } # Renamed variable

        Write-Host "Task: $($taskDisplay.Description)" -ForegroundColor Gray

    }

    Write-Host "Started at: $(Get-Date -Format 'HH:mm:ss')" -ForegroundColor Gray

    if($descriptionForTimer) {Write-Host "Note: $descriptionForTimer" -ForegroundColor Gray}

}

 

function global:Stop-Timer {

    param([string]$TimerKeyInput) # Renamed parameter

  

    if ($script:Data.ActiveTimers.Count -eq 0) { Write-Warning "No active timers."; return }

  

    $keyToStop = $TimerKeyInput # Renamed variable

    if (-not $keyToStop) {

        Show-ActiveTimers

        $keyToStop = Read-Host "`nStop timer (ID/Key, or 'all' to stop all, Enter to cancel)"

        if ([string]::IsNullOrEmpty($keyToStop)) { Write-Info "Stop timer cancelled."; return }

    }

 

    if ($keyToStop.ToLower() -eq 'all') {

        $count = $script:Data.ActiveTimers.Count

        # Iterate over a copy of keys because Stop-SingleTimer modifies the collection

        foreach ($key in @($script:Data.ActiveTimers.Keys)) { Stop-SingleTimer -Key $key -Silent }

        Save-UnifiedData # Save once after all are stopped

        return

    }

  

    $matchedKey = $null

    foreach ($key in $script:Data.ActiveTimers.Keys) {

        if ($key -like "$keyToStop*") { $matchedKey = $key; break }

    }

  

    if (-not $matchedKey) { Write-Error "Timer with key starting '$keyToStop' not found."; return }

  

    Stop-SingleTimer -Key $matchedKey # This will call Save-UnifiedData if not silent

    if ($TimerKeyInput) { Save-UnifiedData } # Ensure save if key was passed as param (non-interactive)

}

 

function global:Stop-SingleTimer {

    param(

        [string]$Key,

        [switch]$Silent

    )

  

    $timer = $script:Data.ActiveTimers[$Key]

    if (-not $timer) {

        if (-not $Silent) {Write-Error "Timer with key '$Key' not found in active timers."}

        return

    }

  

    $endTimeValue = Get-Date # Renamed variable

    $durationHours = ($endTimeValue - [DateTime]$timer.StartTime).TotalHours # Renamed variable

    if ($durationHours -lt (1/60)) { # Less than a minute, maybe ask user?

        if (-not $Silent) {

            Write-Warning "Timer duration is less than 1 minute ($([Math]::Round($durationHours * 3600, 0)) seconds). Still log it? (Y/N)"

            if((Read-Host).ToUpper() -ne 'Y') {

                $script:Data.ActiveTimers.Remove($Key) # Remove without logging

                Save-UnifiedData

                Write-Info "Short timer discarded."

                return

            }

        } else { # If silent and too short, perhaps don't log automatically or log with a note

             # For now, log it. Could add a setting for minimum timer duration.

        }

    }

 

 

    $entry = @{

        Id = New-TodoId; ProjectKey = $timer.ProjectKey; TaskId = $timer.TaskId;

        Date = $endTimeValue.Date.ToString("yyyy-MM-dd"); Hours = [Math]::Round($durationHours, 2);

        StartTime = ([DateTime]$timer.StartTime).ToString("HH:mm"); EndTime = $endTimeValue.ToString("HH:mm");

        Description = $timer.Description; EnteredAt = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")

    }

  

    if ($null -eq $script:Data.TimeEntries) { $script:Data.TimeEntries = @() }

    $script:Data.TimeEntries += $entry

  

    if ($timer.TaskId) {

        $task = $script:Data.Tasks | Where-Object { $_.Id -eq $timer.TaskId }

        if ($task) { $task.TimeSpent = [Math]::Round($task.TimeSpent + $durationHours, 2) }

    }

  

    if ($script:Data.Projects.ContainsKey($timer.ProjectKey)) { Update-ProjectStatistics -ProjectKey $timer.ProjectKey }

  

    $script:Data.ActiveTimers.Remove($Key)

    if (-not $Silent) { Save-UnifiedData } # Save if not part of a batch stop

  

    if (-not $Silent) {

        $project = Get-ProjectOrTemplate $timer.ProjectKey

        Write-Success "Timer stopped for: $($project.Name)"

        Write-Host "Duration: $([Math]::Round($durationHours, 2)) hours ($($entry.StartTime) - $($entry.EndTime))"

        Show-BudgetWarning -ProjectKey $timer.ProjectKey

    }

}

 

function global:Show-ActiveTimers {

    Write-Header "Active Timers"

  

    if ($script:Data.ActiveTimers.Count -eq 0) { Write-Host "No active timers." -ForegroundColor Gray; return }

  

    $totalElapsed = [TimeSpan]::Zero

    foreach ($timerEnum in $script:Data.ActiveTimers.GetEnumerator()) {

        $elapsed = (Get-Date) - [DateTime]$timerEnum.Value.StartTime

        $totalElapsed += $elapsed

        $project = Get-ProjectOrTemplate $timerEnum.Value.ProjectKey

      

        Write-Host "`n[$($timerEnum.Key.Substring(0,6))] " -NoNewline -ForegroundColor Yellow

        $displayName = if($project){$project.Name}else{"Unknown Project"}

        $displayClient = if($project){$project.Client}else{"N/A"}

        Write-Host "$displayName ($displayClient)" -NoNewline # Moved project name up

       

        if ($timerEnum.Value.TaskId) {

            $task = $script:Data.Tasks | Where-Object { $_.Id -eq $timerEnum.Value.TaskId }

            if ($task) { Write-Host " - Task: $($task.Description.Substring(0, [Math]::Min($task.Description.Length, 30)))..." } # Show truncated task desc

            else { Write-Host " - Task ID: $($timerEnum.Value.TaskId) (Not Found)"}

        } else { Write-Host } # Newline if no task

      

        Write-Host "  Started: $($timerEnum.Value.StartTime.ToString('HH:mm:ss'))" -ForegroundColor Gray

        Write-Host "  Elapsed: $([Math]::Floor($elapsed.TotalHours)):$($elapsed.ToString('mm\:ss'))" -ForegroundColor Cyan

      

        if ($timerEnum.Value.Description) { Write-Host "  Note: $($timerEnum.Value.Description)" -ForegroundColor Gray }

      

        if ($project -and $project.BillingType -eq "Billable" -and $project.Rate -gt 0) {

            $value = $elapsed.TotalHours * $project.Rate

            Write-Host "  Value: `$$([Math]::Round($value, 2))" -ForegroundColor Green

        }

    }

  

    if ($script:Data.ActiveTimers.Count -gt 1) {

        Write-Host "`nTotal Time (all timers): $([Math]::Floor($totalElapsed.TotalHours)):$($totalElapsed.ToString('mm\:ss'))" -ForegroundColor Cyan

    }

}

 

function global:Quick-TimeEntry {

    param([string]$InputString) # Renamed parameter

   

    if(-not $InputString){

        $InputString = Read-Host "Quick Time Entry (Format: PROJECT_KEY HOURS [DESCRIPTION])"

        if([string]::IsNullOrWhiteSpace($InputString)) { Write-Info "Quick time entry cancelled."; return}

    }

   

    $parts = $InputString -split ' ', 3

    if ($parts.Count -lt 2) { Write-Error "Invalid format. Use: PROJECT_KEY HOURS [DESCRIPTION]"; return }

  

    $projectKey = $parts[0]

    $hours = 0.0; try { $hours = [double]$parts[1] } catch { Write-Error "Invalid hours format: '$($parts[1])'"; return }

    if($hours -le 0) { Write-Error "Hours must be positive."; return}

    $description = if ($parts.Count -eq 3) { $parts[2] } else { "" }

  

    $project = Get-ProjectOrTemplate $projectKey

    if (-not $project) { Write-Error "Unknown project or template: $projectKey"; return }

  

    $entry = @{

        Id = New-TodoId; ProjectKey = $projectKey; TaskId = $null; Date = (Get-Date).Date.ToString("yyyy-MM-dd");

        Hours = [Math]::Round($hours, 2); Description = $description; StartTime = ""; EndTime = "";

        EnteredAt = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")

    }

  

    if ($null -eq $script:Data.TimeEntries) { $script:Data.TimeEntries = @() }

    $script:Data.TimeEntries += $entry

 

    if ($script:Data.Projects.ContainsKey($projectKey)) { Update-ProjectStatistics -ProjectKey $projectKey }

    Save-UnifiedData

  

    Write-Success "Quick entry: $hours hours for $($project.Name)"

    Show-BudgetWarning -ProjectKey $projectKey

}

 

function global:Edit-TimeEntry {

    Write-Header "Edit Time Entry"

  

    $entriesToList = $script:Data.TimeEntries | # Renamed variable

        Sort-Object @{Expression = {if ([string]::IsNullOrEmpty($_.Date)) { [DateTime]::MinValue } else { [datetime]$_.Date }}; Descending = $true},

                      @{Expression = {if ([string]::IsNullOrEmpty($_.EnteredAt)) { [DateTime]::MinValue } else { [datetime]$_.EnteredAt }}; Descending = $true} |

        Select-Object -First 20

  

    if ($entriesToList.Count -eq 0) { Write-Warning "No time entries to edit."; return }

 

    Write-Host "Recent entries (select number to edit):"

    for ($i = 0; $i -lt $entriesToList.Count; $i++) {

        $entry = $entriesToList[$i]

        $project = Get-ProjectOrTemplate $entry.ProjectKey

        $projectName = if($project){$project.Name}else{"Unknown"}

        Write-Host "  [$i] $($entry.Date): $($entry.Hours)h - $projectName"

        if ($entry.Description) { Write-Host "      $($entry.Description)" -ForegroundColor Gray }

    }

  

    $indexInput = Read-Host "`nSelect entry number (or Enter to cancel)"

    if([string]::IsNullOrWhiteSpace($indexInput)) { Write-Info "Edit cancelled."; return}

    try {

        $idx = [int]$indexInput

        if ($idx -ge 0 -and $idx -lt $entriesToList.Count) {

            $entryToEditSnapshot = $entriesToList[$idx] # This is a snapshot

            # Find the actual entry in $script:Data.TimeEntries by Id to modify it

            $originalEntry = $script:Data.TimeEntries | Where-Object { $_.Id -eq $entryToEditSnapshot.Id } | Select-Object -First 1

           

            if (-not $originalEntry) { Write-Error "Original entry not found. This should not happen."; return }

 

            Write-Host "`nEditing Entry ID: $($originalEntry.Id.Substring(0,6)) for $($originalEntry.Date)" -ForegroundColor DarkGray

            Write-Host "Leave field empty to keep current value." -ForegroundColor Gray

          

            # Store old hours for stat adjustment

            $oldHours = $originalEntry.Hours

 

            $newHoursStr = Read-Host "Hours (current: $($originalEntry.Hours))"

            if (-not [string]::IsNullOrWhiteSpace($newHoursStr)) {

                try { $originalEntry.Hours = [double]$newHoursStr }

                catch { Write-Warning "Invalid hours format. Hours not changed." }

            }

          

            $newDesc = Read-Host "Description (current: $($originalEntry.Description)) (enter 'clear' to empty)"

            if ($newDesc -ne $null) { # Allow empty string or 'clear'

                $originalEntry.Description = if($newDesc.ToLower() -eq 'clear'){""}else{$newDesc}

            }

          

            $newDateStr = Read-Host "Date (current: $($originalEntry.Date)) (YYYY-MM-DD, today, etc.)"

            if(-not [string]::IsNullOrWhiteSpace($newDateStr)){

                try {

                    $parsedDate = switch -regex ($newDateStr.ToLower()) {

                        'today' { [DateTime]::Today } 'yesterday' { [DateTime]::Today.AddDays(-1) }

                        default { [DateTime]::Parse($newDateStr) }

                    }

                    $originalEntry.Date = $parsedDate.ToString("yyyy-MM-dd")

                } catch { Write-Warning "Invalid date format. Date not changed."}

            }

            # Could add editing for StartTime/EndTime if needed

 

            $originalEntry.LastModified = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")

          

            if ($script:Data.Projects.ContainsKey($originalEntry.ProjectKey)) {

                # Update-ProjectStatistics will recalculate total based on all entries

                Update-ProjectStatistics -ProjectKey $originalEntry.ProjectKey

            }

            if($originalEntry.TaskId){

                $task = $script:Data.Tasks | Where-Object {$_.Id -eq $originalEntry.TaskId}

                if($task){

                    # Adjust task time: subtract old, add new

                    $task.TimeSpent = [Math]::Round($task.TimeSpent - $oldHours + $originalEntry.Hours, 2)

                }

            }

          

            Save-UnifiedData

            Write-Success "Entry updated!"

        } else { Write-Error "Invalid selection number." }

    } catch { Write-Error "Invalid selection input: $_" }

}

 

function global:Delete-TimeEntry {

    Write-Header "Delete Time Entry"

  

    $entriesToList = $script:Data.TimeEntries |

        Sort-Object @{Expression = {if ([string]::IsNullOrEmpty($_.Date)) {[DateTime]::MinValue} else {[datetime]$_.Date}}; Descending = $true},

                      @{Expression = {if ([string]::IsNullOrEmpty($_.EnteredAt)) {[DateTime]::MinValue} else {[datetime]$_.EnteredAt}}; Descending = $true} |

        Select-Object -First 20

 

    if ($entriesToList.Count -eq 0) { Write-Warning "No time entries to delete."; return }

  

    Write-Host "Recent entries (select number to delete):"

    for ($i = 0; $i -lt $entriesToList.Count; $i++) {

        $entry = $entriesToList[$i]

        $project = Get-ProjectOrTemplate $entry.ProjectKey

        $projectName = if($project){$project.Name}else{"Unknown"}

        Write-Host "  [$i] $($entry.Date): $($entry.Hours)h - $projectName"

        if ($entry.Description) { Write-Host "      $($entry.Description)" -ForegroundColor Gray }

    }

  

    $indexInput = Read-Host "`nSelect entry number to delete (or Enter to cancel)"

    if([string]::IsNullOrWhiteSpace($indexInput)) { Write-Info "Deletion cancelled."; return}

    try {

        $idx = [int]$indexInput

        if ($idx -ge 0 -and $idx -lt $entriesToList.Count) {

            $entryToDelete = $entriesToList[$idx]

            $projectNameForConfirm = (Get-ProjectOrTemplate $entryToDelete.ProjectKey).Name

            Write-Warning "Delete this entry? ($($entryToDelete.Date): $($entryToDelete.Hours)h for $projectNameForConfirm)"

            if ((Read-Host "Type 'yes' to confirm").ToLower() -eq 'yes') {

                $originalHours = $entryToDelete.Hours

                $originalTaskId = $entryToDelete.TaskId

                $originalProjectKey = $entryToDelete.ProjectKey

 

                $script:Data.TimeEntries = $script:Data.TimeEntries | Where-Object { $_.Id -ne $entryToDelete.Id }

              

                if ($originalTaskId) {

                    $task = $script:Data.Tasks | Where-Object { $_.Id -eq $originalTaskId }

                    if ($task) { $task.TimeSpent = [Math]::Max(0, [Math]::Round($task.TimeSpent - $originalHours, 2)) }

                }

                if ($script:Data.Projects.ContainsKey($originalProjectKey)) { Update-ProjectStatistics -ProjectKey $originalProjectKey }

              

                Save-UnifiedData

                Write-Success "Entry deleted!"

            } else { Write-Info "Deletion cancelled." }

        } else { Write-Error "Invalid selection number." }

    } catch { Write-Error "Invalid selection input: $_" }

}

 

#endregion

 

#region Time Reporting

 

function global:Show-TodayTimeLog {

    Write-Header "Today's Time Log - $((Get-Date).ToString('ddd, MMM dd, yyyy'))"

  

    $todayStr = (Get-Date).ToString("yyyy-MM-dd") # Renamed variable

    $todayEntries = $script:Data.TimeEntries |

        Where-Object { $_.Date -eq $todayStr } |

        Sort-Object @{Expression = {if([string]::IsNullOrWhiteSpace($_.StartTime)){"99:99"}else{$_.StartTime}}}, EnteredAt

   

    if ($todayEntries.Count -eq 0) { Write-Host "No time entries logged for today." -ForegroundColor Gray; return }

  

    $totalHours = 0.0

    foreach ($entry in $todayEntries) {

        $project = Get-ProjectOrTemplate $entry.ProjectKey

        $projectName = if($project){$project.Name}else{"Unknown Project"}

      

        Write-Host "" # Blank line for separation

        $timeDisplay = if ($entry.StartTime -and $entry.EndTime) { "$($entry.StartTime)-$($entry.EndTime)" } else { "[Manual Entry]" }

        Write-Host (Apply-PSStyle -Text $timeDisplay.PadRight(15) -FG Gray) -NoNewline

        Write-Host (Apply-PSStyle -Text "$($entry.Hours)h".PadLeft(6) -FG Cyan) -NoNewline

        Write-Host (Apply-PSStyle -Text " - $projectName" -FG White) -NoNewline

      

        $descOrTask = $entry.Description

        if ($entry.TaskId) {

            $task = $script:Data.Tasks | Where-Object { $_.Id -eq $entry.TaskId }

            if ($task) { $descOrTask = "Task: $($task.Description)" }

            else { $descOrTask = "Task ID: $($entry.TaskId) (not found)"}

        }

        if(-not [string]::IsNullOrWhiteSpace($descOrTask)){ Write-Host (Apply-PSStyle -Text " - $descOrTask" -FG DarkCyan) }

        else { Write-Host } # Just a newline if no further description

      

        $totalHours += $entry.Hours

    }

  

    Write-Host "`n" ("-" * 50) -ForegroundColor DarkGray

    Write-Host "Total Today: $([Math]::Round($totalHours, 2)) hours" -ForegroundColor Green

  

    $targetToday = $script:Data.Settings.HoursPerDay

    if ($targetToday -gt 0) {

        $percent = [Math]::Round(($totalHours / $targetToday) * 100, 0)

        Write-Host "Target: $targetToday hours ($percent% complete)" -ForegroundColor Gray

    } else { Write-Host "Daily target not set." -ForegroundColor Gray }

}

 

function global:Show-WeekReport {

    param([DateTime]$WeekStartDate = $script:Data.CurrentWeek) # Renamed parameter

  

    Write-Header "Week Report: $($WeekStartDate.ToString('yyyy-MM-dd')) to $($WeekStartDate.AddDays(4).ToString('yyyy-MM-dd')) (Tab-Delimited)"

  

    $weekDates = Get-WeekDates $WeekStartDate

    $weekEntries = $script:Data.TimeEntries | Where-Object {

        if ([string]::IsNullOrEmpty($_.Date)) { return $false }

        try {

            $entryDate = [DateTime]::Parse($_.Date).Date

            $entryDate -ge $weekDates[0].Date -and $entryDate -le $weekDates[4].Date

        } catch { $false }

    }

  

    if ($weekEntries.Count -eq 0) { Write-Host "No time entries for this week." -ForegroundColor Gray; return }

 

    $projectHours = @{}

    $dayNames = @("Monday", "Tuesday", "Wednesday", "Thursday", "Friday")

    $dayDateMap = @{}

    for($i=0; $i -lt $dayNames.Length; $i++){ $dayDateMap[$dayNames[$i]] = $weekDates[$i].Date }

      

    foreach ($entry in $weekEntries) {

        $entryDate = [DateTime]::Parse($entry.Date).Date

        $dayNameForEntry = $dayNames | Where-Object { $dayDateMap[$_] -eq $entryDate } | Select-Object -First 1

        if(-not $dayNameForEntry) { continue } # Should not happen if logic is correct

 

        if (-not $projectHours.ContainsKey($entry.ProjectKey)) {

            $projectHours[$entry.ProjectKey] = @{ Monday = 0.0; Tuesday = 0.0; Wednesday = 0.0; Thursday = 0.0; Friday = 0.0 }

        }

        $projectHours[$entry.ProjectKey][$dayNameForEntry] += $entry.Hours

    }

  

    $outputLines = @("Name`tID1`tID2`t`t`t`tMon`tTue`tWed`tThu`tFri`tTotal`tClient`tDept") # Renamed variable

    $weekTotalHours = 0.0 # Renamed variable

    $billableTotalHours = 0.0 # Renamed variable

  

    foreach ($projEnum in ($projectHours.GetEnumerator() | Sort-Object { (Get-ProjectOrTemplate $_.Key).Name })) {

        $project = Get-ProjectOrTemplate $projEnum.Key

        if (-not $project) { continue }

      

        $formattedId2 = Format-Id2 $project.Id2

        $line = "$($project.Name)`t$($project.Id1)`t$formattedId2`t`t`t`t"

       

        $projectTotalHours = 0.0

        foreach ($day in $dayNames) {

            $hours = $projEnum.Value[$day]

            $line += "$([Math]::Round($hours,2))`t"

            $projectTotalHours += $hours

        }

      

        $weekTotalHours += $projectTotalHours

        if ($project.BillingType -eq "Billable") { $billableTotalHours += $projectTotalHours }

      

        $line += "$([Math]::Round($projectTotalHours,2))`t$($project.Client)`t$($project.Department)"

        $outputLines += $line

    }

  

    Write-Host "`nTab-Delimited Output (for copy/paste):" -ForegroundColor Yellow

    $outputLines | ForEach-Object { Write-Host $_ }

  

    Write-Host "`nWeek Summary:" -ForegroundColor Yellow

    Write-Host "  Total Hours Logged: $([Math]::Round($weekTotalHours, 2))"

    Write-Host "  Billable Hours:     $([Math]::Round($billableTotalHours, 2))"

    Write-Host "  Non-Billable Hours: $([Math]::Round($weekTotalHours - $billableTotalHours, 2))"

  

    if ($billableTotalHours -gt 0) {

        $billableValue = 0.0

        foreach ($projEnum in $projectHours.GetEnumerator()) {

            $project = Get-ProjectOrTemplate $projEnum.Key

            if ($project.BillingType -eq "Billable" -and $project.Rate -gt 0) {

                $currentProjectTotalHours = ($dayNames | ForEach-Object {$projEnum.Value[$_]} | Measure-Object -Sum).Sum

                $billableValue += $currentProjectTotalHours * $project.Rate

            }

        }

        Write-Host "  Estimated Billable Value: `$$([Math]::Round($billableValue, 2))" -ForegroundColor Green

    }

  

    $weekCompletedTasks = $script:Data.Tasks | Where-Object {

        $_.Completed -and (-not [string]::IsNullOrEmpty($_.CompletedDate)) -and

        ([DateTime]::Parse($_.CompletedDate).Date -ge $weekDates[0].Date) -and

        ([DateTime]::Parse($_.CompletedDate).Date -le $weekDates[4].Date)

    }

    if ($weekCompletedTasks.Count -gt 0) { Write-Host "  Tasks Completed This Week: $($weekCompletedTasks.Count)" -ForegroundColor Green }

  

    if ((Read-Host "`nCopy to clipboard? (Y/N)").ToUpper() -eq 'Y') {

        if (Copy-ToClipboard ($outputLines -join "`r`n")) { Write-Success "Report copied to clipboard!"}

    }

}

 

function global:Show-ExtendedReport {

    param([DateTime]$WeekStartDate = $script:Data.CurrentWeek) # Renamed parameter

  

    Write-Header "Extended Week Report: $($WeekStartDate.ToString('MMMM dd, yyyy'))"

  

    $weekDates = Get-WeekDates $WeekStartDate

    $allWeekEntries = $script:Data.TimeEntries | Where-Object { # Renamed variable

        if ([string]::IsNullOrEmpty($_.Date)) { return $false }

        try {

            $entryDate = [DateTime]::Parse($_.Date).Date

            $entryDate -ge $weekDates[0].Date -and $entryDate -le $weekDates[4].Date

        } catch {$false}

    } | Sort-Object @{Expression = {if ([string]::IsNullOrEmpty($_.Date)) {[DateTime]::MinValue} else {[datetime]$_.Date}}}, StartTime

  

    if ($allWeekEntries.Count -eq 0) { Write-Host "No time entries for this week." -ForegroundColor Gray; return }

  

    $entriesByDate = $allWeekEntries | Group-Object Date # Renamed variable

  

    foreach ($dateGroup in $entriesByDate) {

        if ([string]::IsNullOrEmpty($dateGroup.Name)) { continue }

        $currentDate = [DateTime]::Parse($dateGroup.Name) # Renamed variable

        Write-Host "`n$($currentDate.ToString('dddd, MMMM dd'))" -ForegroundColor Yellow

        Write-Host ("-" * ($currentDate.ToString('dddd, MMMM dd').Length)) -ForegroundColor DarkGray

      

        $dayTotalHours = 0.0 # Renamed variable

        foreach ($entry in $dateGroup.Group) {

            $project = Get-ProjectOrTemplate $entry.ProjectKey

            $projectName = if($project){$project.Name}else{"Unknown"}

            $projectClient = if($project){$project.Client}else{"N/A"}

 

            Write-Host "  " -NoNewline

            $timeDisplay = if ($entry.StartTime -and $entry.EndTime) { "$($entry.StartTime)-$($entry.EndTime)".PadRight(12) } else { "[Manual]".PadRight(12) }

            Write-Host (Apply-PSStyle -Text $timeDisplay -FG Gray) -NoNewline

            Write-Host (Apply-PSStyle -Text "$($entry.Hours)h".PadLeft(6) -FG Cyan) -NoNewline

            Write-Host (Apply-PSStyle -Text " - $projectName ($projectClient)" -FG White) -NoNewline

          

            $descOrTask = $entry.Description

            if ($entry.TaskId) {

                $task = $script:Data.Tasks | Where-Object { $_.Id -eq $entry.TaskId }

                if ($task) { $descOrTask = "Task: $($task.Description)" }

                else { $descOrTask = "Task ID: $($entry.TaskId) (not found)"}

            }

            if(-not [string]::IsNullOrWhiteSpace($descOrTask)){ Write-Host (Apply-PSStyle -Text " - $descOrTask" -FG DarkCyan) }

            else { Write-Host }

          

            $dayTotalHours += $entry.Hours

        }

        Write-Host "  " ("-" * 48) -ForegroundColor DarkGray

        Write-Host "  Day Total: $([Math]::Round($dayTotalHours, 2)) hours" -ForegroundColor Green

    }

  

    Write-Host "`n`nWeek Summary by Project:" -ForegroundColor Yellow

    Write-Host ("-" * 50) -ForegroundColor DarkGray

  

    $entriesByProject = $allWeekEntries | Group-Object ProjectKey # Renamed variable

    $grandTotalHours = 0.0; $billableTotalHours = 0.0; $billableTotalValue = 0.0 # Renamed variables

  

    foreach ($projGroup in $entriesByProject | Sort-Object { (Get-ProjectOrTemplate $_.Name).Name }) {

        $project = Get-ProjectOrTemplate $projGroup.Name

        $projTotalHours = ($projGroup.Group | Measure-Object -Property Hours -Sum).Sum

        $projTotalHours = [Math]::Round($projTotalHours, 2)

        $grandTotalHours += $projTotalHours

      

        Write-Host "  $(Apply-PSStyle -Text $project.Name.PadRight(30) -FG White): " -NoNewline

        Write-Host (Apply-PSStyle -Text "$projTotalHours hours".PadRight(15) -FG Cyan) -NoNewline

      

        if ($project.BillingType -eq "Billable" -and $project.Rate -gt 0) {

            $value = $projTotalHours * $project.Rate

            $billableTotalHours += $projTotalHours

            $billableTotalValue += $value

            Write-Host (Apply-PSStyle -Text "(`$$([Math]::Round($value, 2)))" -FG Green)

        } else { Write-Host (Apply-PSStyle -Text "(Non-billable)" -FG Gray) }

      

        $projectTasksWithTime = $projGroup.Group | Where-Object { $_.TaskId } | Group-Object TaskId |

                                Sort-Object { ($script:Data.Tasks | Where-Object {$_.Id -eq $_.Name} | Select -ExpandProperty Description) }

        if ($projectTasksWithTime.Count -gt 0) {

            foreach ($taskGroup in $projectTasksWithTime) {

                $task = $script:Data.Tasks | Where-Object { $_.Id -eq $taskGroup.Name }

                if ($task) {

                    $taskHours = ($taskGroup.Group | Measure-Object -Property Hours -Sum).Sum

                    Write-Host "     $($task.Description): $([Math]::Round($taskHours, 2))h" -ForegroundColor DarkCyan

                }

            }

        }

    }

  

    Write-Host "`n" ("-" * 50) -ForegroundColor DarkGray

    Write-Host "  Total Hours Logged:  $([Math]::Round($grandTotalHours, 2))" -ForegroundColor White

    Write-Host "  Billable Hours:      $([Math]::Round($billableTotalHours, 2))" -ForegroundColor Cyan

    Write-Host "  Non-Billable Hours:  $([Math]::Round($grandTotalHours - $billableTotalHours, 2))" -ForegroundColor Gray

    Write-Host "  Total Billable Value:$([Math]::Round($billableTotalValue, 2))" -ForegroundColor Green

  

    $targetWeeklyHours = $script:Data.Settings.HoursPerDay * $script:Data.Settings.DaysPerWeek # Renamed variable

    if ($targetWeeklyHours -gt 0) {

        $utilization = ($grandTotalHours / $targetWeeklyHours) * 100

        Write-Host "  Utilization:         $([Math]::Round($utilization, 1))% of $targetWeeklyHours target hours" -ForegroundColor Magenta

    }

  

    $weekTasksActivity = $script:Data.Tasks | Where-Object { # Renamed variable

        ((-not [string]::IsNullOrEmpty($_.CreatedDate)) -and [DateTime]::Parse($_.CreatedDate).Date -ge $weekDates[0].Date -and [DateTime]::Parse($_.CreatedDate).Date -le $weekDates[4].Date) -or

        ((-not [string]::IsNullOrEmpty($_.CompletedDate)) -and [DateTime]::Parse($_.CompletedDate).Date -ge $weekDates[0].Date -and [DateTime]::Parse($_.CompletedDate).Date -le $weekDates[4].Date)

    }

    if ($weekTasksActivity.Count -gt 0) {

        Write-Host "`n  Task Activity This Week:" -ForegroundColor Yellow

        $createdCount = ($weekTasksActivity | Where-Object { (-not [string]::IsNullOrEmpty($_.CreatedDate)) -and [DateTime]::Parse($_.CreatedDate).Date -ge $weekDates[0].Date -and [DateTime]::Parse($_.CreatedDate).Date -le $weekDates[4].Date }).Count

        $completedCount = ($weekTasksActivity | Where-Object { (-not [string]::IsNullOrEmpty($_.CompletedDate)) -and [DateTime]::Parse($_.CompletedDate).Date -ge $weekDates[0].Date -and [DateTime]::Parse($_.CompletedDate).Date -le $weekDates[4].Date }).Count

        Write-Host "    Tasks Created:  $createdCount"

        Write-Host "    Tasks Completed: $completedCount"

    }

}

 

function global:Show-MonthSummary {

    Write-Header "Month Summary"

  

    $monthStartDate = Get-Date -Day 1 -Hour 0 -Minute 0 -Second 0 # Renamed variable

    $monthEndDate = $monthStartDate.AddMonths(1).AddDays(-1).AddHours(23).AddMinutes(59).AddSeconds(59)

   

    Write-Host "Month: $($monthStartDate.ToString('MMMM yyyy'))" -ForegroundColor Yellow

  

    $monthEntries = $script:Data.TimeEntries | Where-Object {

        if ([string]::IsNullOrEmpty($_.Date)) { return $false }

        try {

            $entryDate = [DateTime]::Parse($_.Date).Date

            $entryDate -ge $monthStartDate.Date -and $entryDate -le $monthEndDate.Date

        } catch {$false}

    }

  

    if ($monthEntries.Count -eq 0) { Write-Host "No time entries for this month." -ForegroundColor Gray; return }

  

    $entriesByProject = $monthEntries | Group-Object ProjectKey # Renamed variable

    Write-Host "`nTime Logged By Project:" -ForegroundColor Yellow

    $monthTotalHours = 0.0 # Renamed variable

  

    foreach ($group in $entriesByProject | Sort-Object { (Get-ProjectOrTemplate $_.Name).Name }) {

        $project = Get-ProjectOrTemplate $group.Name

        $hours = ($group.Group | Measure-Object -Property Hours -Sum).Sum

        $hours = [Math]::Round($hours, 2)

        $monthTotalHours += $hours

        Write-Host "  $($project.Name): $hours hours"

        if ($project.BillingType -eq "Billable" -and $project.Rate -gt 0) {

            $value = $hours * $project.Rate

            Write-Host "    Est. Billable Value: `$$([Math]::Round($value, 2))" -ForegroundColor Green

        }

    }

    Write-Host "`nTotal Hours This Month: $([Math]::Round($monthTotalHours, 2))" -ForegroundColor Green

  

    $monthTasksActivity = $script:Data.Tasks | Where-Object { # Renamed variable

        ((-not [string]::IsNullOrEmpty($_.CreatedDate)) -and [DateTime]::Parse($_.CreatedDate).Date -ge $monthStartDate.Date -and [DateTime]::Parse($_.CreatedDate).Date -le $monthEndDate.Date) -or

        ((-not [string]::IsNullOrEmpty($_.CompletedDate)) -and [DateTime]::Parse($_.CompletedDate).Date -ge $monthStartDate.Date -and [DateTime]::Parse($_.CompletedDate).Date -le $monthEndDate.Date)

    }

    if ($monthTasksActivity.Count -gt 0) {

        Write-Host "`nTask Activity This Month:" -ForegroundColor Yellow

        $createdCount = ($monthTasksActivity | Where-Object { (-not [string]::IsNullOrEmpty($_.CreatedDate)) -and [DateTime]::Parse($_.CreatedDate).Date -ge $monthStartDate.Date -and [DateTime]::Parse($_.CreatedDate).Date -le $monthEndDate.Date }).Count

        $completedCount = ($monthTasksActivity | Where-Object { (-not [string]::IsNullOrEmpty($_.CompletedDate)) -and [DateTime]::Parse($_.CompletedDate).Date -ge $monthStartDate.Date -and [DateTime]::Parse($_.CompletedDate).Date -le $monthEndDate.Date }).Count

        Write-Host "  Tasks Created: $createdCount"

        Write-Host "  Tasks Completed: $completedCount"

    }

}

 

function global:Show-TimeAnalytics {

    Write-Header "Time Analytics"

  

    $monthStartDate = Get-Date -Day 1 -Hour 0 -Minute 0 -Second 0 # Renamed variable

    $currentMonthEntries = $script:Data.TimeEntries | Where-Object { # Renamed variable

        (-not [string]::IsNullOrEmpty($_.Date)) -and ([DateTime]::Parse($_.Date).Date -ge $monthStartDate.Date)

    }

    $currentMonthHours = ($currentMonthEntries | Measure-Object -Property Hours -Sum).Sum # Renamed variable

    $currentMonthHours = if ($currentMonthHours) { [Math]::Round($currentMonthHours, 2) } else { 0.0 }

    Write-Host "This Month ($($monthStartDate.ToString('MMMM yyyy'))): $currentMonthHours hours" -ForegroundColor Yellow

  

    $thirtyDaysAgo = (Get-Date).AddDays(-30).Date

    $last30DaysEntries = $script:Data.TimeEntries | Where-Object { # Renamed variable

        (-not [string]::IsNullOrEmpty($_.Date)) -and ([DateTime]::Parse($_.Date).Date -ge $thirtyDaysAgo)

    }

    $last30DaysHours = ($last30DaysEntries | Measure-Object -Property Hours -Sum).Sum # Renamed variable

    $last30DaysHours = if ($last30DaysHours) { [Math]::Round($last30DaysHours, 2) } else { 0.0 }

    Write-Host "Last 30 Days: $last30DaysHours hours" -ForegroundColor Yellow

  

    $daysWithEntries = ($last30DaysEntries | Where-Object { -not [string]::IsNullOrEmpty($_.Date) } | Group-Object Date).Count

    if ($daysWithEntries -gt 0) {

        $dailyAvg = [Math]::Round($last30DaysHours / $daysWithEntries, 2)

        Write-Host "Daily Average (logged days): $dailyAvg hours (over $daysWithEntries working days in last 30)" -ForegroundColor Green

    }

  

    Write-Host "`nHours Logged by Day of Week (Last 30 Days):" -ForegroundColor Yellow

    $entriesByDayOfWeek = $last30DaysEntries | Where-Object { -not [string]::IsNullOrEmpty($_.Date) } | Group-Object { [DateTime]::Parse($_.Date).DayOfWeek } | Sort-Object Name # Renamed variable

    foreach ($group in $entriesByDayOfWeek) {

        $hours = [Math]::Round(($group.Group | Measure-Object -Property Hours -Sum).Sum, 2)

        Write-Host "  $([System.Globalization.CultureInfo]::CurrentCulture.DateTimeFormat.GetDayName($group.Name)): $hours hours"

    }

  

    Write-Host "`nTop 5 Projects (Last 30 Days by Hours):" -ForegroundColor Yellow

    $topProjectsByHours = $last30DaysEntries | Group-Object ProjectKey |  # Renamed variable

        Select-Object @{N="ProjectKey";E={$_.Name}}, @{N="TotalHours";E={($_.Group | Measure-Object Hours -Sum).Sum}} |

        Sort-Object TotalHours -Descending | Select-Object -First 5

    foreach ($projInfo in $topProjectsByHours) { # Renamed variable

        $project = Get-ProjectOrTemplate $projInfo.ProjectKey

        Write-Host "  $($project.Name): $([Math]::Round($projInfo.TotalHours,2)) hours"

    }

}

 

function global:Export-FormattedTimesheet {

    param(

        [DateTime]$WeekStartDate = $script:Data.CurrentWeek, # Renamed parameter

        [string]$OutputFilePath # Renamed parameter

    )

 

    Write-Header "Export Formatted Timesheet for Week Starting $($WeekStartDate.ToString('yyyy-MM-dd'))"

 

    if (-not $OutputFilePath) {

        $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"

        $OutputFilePath = Join-Path ([Environment]::GetFolderPath("Desktop")) "FormattedTimesheet_Export_WeekOf_$($WeekStartDate.ToString('yyyyMMdd'))_$timestamp.csv"

    }

 

    $weekDates = Get-WeekDates $WeekStartDate

    $weekEntries = $script:Data.TimeEntries | Where-Object {

        if ([string]::IsNullOrEmpty($_.Date)) { return $false }

        try {

            $entryDate = [DateTime]::Parse($_.Date).Date

            $entryDate -ge $weekDates[0].Date -and $entryDate -le $weekDates[4].Date

        } catch {$false}

    }

 

    if ($weekEntries.Count -eq 0) { Write-Warning "No time entries for the week. Export cancelled."; return }

 

    $projectHours = @{}

    $dayNames = @("Monday", "Tuesday", "Wednesday", "Thursday", "Friday")

    $dayDateMap = @{}; for($i=0; $i -lt $dayNames.Length; $i++){ $dayDateMap[$dayNames[$i]] = $weekDates[$i].Date }

 

    foreach ($entry in $weekEntries) {

        $entryDate = [DateTime]::Parse($entry.Date).Date

        $dayNameForEntry = $dayNames | Where-Object { $dayDateMap[$_] -eq $entryDate } | Select-Object -First 1

        if(-not $dayNameForEntry) { continue }

 

        if (-not $projectHours.ContainsKey($entry.ProjectKey)) {

            $project = Get-ProjectOrTemplate $entry.ProjectKey

            $projectHours[$entry.ProjectKey] = @{

                ProjectName = if($project){$project.Name}else{"Unknown"}

                Id1 = if($project){$project.Id1}else{""}

                Id2 = if($project){Format-Id2 $project.Id2}else{Format-Id2 ""}

                Monday = 0.0; Tuesday = 0.0; Wednesday = 0.0; Thursday = 0.0; Friday = 0.0

            }

        }

        $projectHours[$entry.ProjectKey][$dayNameForEntry] += $entry.Hours

    }

 

    $exportData = @()

    foreach ($projKey in ($projectHours.Keys | Sort-Object { $projectHours[$_].ProjectName })) {

        $projData = $projectHours[$projKey]

        $exportData += [PSCustomObject]@{

            ProjectName = $projData.ProjectName

            Id1 = $projData.Id1

            Id2 = $projData.Id2

            Monday = [Math]::Round($projData.Monday, 2)

            Tuesday = [Math]::Round($projData.Tuesday, 2)

            Wednesday = [Math]::Round($projData.Wednesday, 2)

            Thursday = [Math]::Round($projData.Thursday, 2)

            Friday = [Math]::Round($projData.Friday, 2)

            Total = [Math]::Round(($projData.Monday + $projData.Tuesday + $projData.Wednesday + $projData.Thursday + $projData.Friday), 2)

        }

    }

 

    try {

        $exportData | Export-Csv -Path $OutputFilePath -NoTypeInformation -Encoding UTF8

        Write-Success "Formatted timesheet exported to: $OutputFilePath"

        if ((Read-Host "Open file now? (Y/N)").ToUpper() -eq 'Y') {

            try { Start-Process $OutputFilePath } catch { Write-Warning "Could not open file: $_"}

        }

    } catch { Write-Error "Failed to export timesheet: $_" }

}

 

#endregion

 

#region Time Settings and Utilities

 

function global:Edit-TimeTrackingSettings {

    Write-Header "Time Tracking Settings"

    Write-Host "Leave empty to keep current value." -ForegroundColor Gray

  

    $settings = $script:Data.Settings # Alias

   

    $newRateStr = Read-Host "`nDefault hourly rate (current: $($settings.DefaultRate))"

    if (-not [string]::IsNullOrWhiteSpace($newRateStr)) {

        try { $settings.DefaultRate = [double]$newRateStr }

        catch { Write-Warning "Invalid rate format. Not changed." }

    }

  

    $newHoursStr = Read-Host "`nTarget hours per day (current: $($settings.HoursPerDay))"

    if (-not [string]::IsNullOrWhiteSpace($newHoursStr)) {

        try { $settings.HoursPerDay = [double]$newHoursStr } # Allow fractional hours

        catch { Write-Warning "Invalid hours format. Not changed." }

    }

  

    $newDaysStr = Read-Host "`nTarget days per week (current: $($settings.DaysPerWeek))"

    if (-not [string]::IsNullOrWhiteSpace($newDaysStr)) {

        try {

            $days = [int]$newDaysStr

            if($days -ge 1 -and $days -le 7) { $settings.DaysPerWeek = $days }

            else { Write-Warning "Days per week must be between 1 and 7. Not changed."}

        }

        catch { Write-Warning "Invalid days format. Not changed." }

    }

  

    Save-UnifiedData

    Write-Success "Time tracking settings updated!"

}

 

function global:Show-BudgetWarning {

    param([string]$ProjectKey)

  

    if (-not $script:Data.Projects.ContainsKey($ProjectKey)) { return } # Only for actual projects

    $project = Get-ProjectOrTemplate $ProjectKey

   

    if (-not $project -or $project.BillingType -eq "Non-Billable" -or -not $project.Budget -or $project.Budget -le 0) { # Budget must be > 0

        return

    }

  

    Update-ProjectStatistics -ProjectKey $ProjectKey

    $project = $script:Data.Projects[$ProjectKey] # Re-fetch after update for fresh TotalHours

 

    $totalHours = if ($project.TotalHours -is [double] -or $project.TotalHours -is [int]) { $project.TotalHours } else { 0.0 }

    $percentUsed = ($totalHours / $project.Budget) * 100

   

    if ($percentUsed -ge 100) {

        Write-Warning "BUDGET EXCEEDED for $($project.Name): $([Math]::Round($percentUsed, 1))% used. Budget: $($project.Budget)h, Used: $($totalHours)h."

    } elseif ($percentUsed -ge 90) {

        Write-Warning "Budget alert for $($project.Name): $([Math]::Round($percentUsed, 1))% used ($([Math]::Round($project.Budget - $totalHours, 2)) hours remaining)."

    } elseif ($percentUsed -ge 75) {

        Write-Info "Budget notice for $($project.Name): $([Math]::Round($percentUsed, 1))% used."

    }

}

 

#endregion

 

##########################################################################################################################################################################################################################################################################################################################################################################################################################################

# Helper Functions Module

# Utility functions for file I/O, date handling, validation, etc.

 

#region Configuration

 

$script:DataPath = Join-Path $env:USERPROFILE ".ProductivitySuite"

$script:UnifiedDataFile = Join-Path $script:DataPath "unified_data.json"

$script:ConfigFile = Join-Path $script:DataPath "config.json" # Not actively used in provided code

$script:BackupPath = Join-Path $script:DataPath "backups"

$script:ExcelCopyConfigFile = Join-Path $script:DataPath "excelcopy_configs.json" # Not actively used

 

# Ensure directories exist

@($script:DataPath, $script:BackupPath) | ForEach-Object {

    if (-not (Test-Path $_)) {

        New-Item -ItemType Directory -Path $_ -Force | Out-Null

    }

}

 

#endregion

 

#region PowerShell 5.1 Compatibility Functions

 

function global:ConvertFrom-JsonToHashtable {

    param([string]$JsonString)

   

    function Convert-PSObjectToHashtable {

        param($InputObject)

       

        if ($null -eq $InputObject) { return $null }

       

        if ($InputObject -is [PSCustomObject]) {

            $hashtable = @{}

            $InputObject.PSObject.Properties | ForEach-Object {

                $hashtable[$_.Name] = Convert-PSObjectToHashtable $_.Value

            }

            return $hashtable

        }

        elseif ($InputObject -is [array]) {

            return @($InputObject | ForEach-Object { Convert-PSObjectToHashtable $_ })

        }

        else {

            return $InputObject

        }

    }

   

    $psobject = $JsonString | ConvertFrom-Json

    return Convert-PSObjectToHashtable $psobject

}

 

#endregion

 

#region Data Persistence

 

function global:Load-UnifiedData {

    try {

        if (Test-Path $script:UnifiedDataFile) {

            $jsonContent = Get-Content $script:UnifiedDataFile -Raw

            $loadedData = ConvertFrom-JsonToHashtable $jsonContent

           

            # Ensure $script:Data and $script:Data.Settings are initialized with defaults first

            # This is guaranteed by core-data.ps1 loading before this function is called from main.ps1

            # But adding a safeguard here just in case.

            if (-not $script:Data) {

                Write-Error "CRITICAL: \$script:Data not initialized before Load-UnifiedData call. This indicates a script loading order problem."

                $script:Data = @{ Settings = (Get-DefaultSettings); Projects = @{}; Tasks = @(); TimeEntries = @(); ActiveTimers = @{}; ArchivedTasks = @{}; ExcelCopyJobs = @{}; CurrentWeek = (Get-WeekStart (Get-Date)) }

            } elseif (-not $script:Data.Settings) {

                 $script:Data.Settings = (Get-DefaultSettings)

            }

 

            # Deep merge to preserve structure and handle missing keys in saved data

            foreach ($topLevelKey in $loadedData.Keys) {

                if ($topLevelKey -eq "Settings") {

                    # --- START OF CRITICAL FIX FOR NULL SETTINGS ERROR ---

                    # Special handling for Settings: ensure it's a hashtable and merge carefully

                    if ($loadedData.Settings -is [hashtable] -and $script:Data.Settings -is [hashtable]) {

                        $defaultSettings = Get-DefaultSettings

                        foreach ($settingKey in $defaultSettings.Keys) {

                            if ($loadedData.Settings.ContainsKey($settingKey)) {

                                # Deep merge for nested hashtables within Settings

                                if ($settingKey -eq "Theme" -and $loadedData.Settings.Theme -is [hashtable] -and $defaultSettings.Theme -is [hashtable]) {

                                    foreach ($themeColorKey in $defaultSettings.Theme.Keys) {

                                        if ($loadedData.Settings.Theme.ContainsKey($themeColorKey)) {

                                            $script:Data.Settings.Theme[$themeColorKey] = $loadedData.Settings.Theme[$themeColorKey]

                                        } # Else, keep default theme color

                                    }

                                } elseif ($settingKey -eq "TimeTrackerTemplates" -and $loadedData.Settings.TimeTrackerTemplates -is [hashtable]) {

                                    $script:Data.Settings.TimeTrackerTemplates = $loadedData.Settings.TimeTrackerTemplates

                                } elseif ($settingKey -eq "CommandSnippets" -and $loadedData.Settings.CommandSnippets -is [hashtable]) {

                                    foreach($csKey in $defaultSettings.CommandSnippets.Keys){

                                         if($loadedData.Settings.CommandSnippets.ContainsKey($csKey)){

                                             $script:Data.Settings.CommandSnippets[$csKey] = $loadedData.Settings.CommandSnippets[$csKey]

                                         } # Else, keep default

                                    }

                                } elseif ($settingKey -eq "ExcelFormConfig" -and $loadedData.Settings.ExcelFormConfig -is [hashtable]) {

                                    # Deep merge ExcelFormConfig

                                    if ($loadedData.Settings.ExcelFormConfig.WorksheetName) {

                                        $script:Data.Settings.ExcelFormConfig.WorksheetName = $loadedData.Settings.ExcelFormConfig.WorksheetName

                                    } else {

                                        $script:Data.Settings.ExcelFormConfig.WorksheetName = $defaultSettings.ExcelFormConfig.WorksheetName

                                    }

                                    foreach($fieldKey in $defaultSettings.ExcelFormConfig.StandardFields.Keys){

                                        if($loadedData.Settings.ExcelFormConfig.StandardFields.ContainsKey($fieldKey)){

                                            $script:Data.Settings.ExcelFormConfig.StandardFields[$fieldKey] = $loadedData.Settings.ExcelFormConfig.StandardFields[$fieldKey]

                                        } # Else, keep default

                                    }

                                }

                                else {

                                    $script:Data.Settings[$settingKey] = $loadedData.Settings[$settingKey]

                                }

                            } # Else, the key is missing in loaded data, so the default from Get-DefaultSettings (already in $script:Data.Settings) remains.

                        }

                    } else {

                        # If loadedData.Settings is not a hashtable (e.g., it was null in JSON),

                        # or if $script:Data.Settings somehow isn't a hashtable (shouldn't happen if core-data.ps1 loads first),

                        # then we reset $script:Data.Settings to the default to ensure it's valid.

                        Write-Warning "Loaded 'Settings' data is invalid or not a hashtable. Keeping default settings."

                        $script:Data.Settings = (Get-DefaultSettings)

                    }

                    # --- END OF CRITICAL FIX FOR NULL SETTINGS ERROR ---

                } elseif ($script:Data.ContainsKey($topLevelKey)) { # For other top-level keys like Projects, Tasks, etc.

                    $script:Data[$topLevelKey] = $loadedData[$topLevelKey]

                } # Else, loaded data has a top-level key not in default $script:Data structure; ignore it to maintain schema.

            }

           

            # Ensure CurrentWeek is a DateTime

            if ($script:Data.CurrentWeek -is [string]) {

                try {

                    $script:Data.CurrentWeek = [DateTime]::Parse($script:Data.CurrentWeek)

                } catch {

                    Write-Warning "Could not parse CurrentWeek '$($script:Data.CurrentWeek)'. Resetting to current week."

                    $script:Data.CurrentWeek = Get-WeekStart (Get-Date) # Get-WeekStart must be global

                }

            } elseif ($null -eq $script:Data.CurrentWeek) { # If CurrentWeek was missing entirely

                 $script:Data.CurrentWeek = Get-WeekStart (Get-Date)

            }

        } else {

            Write-Info "No existing data file found. Starting with default data."

            # $script:Data is already initialized with defaults by core-data.ps1

        }

    } catch {

        Write-Warning "Could not load data due to an error, starting fresh: $_"

        # Ensure $script:Data is reset to defaults if loading fails catastrophically

        $script:Data = @{ Settings = (Get-DefaultSettings); Projects = @{}; Tasks = @(); TimeEntries = @(); ActiveTimers = @{}; ArchivedTasks = @{}; ExcelCopyJobs = @{}; CurrentWeek = (Get-WeekStart (Get-Date)) }

    }

}

 

function global:Save-UnifiedData {

    try {

        # Auto-backup

        if ((Get-Random -Maximum 10) -eq 0 -or -not (Test-Path $script:UnifiedDataFile)) {

            Backup-Data -Silent

        }

       

        $script:Data | ConvertTo-Json -Depth 10 | Set-Content $script:UnifiedDataFile -Encoding UTF8

    } catch {

        Write-Error "Failed to save data: $_"

    }

}

 

function global:Backup-Data {

    param([switch]$Silent)

   

    $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"

    $backupFile = Join-Path $script:BackupPath "backup_$timestamp.json"

   

    try {

        $script:Data | ConvertTo-Json -Depth 10 | Set-Content $backupFile -Encoding UTF8

        if (-not $Silent) {

            Write-Success "Backup created: $backupFile"

        }

       

        # Keep only last 30 backups

        Get-ChildItem $script:BackupPath -Filter "backup_*.json" |

            Sort-Object CreationTime -Descending |

            Select-Object -Skip 30 |

            Remove-Item -Force

    } catch {

        Write-Error "Backup failed: $_"

    }

}

 

function global:Restore-FromBackup {

    Write-Header "Restore from Backup"

   

    $backups = Get-ChildItem $script:BackupPath -Filter "backup_*.json" | Sort-Object CreationTime -Descending

   

    if ($backups.Count -eq 0) {

        Write-Warning "No backups found"

        return

    }

   

    Write-Host "Available backups:"

    for ($i = 0; $i -lt $backups.Count; $i++) {

        $backupItem = $backups[$i]

        $date = $backupItem.CreationTime.ToString("yyyy-MM-dd HH:mm:ss")

        $size = [Math]::Round($backupItem.Length / 1KB, 2)

        Write-Host "  [$i] $date ($size KB)"

    }

   

    $indexInput = Read-Host "`nSelect backup number"

    try {

        $idx = [int]$indexInput

        if ($idx -ge 0 -and $idx -lt $backups.Count) {

            $selectedBackup = $backups[$idx]

           

            Write-Warning "This will replace all current data! Type 'yes' to confirm"

            $confirm = Read-Host

           

            if ($confirm -eq 'yes') {

                # Backup current data first

                Backup-Data -Silent

               

                # Load backup

                $jsonContent = Get-Content $selectedBackup.FullName -Raw

                $backupData = ConvertFrom-JsonToHashtable $jsonContent

                $script:Data = $backupData # This replaces the entire $script:Data

               

                # Re-initialize CurrentWeek to DateTime if it was stored as string in backup

                if ($script:Data.CurrentWeek -is [string]) {

                    try { $script:Data.CurrentWeek = [DateTime]::Parse($script:Data.CurrentWeek) }

                    catch { $script:Data.CurrentWeek = Get-WeekStart (Get-Date) }

                } elseif ($null -eq $script:Data.CurrentWeek) {

                    $script:Data.CurrentWeek = Get-WeekStart (Get-Date)

                }

 

                # --- START OF IMPROVED SETTINGS MERGE FOR RESTORE ---

                # Ensure settings are present and merge with defaults if backup is old/missing some

                $defaultSettings = Get-DefaultSettings

                if (-not $script:Data.Settings -or -not ($script:Data.Settings -is [hashtable])) {

                    $script:Data.Settings = $defaultSettings # If settings are missing or invalid, reset to defaults

                } else {

                    # Deep merge for settings to ensure all default keys are present and valid

                    foreach($key in $defaultSettings.Keys){

                        if(-not $script:Data.Settings.ContainsKey($key)){

                            $script:Data.Settings[$key] = $defaultSettings[$key]

                        }

                        # For nested hashtables, ensure their structure too

                        elseif ($defaultSettings[$key] -is [hashtable] -and $script:Data.Settings[$key] -is [hashtable]) {

                            foreach($subKey in $defaultSettings[$key].Keys){

                                if(-not $script:Data.Settings[$key].ContainsKey($subKey)){

                                    $script:Data.Settings[$key][$subKey] = $defaultSettings[$key][$subKey]

                                }

                            }

                        }

                    }

                }

                # --- END OF IMPROVED SETTINGS MERGE FOR RESTORE ---

 

                Save-UnifiedData

                Initialize-ThemeSystem # Re-initialize theme after restoring data

               

                Write-Success "Data restored from backup!"

                Write-Info "A backup of your previous data was created."

            } else { Write-Info "Restore cancelled." }

        } else { Write-Error "Invalid selection number." }

    } catch {

        Write-Error "Invalid selection input: $_"

    }

}

 

#endregion

 

#region ID Generation

 

function global:New-TodoId {

    return [System.Guid]::NewGuid().ToString().Substring(0, 8)

}

 

function global:Format-Id2 {

    param([string]$Id2Input)

 

    $id2ToFormat = if ([string]::IsNullOrEmpty($Id2Input)) { "" } else { $Id2Input }

   

    if ($id2ToFormat.Length -gt 9) {

        $id2ToFormat = $id2ToFormat.Substring(0, 9)

    }

   

    $paddingNeeded = 12 - 2 - $id2ToFormat.Length # 12 total, V and S are 2 chars

    $zeros = "0" * [Math]::Max(0, $paddingNeeded) # Ensure padding is not negative

   

    return "V${zeros}${id2ToFormat}S"

}

 

#endregion

 

#region Date Functions

 

function global:Get-WeekStart {

    param([DateTime]$DateInput = (Get-Date))

   

    $daysFromMonday = [int]$DateInput.DayOfWeek

    # DayOfWeek: Sunday = 0, Monday = 1, ..., Saturday = 6

    if ($daysFromMonday -eq 0) { $daysFromMonday = 7 } # Adjust Sunday to be 7 for calculation

    $monday = $DateInput.AddDays(1 - $daysFromMonday) # If Monday (1), 1-1=0. If Sunday (7), 1-7=-6.

   

    return Get-Date $monday -Hour 0 -Minute 0 -Second 0

}

 

function global:Get-WeekDates {

    param([DateTime]$WeekStartDate)

   

    return @(0..4 | ForEach-Object { $WeekStartDate.AddDays($_) }) # Monday to Friday

}

 

function global:Format-TodoDate {

    param($DateString)

    if ([string]::IsNullOrEmpty($DateString)) { return "" }

    try {

        $date = [datetime]::Parse($DateString)

        $today = [datetime]::Today # Just the date part

        $diffDays = ($date.Date - $today).Days # Compare Date parts only

       

        $dateStr = $date.ToString("MMM dd")

        if ($diffDays -eq 0) { return "Today" }

        elseif ($diffDays -eq 1) { return "Tomorrow" }

        elseif ($diffDays -eq -1) { return "Yesterday" }

        elseif ($diffDays -gt 1 -and $diffDays -le 7) { return "$dateStr (in $diffDays days)" }

        elseif ($diffDays -lt -1) {

            $absDiff = [Math]::Abs($diffDays)

            return "$dateStr ($absDiff days ago)"

        }

        else { return $dateStr } # Covers dates far in future or other unhandled cases

    }

    catch { return $DateString } # Return original string if parsing fails

}

 

function global:Get-NextWeekday {

    param([int]$TargetDayOfWeek) # 0 for Sunday, 1 for Monday, ..., 6 for Saturday

   

    $today = [datetime]::Today

    $currentDayOfWeek = [int]$today.DayOfWeek

    $daysToAdd = ($TargetDayOfWeek - $currentDayOfWeek + 7) % 7

    if ($daysToAdd -eq 0) { $daysToAdd = 7 } # If today is the target day, get next week's target day

   

    return $today.AddDays($daysToAdd)

}

 

#endregion

 

#region Validation Functions

 

function global:Test-ExcelConnection {

    Write-Header "Test Excel Connection"

    $excel = $null # Initialize for finally block

    try {

        Write-Info "Testing Excel COM object creation..."

        $excel = New-Object -ComObject Excel.Application

        Write-Success "Excel COM object created successfully!"

       

        Write-Info "Excel version: $($excel.Version)"

       

        $excel.Quit()

        # ReleaseComObject calls are important

    } catch {

        Write-Error "Excel connection test failed: $_"

        Write-Warning "Make sure Microsoft Excel is installed on this system."

    } finally {

        if ($excel) {

            try { [System.Runtime.InteropServices.Marshal]::ReleaseComObject($excel) | Out-Null } catch {}

            Remove-Variable excel -ErrorAction SilentlyContinue

        }

        [GC]::Collect()

        [GC]::WaitForPendingFinalizers()

    }

}

 

#endregion

 

#region Import/Export Functions

 

function global:Export-AllData {

    Write-Header "Export All Data"

   

    $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"

    $exportPath = Join-Path ([Environment]::GetFolderPath("Desktop")) "ProductivitySuite_Export_$timestamp"

    New-Item -ItemType Directory -Path $exportPath -Force | Out-Null

   

    # Export main data

    $script:Data | ConvertTo-Json -Depth 10 | Set-Content (Join-Path $exportPath "unified_data.json") -Encoding UTF8

   

    # Export time entries as CSV

    if ($script:Data.TimeEntries -and $script:Data.TimeEntries.Count -gt 0) {

        $timeExport = $script:Data.TimeEntries | ForEach-Object {

            $project = Get-ProjectOrTemplate $_.ProjectKey

            [PSCustomObject]@{

                Date = $_.Date

                ProjectKey = $_.ProjectKey

                ProjectName = if ($project) { $project.Name } else { "N/A" }

                Hours = $_.Hours

                Description = $_.Description

                TaskId = $_.TaskId

                StartTime = $_.StartTime

                EndTime = $_.EndTime

            }

        }

        $timeExport | Export-Csv (Join-Path $exportPath "time_entries.csv") -NoTypeInformation -Encoding UTF8

    }

   

    # Export tasks as CSV

    if ($script:Data.Tasks -and $script:Data.Tasks.Count -gt 0) {

        $taskExport = $script:Data.Tasks | ForEach-Object {

            $project = if ($_.ProjectKey) { Get-ProjectOrTemplate $_.ProjectKey } else { $null }

            [PSCustomObject]@{

                Id = $_.Id

                Description = $_.Description

                Priority = $_.Priority

                Category = $_.Category

                ProjectName = if ($project) { $project.Name } else { "" }

                Status = Get-TaskStatus $_ # Get-TaskStatus must be global

                DueDate = $_.DueDate

                Progress = $_.Progress

                TimeSpent = $_.TimeSpent

                EstimatedTime = $_.EstimatedTime

                Tags = if ($_.Tags) { $_.Tags -join "," } else { "" }

            }

        }

        $taskExport | Export-Csv (Join-Path $exportPath "tasks.csv") -NoTypeInformation -Encoding UTF8

    }

   

    # Export projects as CSV

    if ($script:Data.Projects -and $script:Data.Projects.Count -gt 0) {

        $projectExport = $script:Data.Projects.GetEnumerator() | ForEach-Object {

            $projValue = $_.Value

            [PSCustomObject]@{

                Key = $_.Key

                Name = $projValue.Name

                Id1 = $projValue.Id1

                Id2 = $projValue.Id2

                Client = $projValue.Client

                Department = $projValue.Department

                Status = $projValue.Status

                BillingType = $projValue.BillingType

                Rate = $projValue.Rate

                Budget = $projValue.Budget

                TotalHours = $projValue.TotalHours

                ActiveTasks = $projValue.ActiveTasks

                CompletedTasks = $projValue.CompletedTasks

            }

        }

        $projectExport | Export-Csv (Join-Path $exportPath "projects.csv") -NoTypeInformation -Encoding UTF8

    }

   

    # Export command snippets

    $commands = $script:Data.Tasks | Where-Object { $_.IsCommand -eq $true }

    if ($commands.Count -gt 0) {

        $commandExport = $commands | ForEach-Object {

            [PSCustomObject]@{

                Id = $_.Id

                Name = $_.Description

                Command = $_.Notes # Command text is in Notes field for snippets

                Category = $_.Category

                Tags = if ($_.Tags) { $_.Tags -join "," } else { "" }

                Hotkey = if ($_.Hotkey) { $_.Hotkey } else { "" }

                CreatedDate = $_.CreatedDate

            }

        }

        $commandExport | Export-Csv (Join-Path $exportPath "command_snippets.csv") -NoTypeInformation -Encoding UTF8

    }

   

    Write-Success "Data exported to: $exportPath"

   

    # Open folder

    try {

        Start-Process $exportPath

    } catch {

        Write-Warning "Could not open export folder: $_"

    }

}

 

function global:Import-Data {

    Write-Header "Import Data"

   

    Write-Warning "This will merge imported data with existing data or allow full replacement."

    Write-Host "Enter path to unified_data.json file:"

    $importFilePath = Read-Host

   

    if (-not (Test-Path $importFilePath -PathType Leaf)) {

        Write-Error "File not found or is a directory!"

        return

    }

   

    try {

        # Backup current data first

        Backup-Data -Silent

       

        $jsonContent = Get-Content $importFilePath -Raw

        $importedData = ConvertFrom-JsonToHashtable $jsonContent

       

        Write-Host "`nImport options:"

        Write-Host "[1] Merge with existing data (adds new, skips existing by ID/Key)"

        Write-Host "[2] Replace all data (current data will be overwritten!)"

        Write-Host "[3] Cancel"

       

        $choice = Read-Host "Choice"

       

        switch ($choice) {

            "1" { # Merge

                if ($importedData.Projects) {

                    foreach ($key in $importedData.Projects.Keys) {

                        if (-not $script:Data.Projects.ContainsKey($key)) {

                            $script:Data.Projects[$key] = $importedData.Projects[$key]

                            Write-Success "Imported project: $key"

                        } else {

                            Write-Warning "Skipped existing project (key already exists): $key"

                        }

                    }

                }

               

                if ($importedData.Tasks) {

                    $existingTaskIds = $script:Data.Tasks | ForEach-Object { $_.Id }

                    $importedTaskCount = 0

                    foreach ($task in $importedData.Tasks) {

                        if ($task.Id -notin $existingTaskIds) {

                            $script:Data.Tasks += $task

                            $importedTaskCount++

                        }

                    }

                    Write-Success "Imported $importedTaskCount new tasks"

                }

               

                if ($importedData.TimeEntries) {

                    if ($null -eq $script:Data.TimeEntries) { $script:Data.TimeEntries = @() }

                    $existingTimeEntryIds = $script:Data.TimeEntries | ForEach-Object { $_.Id }

                    $importedTimeEntryCount = 0

                    foreach ($entry in $importedData.TimeEntries) {

                         if ($null -eq $entry.Id -or $entry.Id -notin $existingTimeEntryIds) {

                            if ($null -eq $entry.Id) { $entry.Id = New-TodoId }

                            $script:Data.TimeEntries += $entry

                            $importedTimeEntryCount++

                        }

                    }

                    Write-Success "Imported $importedTimeEntryCount new time entries"

                }

               

                # --- START OF IMPROVED SETTINGS MERGE FOR IMPORT (MERGE MODE) ---

                # Merge settings carefully if present in import

                if ($importedData.Settings -is [hashtable]) { # Ensure imported settings are a hashtable

                    Write-Info "Merging settings..."

                    $defaultSettings = Get-DefaultSettings

                    foreach ($settingKey in $defaultSettings.Keys) {

                        if ($importedData.Settings.ContainsKey($settingKey)) {

                            # Handle nested hashtables like Theme, CommandSnippets, ExcelFormConfig carefully

                            if ($script:Data.Settings[$settingKey] -is [hashtable] -and $importedData.Settings[$settingKey] -is [hashtable]) {

                                foreach ($subKey in $importedData.Settings[$settingKey].Keys) {

                                    if ($script:Data.Settings[$settingKey].ContainsKey($subKey)) {

                                        $script:Data.Settings[$settingKey][$subKey] = $importedData.Settings[$settingKey][$subKey]

                                    }

                                }

                            } else {

                                $script:Data.Settings[$settingKey] = $importedData.Settings[$settingKey]

                            }

                        }

                    }

                } else {

                    Write-Warning "Imported 'Settings' data is invalid or not a hashtable. Skipping settings merge."

                }

                # --- END OF IMPROVED SETTINGS MERGE FOR IMPORT (MERGE MODE) ---

 

                Save-UnifiedData

                Initialize-ThemeSystem # Re-initialize theme if settings were part of import

                Write-Success "Data merge complete!"

            }

            "2" { # Replace

                Write-Warning "This will REPLACE ALL current data. Are you absolutely sure? Type 'yes' to confirm"

                $confirmReplace = Read-Host

                if ($confirmReplace -eq 'yes') {

                    $script:Data = $importedData

                    # Re-initialize CurrentWeek to DateTime if it was stored as string in import

                    if ($script:Data.CurrentWeek -is [string]) {

                        try { $script:Data.CurrentWeek = [DateTime]::Parse($script:Data.CurrentWeek) }

                        catch { $script:Data.CurrentWeek = Get-WeekStart (Get-Date) }

                    } elseif ($null -eq $script:Data.CurrentWeek) {

                         $script:Data.CurrentWeek = Get-WeekStart (Get-Date)

                    }

                    # --- START OF IMPROVED SETTINGS MERGE FOR IMPORT (REPLACE MODE) ---

                    # Ensure settings structure is complete by merging with defaults

                    $defaultSettings = Get-DefaultSettings

                    if (-not $script:Data.Settings -or -not ($script:Data.Settings -is [hashtable])) {

                        $script:Data.Settings = $defaultSettings # If settings are missing or invalid, reset to defaults

                    } else {

                        foreach($key in $defaultSettings.Keys){

                            if(-not $script:Data.Settings.ContainsKey($key)){

                                $script:Data.Settings[$key] = $defaultSettings[$key]

                            }

                            # For nested hashtables, ensure their structure too

                            elseif ($defaultSettings[$key] -is [hashtable] -and $script:Data.Settings[$key] -is [hashtable]) {

                                foreach($subKey in $defaultSettings[$key].Keys){

                                    if(-not $script:Data.Settings[$key].ContainsKey($subKey)){

                                        $script:Data.Settings[$key][$subKey] = $defaultSettings[$key][$subKey]

                                    }

                                }

                            }

                        }

                    }

                    # --- END OF IMPROVED SETTINGS MERGE FOR IMPORT (REPLACE MODE) ---

 

                    Save-UnifiedData

                    Initialize-ThemeSystem # Re-initialize theme after replacing data

                    Write-Success "Data replaced successfully!"

                } else { Write-Info "Replacement cancelled."}

            }

            "3" {

                Write-Info "Import cancelled"

            }

            default {

                Write-Warning "Invalid choice. Import cancelled."

            }

        }

    } catch {

        Write-Error "Import failed: $_"

    }

}

 

#endregion

 

#region Reset Functions

 

function global:Reset-ToDefaults {

    Write-Header "Reset to Defaults"

   

    Write-Warning "This will reset all settings to defaults. Your data (tasks, projects, time entries) will be preserved."

    Write-Host "Type 'yes' to confirm:"

    $confirm = Read-Host

   

    if ($confirm -eq 'yes') {

        # Backup first

        Backup-Data -Silent

       

        # Reset settings while preserving data

        # Get-DefaultSettings must be available (defined in core-data.ps1)

        $script:Data.Settings = Get-DefaultSettings

        

        Save-UnifiedData

        Initialize-ThemeSystem # Re-initialize theme after resetting settings

       

        Write-Success "Settings reset to defaults!"

        Write-Info "Your projects, tasks, and time entries remain untouched."

    } else { Write-Info "Reset cancelled."}

}

 

#endregion

 

#region Clipboard Functions

 

function global:Copy-ToClipboard {

    param([string]$TextToCopy)

   

    try {

        $TextToCopy | Set-Clipboard

        return $true

    } catch {

        Write-Warning "Could not copy to clipboard: $_"

        return $false

    }

}

 

function global:Get-FromClipboard {

    try {

        return Get-Clipboard

    } catch {

        Write-Warning "Could not read from clipboard: $_"

        return $null

    }

}

 

 

 

##########################################################################################################################################################################################################################################################################################################################################################################################################################################

# Unified Productivity Suite v5.0 - Main Entry Point

# PowerShell 7.2+ Recommended for full PSStyle support (7.5+ ideal)

 

#region Module Loading

 

# Get script directory

$script:ModuleRoot = $PSScriptRoot

if (-not $script:ModuleRoot) {

    try { $script:ModuleRoot = Split-Path $MyInvocation.MyCommand.Path -Parent }

    catch { Write-Error "Could not determine script root. Please run as a .ps1 file."; exit 1 }

}

 

# Initialize data structure first

$script:Data = $null

 

# Dot source modules in dependency order

 

if (Test-Path "$script:ModuleRoot\helper.ps1") { . "$script:ModuleRoot\helper.ps1" }

if (Test-Path "$script:ModuleRoot\core-data.ps1") { . "$script:ModuleRoot\core-data.ps1" }

if (Test-Path "$script:ModuleRoot\theme.ps1") { . "$script:ModuleRoot\theme.ps1" }

if (Test-Path "$script:ModuleRoot\ui.ps1") { . "$script:ModuleRoot\ui.ps1" }

if (Test-Path "$script:ModuleRoot\core-time.ps1") { . "$script:ModuleRoot\core-time.ps1" }

 

# Initialize systems in correct order

if (Get-Command Load-UnifiedData -ErrorAction SilentlyContinue) {

    Load-UnifiedData

} else {

    Write-Error "Load-UnifiedData function not available. Check helper.ps1."

    exit 1

}

 

if (Get-Command Initialize-ThemeSystem -ErrorAction SilentlyContinue) {

    Initialize-ThemeSystem

}

 

#endregion

 

 

#region Quick Action System

 

$script:QuickActionMap = @{

    '9' = { Add-ManualTimeEntry; return $true }

    's' = { Start-Timer; return $true }

    'stop' = { Stop-Timer; return $true }

    'a' = { Add-TodoTask; return $true }

    'qa' = { $userInput = Read-Host "Quick add task details"; Quick-AddTask -InputString $userInput; return $true }

    'v' = { Show-ActiveTimers; Write-Host "`nPress any key..."; $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown"); return $true }

    't' = { Show-TodayView; return $true }

    'tasks' = { Show-TaskManagementMenu; return $true }

    'w' = { Show-WeekReport; Write-Host "`nPress Enter..."; Read-Host; return $true }

    'p' = { Show-ProjectDetail; Write-Host "`nPress Enter..."; Read-Host; return $true }

    'projects' = { Show-ProjectsMenu; return $true }

    'c' = { Manage-CommandSnippets; return $true }

    'r' = { Show-ReportsMenu; return $true }

    'export' = { Export-FormattedTimesheet; return $true }

    'h' = { Show-Help; return $true }

    '?' = { Show-QuickActionHelp; return $true }

    'cal' = { Show-Calendar; return $true }

}

 

# Add aliases after the main map is created

$script:QuickActionMap['m'] = $script:QuickActionMap['9']

$script:QuickActionMap['time'] = $script:QuickActionMap['9']

$script:QuickActionMap['timer'] = $script:QuickActionMap['s']

$script:QuickActionMap['task'] = $script:QuickActionMap['a']

$script:QuickActionMap['week'] = $script:QuickActionMap['w']

$script:QuickActionMap['cmd'] = $script:QuickActionMap['c']

$script:QuickActionMap['snippets'] = $script:QuickActionMap['c']

$script:QuickActionMap['reports'] = $script:QuickActionMap['r']

$script:QuickActionMap['timesheet'] = $script:QuickActionMap['export']

$script:QuickActionMap['help'] = $script:QuickActionMap['h']

 

 

function global:Process-QuickAction {

    param([string]$Key)

   

    $action = $script:QuickActionMap[$Key.ToLower()]

    if ($action) { return & $action }

   

    $matches = $script:QuickActionMap.Keys | Where-Object { $_ -like "$($Key.ToLower())*" }

    if ($matches.Count -eq 1) { return & $script:QuickActionMap[$matches[0]] }

    elseif ($matches.Count -gt 1) { Write-Warning "Ambiguous quick action '$Key'. Matches: $($matches -join ', ')"; return $true }

   

    return $false

}

 

function global:Show-QuickActionHelp {

    Write-Header "Quick Actions Help (+Key)"

    Write-Host "Use '+' followed by a keyword from any prompt:" -ForegroundColor Gray; Write-Host ""

   

    $actionHelp = @(

        @{ Category="Time"; Actions=@("9, m, time: Manual time entry", "s, timer: Start timer", "stop: Stop timer")},

        @{ Category="Task"; Actions=@("a, task: Add full task", "qa: Quick add task", "t: Today's View", "tasks: Full Task Menu")},

        @{ Category="Views & Reports"; Actions=@("v: View active timers", "w, week: Week report", "timesheet: Export timesheet", "r, reports: Reports Menu", "cal: Calendar")},

        @{ Category="Project"; Actions=@("p: Project details", "projects: Projects Menu")},

        @{ Category="Snippets"; Actions=@("c, cmd, snippets: Command snippets")},

        @{ Category="Other"; Actions=@("h, help: Main help screen", "?: This quick action help")}

    )

    foreach($cat in $actionHelp){

        Write-Host "$($cat.Category):" -ForegroundColor Yellow

        foreach($act in $cat.Actions){ Write-Host "  +$act"}

        Write-Host ""

    }

    Write-Host "`nPress any key to continue..."

    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")

}

 

#endregion

 

#region Menu Structure & Functions

 

function global:Show-ProjectsMenu { # Wrapper for Projects & Clients submenu

    while ($true) {

        # Check if Show-ProjectsAndTemplates exists (it's part of core-data.ps1, so it should)

        if (Get-Command -Name Show-ProjectsAndTemplates -ErrorAction SilentlyContinue) {

            Show-ProjectsAndTemplates # Display list before menu options

        } else {

            Write-Warning "Show-ProjectsAndTemplates function not found. Cannot display project list."

        }

        Write-Host ""

        if (Show-Menu $script:MenuStructure["Projects & Clients"]) { break } # Show-Menu returns $true to break

    }

}

 

function global:Show-ReportsMenu { # Wrapper for Reports & Analytics submenu

     while ($true) {

        if (Show-Menu $script:MenuStructure["Reports & Analytics"]) { break }

    }

}

 

function global:Show-ExcelIntegrationMenu { # Placeholder

    Write-Header "Excel Integration"

    Write-Warning "Excel Copy Jobs feature is not fully implemented in this version."

    Write-Host "[1] Configure Excel Form Import Mapping (for Projects)"

    Write-Host "[B] Back"

    $choice = Read-Host "Choice"

    if($choice -eq "1"){ Configure-ExcelForm }

}

 

 

$script:MenuStructure = @{

    "Time Management" = @{ Header = "Time Management"; Options = @(

        @{Key="1"; Label="Manual Time Entry"; Action={Add-ManualTimeEntry}}

        @{Key="2"; Label="Start Timer"; Action={Start-Timer}}

        @{Key="3"; Label="Stop Timer"; Action={Stop-Timer}}

        @{Key="4"; Label="View Active Timers"; Action={ Show-ActiveTimers }}

        @{Key="5"; Label="Quick Time Entry"; Action={ Quick-TimeEntry }} # Will prompt for input

        @{Key="6"; Label="Edit Time Entry"; Action={Edit-TimeEntry}}

        @{Key="7"; Label="Delete Time Entry"; Action={Delete-TimeEntry}}

        @{Key="8"; Label="Today's Full Time Log"; Action={Show-TodayTimeLog}}

        @{Key="9"; Label="Export Formatted Timesheet"; Action={Export-FormattedTimesheet}}

    )}

    "Task Management" = @{ Header = "Task Management"; Action = {Show-TaskManagementMenu} } # Direct action

    "Reports & Analytics" = @{ Header = "Reports & Analytics"; Options = @(

        @{Key="1"; Label="Week Report (Tab-Delimited)"; Action={Show-WeekReport}}

        @{Key="2"; Label="Extended Week Report (Detailed)"; Action={Show-ExtendedReport}}

        @{Key="3"; Label="Month Summary Report"; Action={Show-MonthSummary}}

        @{Key="4"; Label="Project Summary Report"; Action={Show-ProjectSummary}}

        @{Key="5"; Label="Task Analytics"; Action={Show-TaskAnalytics}}

        @{Key="6"; Label="Time Analytics"; Action={Show-TimeAnalytics}}

        @{Key="7"; Label="Export All Data (JSON & CSVs)"; Action={Export-AllData}}

        @{Key="8"; Label="Formatted Timesheet (CSV for current week)"; Action={Export-FormattedTimesheet}}

        @{Key="9"; Label="Change Report Week"; Action={Change-ReportWeek}}

    )}

    "Projects & Clients" = @{ Header = "Projects & Clients"; Options = @(

        @{Key="1"; Label="Add New Project"; Action={Add-Project}}

        @{Key="2"; Label="Import Project from Excel Form"; Action={Import-ProjectFromExcel}}

        @{Key="3"; Label="View Project/Template Details"; Action={Show-ProjectDetail}}

        @{Key="4"; Label="Edit Existing Project"; Action={Edit-Project}}

        @{Key="5"; Label="Configure Excel Form Import Mapping"; Action={Configure-ExcelForm}}

        # @{Key="6"; Label="Batch Import Projects (Not Implemented)"; Action={Batch-ImportProjects}}

        @{Key="7"; Label="Export All Projects (CSV)"; Action={Export-Projects}}

    )}

    "Tools & Utilities" = @{ Header = "Tools & Utilities"; Options = @(

        @{Key="1"; Label="Command Snippets Manager"; Action={Manage-CommandSnippets}}

        @{Key="2"; Label="Excel Integration Options"; Action={Show-ExcelIntegrationMenu}}

        @{Key="3"; Label="View Calendar"; Action={Show-Calendar}}

        @{Key="4"; Label="Backup Data Now"; Action={ Backup-Data }}

        @{Key="5"; Label="Test Excel COM Connection"; Action={Test-ExcelConnection}}

        @{Key="6"; Label="Quick Actions Help (+?)"; Action={Show-QuickActionHelp}}

    )}

    "Settings & Config" = @{ Header = "Settings & Configuration"; Options = @(

        @{Key="1"; Label="Time Tracking Settings"; Action={Edit-TimeTrackingSettings}}

        @{Key="2"; Label="Task Management Settings"; Action={Edit-TaskSettings}}

        @{Key="3"; Label="Excel Form Import Configuration"; Action={Configure-ExcelForm}}

        @{Key="4"; Label="Theme Color Settings"; Action={Edit-ThemeSettings}}

        @{Key="5"; Label="Command Snippet Settings"; Action={Edit-CommandSnippetSettings}}

        @{Key="6"; Label="Export All Application Data"; Action={Export-AllData}}

        @{Key="7"; Label="Import Application Data"; Action={Import-Data}}

        @{Key="8"; Label="Restore Data from Backup"; Action={Restore-FromBackup}}

        @{Key="9"; Label="Reset All Settings to Defaults"; Action={Reset-ToDefaults}}

    )}

}

 

#endregion

 

#region Main Functions

 

function global:Show-Menu {

    param($MenuConfig)

   

    Write-Header $MenuConfig.Header

   

    if ($MenuConfig.Options) {

        foreach ($option in $MenuConfig.Options) { Write-Host "[$($option.Key)] $($option.Label)" }

        Write-Host "`n[B] Back to Dashboard"

       

        $choice = Read-Host "`nChoice"

       

        if ($choice.ToUpper() -eq 'B') { return $true } # Indicate to go back

       

        $selectedOption = $MenuConfig.Options | Where-Object { $_.Key -eq $choice }

        if ($selectedOption) {

            & $selectedOption.Action

            Write-Host "`nPress Enter to continue..." ; Read-Host

        } else { Write-Warning "Invalid choice."; Start-Sleep -Seconds 1 }

        return $false # Indicate to stay in menu

    } elseif ($MenuConfig.Action) {

        & $MenuConfig.Action

        return $true # Assume direct action menus return to dashboard afterwards

    }

    Write-Warning "Menu configuration error for $($MenuConfig.Header)."

    return $true # Error, go back

}

 

function global:Show-MainMenu {

    while ($true) {

        Show-Dashboard

        

        Write-Host "`nCommand: " -NoNewline -ForegroundColor Yellow

        $choice = Read-Host

       

        if ($choice -match '^\+(.+)$') {

            if (Process-QuickAction $matches[1]) { # Action handled (found or ambiguous)

                # If action has its own pause, it will handle it. Otherwise, main loop continues.

            } else { Write-Warning "Unknown quick action: +$($matches[1]). Use +? for help."; Start-Sleep -Seconds 1 }

            continue

        }

       

        $actionTakenRequiresPause = $false

        switch ($choice.ToUpper()) {

            "M" { Add-ManualTimeEntry; $actionTakenRequiresPause = $true }

            "S" { Start-Timer; $actionTakenRequiresPause = $true }

            "A" { Add-TodoTask; $actionTakenRequiresPause = $true }

            "V" { Show-ActiveTimers; $actionTakenRequiresPause = $true }

            "T" { Show-TodayView; $actionTakenRequiresPause = $true } # Dashboard shortcut for Today View

            "W" { Show-WeekReport; $actionTakenRequiresPause = $true }

            "P" {

                # Ensure Show-ProjectDetail exists before calling

                if (Get-Command -Name Show-ProjectDetail -ErrorAction SilentlyContinue) {

                    Show-ProjectDetail; $actionTakenRequiresPause = $true

                } else {

                    Write-Warning "Show-ProjectDetail function not found. Please check core-data.ps1."

                    Start-Sleep -Seconds 1

                }

            }

            "H" { Show-Help; $actionTakenRequiresPause = $true }

           

            "1" { while (-not (Show-Menu $script:MenuStructure["Time Management"])) { } }

            "2" { Show-TaskManagementMenu } # Handles its own loop and pauses

            "3" { Show-ReportsMenu }        # Handles its own loop and pauses

            "4" { Show-ProjectsMenu }       # Handles its own loop and pauses

            "5" { while (-not (Show-Menu $script:MenuStructure["Tools & Utilities"])) { } }

            "6" { while ($true) { Show-CurrentSettings; if (Show-Menu $script:MenuStructure["Settings & Config"]) { break } } }

           

            "Q" {

                if ($script:Data.ActiveTimers -and $script:Data.ActiveTimers.Count -gt 0) {

                    Write-Warning "You have $($script:Data.ActiveTimers.Count) active timer(s) running!"

                    if ((Read-Host "Stop all timers before quitting? (Y/N)").ToUpper() -eq 'Y') {

                        foreach ($key in @($script:Data.ActiveTimers.Keys)) { Stop-SingleTimer -Key $key -Silent }

                        Save-UnifiedData # Save after stopping all

                    }

                }

                Save-UnifiedData

                Write-Host "`n Thanks for using Unified Productivity Suite!" -ForegroundColor Cyan

                Write-Host "Stay productive! " -ForegroundColor Yellow

                return

            }

            default {

                if ($choice -match '^q\s+(.+)') { Quick-TimeEntry $choice.Substring(2); $actionTakenRequiresPause = $true }

                elseif ($choice -match '^qa\s+(.+)') { Quick-AddTask -InputString $choice.Substring(3); $actionTakenRequiresPause = $true }

                elseif (-not [string]::IsNullOrEmpty($choice)) {

                    Write-Warning "Unknown command. Press [H] for help or +? for quick actions."

                    Start-Sleep -Seconds 1

                }

                # If choice is empty (just Enter), loop will show dashboard again without pause

            }

        }

        if ($actionTakenRequiresPause) { Write-Host "`nPress Enter to continue..."; Read-Host }

    }

}

 

function global:Show-TodayView {

#    Clear-Host

    Write-Header "Today's Overview - $((Get-Date).ToString('dddd, MMMM dd, yyyy'))"

   

    $todayStr = (Get-Date).ToString("yyyy-MM-dd")

    

    $todayHours = 0.0

    if ($script:Data.TimeEntries) {

        $todayEntries = $script:Data.TimeEntries | Where-Object { $_.Date -eq $todayStr }

        $todayHours = ($todayEntries | Measure-Object -Property Hours -Sum).Sum

        $todayHours = if ($todayHours) { [Math]::Round($todayHours, 2) } else { 0.0 }

    }

   

    Write-Host "  TIME LOGGED TODAY: " -NoNewline -ForegroundColor (Get-ThemeProperty "Palette.WarningFG")

    Write-Host "$todayHours hours" -NoNewline

    $targetHours = $script:Data.Settings.HoursPerDay

    $percent = if ($targetHours -gt 0) { [Math]::Round(($todayHours / $targetHours) * 100, 0) } else { 0 }

    Write-Host " ($percent% of $targetHours hour target)" -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG")

    

    if ($script:Data.ActiveTimers -and $script:Data.ActiveTimers.Count -gt 0) {

        Write-Host "`n ACTIVE TIMERS:" -ForegroundColor (Get-ThemeProperty "Palette.ErrorFG")

        foreach ($timer in $script:Data.ActiveTimers.GetEnumerator()) {

            $elapsed = (Get-Date) - [DateTime]$timer.Value.StartTime

            $project = Get-ProjectOrTemplate $timer.Value.ProjectKey

            $projectName = if($project){$project.Name}else{"Unknown"}

            Write-Host "    $projectName $([Math]::Floor($elapsed.TotalHours)):$($elapsed.ToString('mm\:ss'))" -ForegroundColor (Get-ThemeProperty "Palette.InfoFG")

        }

    }

   

    $today = [DateTime]::Today.Date

    $overdueTasks = $script:Data.Tasks | Where-Object { (-not $_.Completed) -and ($_.IsCommand -ne $true) -and (-not [string]::IsNullOrEmpty($_.DueDate)) -and ([datetime]::Parse($_.DueDate).Date -lt $today) }

    $dueTodayTasks = $script:Data.Tasks | Where-Object { (-not $_.Completed) -and ($_.IsCommand -ne $true) -and (-not [string]::IsNullOrEmpty($_.DueDate)) -and ([datetime]::Parse($_.DueDate).Date -eq $today) }

   

    if ($overdueTasks.Count -gt 0) {

        Write-Host "`n  OVERDUE TASKS ($($overdueTasks.Count)):" -ForegroundColor (Get-ThemeProperty "Palette.ErrorFG")

        foreach ($task in $overdueTasks | Sort-Object @{Expression={if([string]::IsNullOrEmpty($_.DueDate)) {[DateTime]::MaxValue} else {[DateTime]::Parse($_.DueDate)}}}, Priority | Select-Object -First 5) {

            Show-TaskItemCompact $task

        }

        if ($overdueTasks.Count -gt 5) { Write-Host "   ... and $($overdueTasks.Count - 5) more" -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG") }

    }

   

    if ($dueTodayTasks.Count -gt 0) {

        Write-Host "`n TASKS DUE TODAY ($($dueTodayTasks.Count)):" -ForegroundColor (Get-ThemeProperty "Palette.WarningFG")

        foreach ($task in $dueTodayTasks | Sort-Object Priority) { Show-TaskItemCompact $task }

    } elseif ($overdueTasks.Count -eq 0) {

        Write-Host "`n No tasks overdue or due today!" -ForegroundColor (Get-ThemeProperty "Palette.SuccessFG")

    }

   

    $inProgressTasks = $script:Data.Tasks | Where-Object { (-not $_.Completed) -and ($_.IsCommand -ne $true) -and ($_.Progress -gt 0) -and ($_.Progress -lt 100) }

    if ($inProgressTasks.Count -gt 0) {

        Write-Host "`n IN PROGRESS TASKS ($($inProgressTasks.Count)):" -ForegroundColor (Get-ThemeProperty "Palette.InfoFG")

        foreach ($task in $inProgressTasks | Sort-Object -Descending Progress | Select-Object -First 3) {

            Show-TaskItemCompact $task

            Draw-ProgressBar -Percent $task.Progress; Write-Host ""

        }

    }

   

    $recentCommands = Get-RecentCommandSnippets -Count 3

    if ($recentCommands.Count -gt 0) {

        Write-Host "`n RECENT COMMAND SNIPPETS:" -ForegroundColor (Get-ThemeProperty "Palette.AccentFG")

        foreach ($cmd in $recentCommands) {

            Write-Host "   [$($cmd.Id.Substring(0,6))] $($cmd.Description)" -ForegroundColor (Get-ThemeProperty "Palette.PrimaryFG")

            if ($cmd.Hotkey) { Write-Host "         Hotkey: $($cmd.Hotkey)" -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG") }

        }

    }

    # No automatic pause here, main menu loop will handle it or user presses a key for next action

}

 

function global:Show-TaskItemCompact {

    param($Task)

   

    $priorityInfo = Get-PriorityInfo $Task.Priority

    Write-Host "   $(Apply-PSStyle -Text $priorityInfo.Icon -FG $priorityInfo.Color) " -NoNewline

   

    $taskText = "[$($Task.Id.Substring(0,6))] $($Task.Description)"

    if ($Task.Completed) {

        Write-Host (Apply-PSStyle -Text $taskText -FG (Get-ThemeProperty "Palette.SubtleFG"))

    } else {

        $status = Get-TaskStatus $Task

        $color = switch ($status) {

            "Overdue" { Get-ThemeProperty "Palette.ErrorFG" }

            "Due Today" { Get-ThemeProperty "Palette.WarningFG" }

            "Due Soon" { Get-ThemeProperty "Palette.InfoFG" }

            "In Progress" { Get-ThemeProperty "Palette.InfoFG" }

            default { Get-ThemeProperty "Palette.PrimaryFG" }

        }

        Write-Host (Apply-PSStyle -Text $taskText -FG $color)

    }

   

    if ($Task.ProjectKey) {

        $project = Get-ProjectOrTemplate $Task.ProjectKey

        if ($project) { Write-Host "      Project: $($project.Name)" -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG") }

    }

}

 

function global:Change-ReportWeek {

    Write-Host "Current report week starts: $($script:Data.CurrentWeek.ToString('yyyy-MM-dd'))"

    Write-Host "[P]revious Week, [N]ext Week, [T]his Week, or enter a date (YYYY-MM-DD) for the week to view: " -NoNewline

    $navChoice = Read-Host

   

    $newWeekStart = $script:Data.CurrentWeek # Default to current if input is invalid

    switch ($navChoice.ToUpper()) {

        'P' { $newWeekStart = $script:Data.CurrentWeek.AddDays(-7) }

        'N' { $newWeekStart = $script:Data.CurrentWeek.AddDays(7) }

        'T' { $newWeekStart = Get-WeekStart (Get-Date) }

        default {

            try {

                $inputDate = [DateTime]::Parse($navChoice)

                $newWeekStart = Get-WeekStart $inputDate

            } catch { Write-Error "Invalid date format '$navChoice'. Report week not changed." ; return }

        }

    }

    $script:Data.CurrentWeek = $newWeekStart

    Save-UnifiedData

    Write-Success "Report week changed to start: $($script:Data.CurrentWeek.ToString('yyyy-MM-dd'))"

}

 

function global:Show-CurrentSettings { # Display a summary of current settings

    Write-Header "Current Application Settings Summary"

    $s = $script:Data.Settings # Alias

    Write-Host "Time Tracking:" -ForegroundColor Yellow

    Write-Host "  Default Rate: $($s.DefaultRate)/$($s.Currency), Target: $($s.HoursPerDay)h/day, $($s.DaysPerWeek) days/week"

    Write-Host "Task Management:" -ForegroundColor Yellow

    Write-Host "  Default Priority: $($s.DefaultPriority), Default Category: $($s.DefaultCategory)"

    Write-Host "  Show Completed (Active Views): Last $($s.ShowCompletedDays) days, Auto-Archive After: $($s.AutoArchiveDays) days"

    Write-Host "Command Snippets:" -ForegroundColor Yellow

    Write-Host "  Hotkeys: $(if($s.CommandSnippets.EnableHotkeys){'Enabled (external binding)'}else{'Disabled'}), Auto-Copy: $(if($s.CommandSnippets.AutoCopyToClipboard){'Yes'}else{'No'})"

    Write-Host "  Show in Task List: $(if($s.CommandSnippets.ShowInTaskList){'Yes'}else{'No'}), Default Category: $($s.CommandSnippets.DefaultCategory)"

    Write-Host "Theme:" -ForegroundColor Yellow

    Write-Host "  Current Legacy Theme Colors (used by Write-Host -FG):"

    foreach($colorKey in $s.Theme.Keys){ Write-Host "    $colorKey = $($s.Theme[$colorKey])"}

    if($script:CurrentTheme -and $script:CurrentTheme.Name -ne "Legacy"){

         Write-Host "  Modern Theme Active: $($script:CurrentTheme.Name) (uses PSStyle/Hex)"

    }

    Write-Host "" # Newline for readability before menu

}

 

function global:Start-UnifiedProductivitySuite {

    Write-Host ("-"*30) + " Unified Productivity Suite v5.0 " + ("-"*30) -ForegroundColor Cyan

    Write-Host "Initializing..." -ForegroundColor Gray

   

    # Ensure Settings exists and has required properties

if (-not $script:Data) {

    $script:Data = @{

        Projects = @{}     

        Tasks = @()        

        TimeEntries = @()  

        ActiveTimers = @{} 

        ArchivedTasks = @()

        ExcelCopyJobs = @{}

        CurrentWeek = if (Get-Command Get-WeekStart -ErrorAction SilentlyContinue) { Get-WeekStart (Get-Date) } else { (Get-Date) }

        Settings = Get-DefaultSettings

    }

}

 

   

    # PowerShell 5.1 compatibility - use ContainsKey() instead of HasKey()

    if (-not $script:Data.Settings.QuickActionTipShown) {

        Write-Host "`nTIP: Use '+' followed by a keyword (e.g., +time, +task, +help) from any prompt for quick actions!" -ForegroundColor Yellow

        Write-Host "     Try '+?' to see all available quick actions." -ForegroundColor Gray

        $script:Data.Settings.QuickActionTipShown = $true

        Save-UnifiedData

        Start-Sleep -Seconds 3

    }

   

    Show-MainMenu

}

 

 

#endregion

 

# Entry point

Start-UnifiedProductivitySuite

 

 

 

##########################################################################################################################################################################################################################################################################################################################################################################################################################################

# Simple Theme System - Console Colors Only

 

function global:Initialize-ThemeSystem {

    # Do nothing - using simple console colors only

}

 

function global:Get-ThemeProperty {

    param([string]$Path)

   

    # Return simple console colors only

    switch ($Path) {

        "Palette.HeaderFG" { return "Cyan" }

        "Palette.SuccessFG" { return "Green" }

        "Palette.ErrorFG" { return "Red" }

        "Palette.WarningFG" { return "Yellow" }

        "Palette.InfoFG" { return "Blue" }

        "Palette.AccentFG" { return "Magenta" }

        "Palette.SubtleFG" { return "DarkGray" }

        "Palette.PrimaryFG" { return "White" }

        "Palette.SecondaryFG" { return "Gray" }

        "DataTable.Header.FG" { return "Cyan" }

        "DataTable.DataRow.FG" { return "White" }

        "DataTable.AltRow.FG" { return "Gray" }

        "DataTable.DataRow.BG" { return $null }

        "DataTable.AltRow.BG" { return $null }

        default { return "White" }

    }

}

 

function global:Get-BorderStyleChars {

    param([string]$Style = "Single")

   

    $borderStyles = @{

        Single = @{

            TopLeft = ""; TopRight = ""; BottomLeft = ""; BottomRight = ""

            Horizontal = ""; Vertical = ""; Cross = ""; TLeft = ""; TRight = ""

            TTop = ""; TBottom = ""

        }

        Double = @{

            TopLeft = ""; TopRight = ""; BottomLeft = ""; BottomRight = ""

            Horizontal = ""; Vertical = ""; Cross = ""; TLeft = ""; TRight = ""

            TTop = ""; TBottom = ""

        }

    }

   

    if ($borderStyles.ContainsKey($Style)) {

        return $borderStyles[$Style]

    }

    return $borderStyles.Single

}

 

function global:Apply-PSStyle {

    param(

        [string]$Text,

        [string]$FG,

        [string]$BG,

        [switch]$Bold,

        [switch]$Italic,

        [switch]$Underline

    )

   

    # Just return plain text - no styling

    return $Text

}

 

function global:Write-Header {

    param([string]$Text)

   

    if ($script:Data -and $script:Data.Settings -and $script:Data.Settings.Theme -and $script:Data.Settings.Theme.Header) {

        Write-Host "`n$Text" -ForegroundColor $script:Data.Settings.Theme.Header

    } else {

        Write-Host "`n$Text" -ForegroundColor Cyan

    }

    Write-Host ("=" * $Text.Length) -ForegroundColor DarkCyan

}

 

function global:Write-Success {

    param([string]$Text)

   

    if ($script:Data -and $script:Data.Settings -and $script:Data.Settings.Theme -and $script:Data.Settings.Theme.Success) {

        Write-Host " $Text" -ForegroundColor $script:Data.Settings.Theme.Success

    } else {

        Write-Host " $Text" -ForegroundColor Green

    }

}

 

function global:Write-Warning {

    param([string]$Text)

   

    if ($script:Data -and $script:Data.Settings -and $script:Data.Settings.Theme -and $script:Data.Settings.Theme.Warning) {

        Write-Host " $Text" -ForegroundColor $script:Data.Settings.Theme.Warning

    } else {

        Write-Host " $Text" -ForegroundColor Yellow

    }

}

 

function global:Write-Error {

    param([string]$Text)

   

    if ($script:Data -and $script:Data.Settings -and $script:Data.Settings.Theme -and $script:Data.Settings.Theme.Error) {

        Write-Host " $Text" -ForegroundColor $script:Data.Settings.Theme.Error

    } else {

        Write-Host " $Text" -ForegroundColor Red

    }

}

 

function global:Write-Info {

    param([string]$Text)

   

    if ($script:Data -and $script:Data.Settings -and $script:Data.Settings.Theme -and $script:Data.Settings.Theme.Info) {

        Write-Host " $Text" -ForegroundColor $script:Data.Settings.Theme.Info

    } else {

        Write-Host " $Text" -ForegroundColor Blue

    }

}

 

function global:Edit-ThemeSettings {

    Write-Header "Theme Settings"

   

    if (-not $script:Data.Settings.Theme) {

        $script:Data.Settings.Theme = @{

            Header = "Cyan"; Success = "Green"; Warning = "Yellow"

            Error = "Red"; Info = "Blue"; Accent = "Magenta"; Subtle = "DarkGray"

        }

    }

 

    Write-Host "Current theme colors:" -ForegroundColor Yellow

    Write-Host "Available colors: Black, DarkBlue, DarkGreen, DarkCyan, DarkRed, DarkMagenta, DarkYellow, Gray, DarkGray, Blue, Green, Cyan, Red, Magenta, Yellow, White"

   

    Save-UnifiedData

    Write-Success "Theme settings updated!"

}

 

 

##########################################################################################################################################################################################################################################################################################################################################################################################################################################

# UI Components Module

# Tables, menus, borders, and display functions

 

#region Table Formatting

function global:Format-TableUnicode {

    param(

        [Parameter(ValueFromPipeline)]

        [object[]]$InputData,

       

        [hashtable[]]$Columns,

       

        [string]$BorderStyle = "Single",

        [string]$Title = "",

        [switch]$NoHeader,

        [switch]$Wrap,

        [int]$MaxWidth = 0,

        [hashtable]$RowHighlightRules = @{},

        [scriptblock]$RowColorCondition

    )

   

    begin {

        $allData = @()

        $border = Get-BorderStyleChars -Style $BorderStyle

        if (-not $border) {

            $border = @{

                TopLeft = "+"; TopRight = "+"; BottomLeft = "+"; BottomRight = "+"

                Horizontal = "-"; Vertical = "|"; Cross = "+"; TLeft = "+"; TRight = "+"

                TTop = "+"; TBottom = "+"

            }

        }

        if ($MaxWidth -eq 0) {

            try { $MaxWidth = $Host.UI.RawUI.WindowSize.Width - 2 }

            catch { $MaxWidth = 80 }

        }

    }

   

    process {

        if ($InputData) {

            $allData += $InputData

        }

    }

   

    end {

        if ($allData.Count -eq 0) {

            Write-Host "No data to display." -ForegroundColor Gray

            return

        }

       

        if (-not $Columns) {

            $props = @()

            if ($allData[0].PSObject -and $allData[0].PSObject.Properties) {

                $props = $allData[0].PSObject.Properties | Where-Object { $_.MemberType -eq 'NoteProperty' }

            }

            $Columns = $props | ForEach-Object {

                @{ Name = $_.Name; Title = $_.Name; Width = 0 }

            }

        }

       

        if (-not $Columns -or $Columns.Count -eq 0) {

            Write-Host "No columns to display." -ForegroundColor Gray

            return

        }

       

        # Calculate initial column widths based on content

        foreach ($col in $Columns) {

            if ($null -eq $col.Width -or $col.Width -eq 0) {

                $maxLen = if ($col.Title) { $col.Title.Length } else { if ($col.Name) { $col.Name.Length } else { 5 } }

                foreach ($item in $allData) {

                    $value = Get-PropertyValue $item $col.Name

                    $len = if ($value) { $value.ToString().Length } else { 0 }

                    if ($len -gt $maxLen) { $maxLen = $len }

                }

                $col.Width = [Math]::Min($maxLen + 2, ($MaxWidth / 2))

                if ($col.Title -and $col.Width -lt ($col.Title.Length + 2)) {$col.Width = $col.Title.Length + 2}

                if ($col.Width -lt 5) { $col.Width = 5 }

            }

        }

       

        # Adjust column widths if total exceeds MaxWidth

        $totalCurrentWidth = ($Columns | Measure-Object -Property Width -Sum).Sum + ($Columns.Count + 1)

        if ($totalCurrentWidth -gt $MaxWidth) {

            $reductionFactor = ($MaxWidth - ($Columns.Count + 1)) / ($Columns | Measure-Object -Property Width -Sum).Sum

            if($reductionFactor -lt 1 -and $reductionFactor -gt 0){

                foreach ($col in $Columns) {

                    $newWidth = [Math]::Max(5, [int]($col.Width * $reductionFactor))

                    $col.Width = $newWidth

                }

            }

            $totalCurrentWidth = ($Columns | Measure-Object -Property Width -Sum).Sum + ($Columns.Count + 1)

        }

       

        # Draw top border

        Write-Host $border.TopLeft -NoNewline

        for ($i = 0; $i -lt $Columns.Count; $i++) {

            Write-Host ($border.Horizontal * $Columns[$i].Width) -NoNewline

            if ($i -lt $Columns.Count - 1) { Write-Host $border.TTop -NoNewline }

        }

        Write-Host $border.TopRight

       

        # Draw title if provided

        if ($Title) {

            $titleAreaWidth = $totalCurrentWidth - 2

            Write-Host $border.Vertical -NoNewline

            $titlePadded = " $Title ".PadRight($titleAreaWidth)

            if ($titlePadded.Length -gt $titleAreaWidth) {

                $titlePadded = $titlePadded.Substring(0, [Math]::Max(0, $titleAreaWidth -1)) + ""

            }

            Write-Host $titlePadded -NoNewline -ForegroundColor Cyan

            Write-Host $border.Vertical

           

            Write-Host $border.TLeft -NoNewline

            for ($i = 0; $i -lt $Columns.Count; $i++) {

                Write-Host ($border.Horizontal * $Columns[$i].Width) -NoNewline

                if ($i -lt $Columns.Count - 1) { Write-Host $border.Cross -NoNewline }

            }

            Write-Host $border.TRight

        }

       

        # Draw header

        if (-not $NoHeader) {

            Write-Host $border.Vertical -NoNewline

            foreach ($col in $Columns) {

                $alignHeader = if ($col.AlignHeader) { $col.AlignHeader } else { "Center" }

                $headerText = Format-TableCell -Text $col.Title -Width $col.Width -Align $alignHeader

                Write-Host $headerText -NoNewline -ForegroundColor Cyan

                Write-Host $border.Vertical -NoNewline

            }

            Write-Host

           

            Write-Host $border.TLeft -NoNewline

            for ($i = 0; $i -lt $Columns.Count; $i++) {

                Write-Host ($border.Horizontal * $Columns[$i].Width) -NoNewline

                if ($i -lt $Columns.Count - 1) { Write-Host $border.Cross -NoNewline }

            }

            Write-Host $border.TRight

        }

       

        # Draw data rows

        $rowIndex = 0

        foreach ($item in $allData) {

            Write-Host $border.Vertical -NoNewline

           

            $rowColor = "White"

            if ($RowColorCondition -and (& $RowColorCondition $item)) {

                 $colorResult = & $RowColorCondition $item

                 if($colorResult -is [hashtable] -and $colorResult.FG){

                     $rowColor = if ($colorResult.FG -match '^(Black|DarkBlue|DarkGreen|DarkCyan|DarkRed|DarkMagenta|DarkYellow|Gray|DarkGray|Blue|Green|Cyan|Red|Magenta|Yellow|White)$') { $colorResult.FG } else { "White" }

                 }

                 elseif($colorResult -is [string] -and $colorResult -match '^(Black|DarkBlue|DarkGreen|DarkCyan|DarkRed|DarkMagenta|DarkYellow|Gray|DarkGray|Blue|Green|Cyan|Red|Magenta|Yellow|White)$') {

                     $rowColor = $colorResult

                 }

            } elseif ($rowIndex % 2 -eq 1 -and (-not $RowHighlightRules -or $RowHighlightRules.Count -eq 0)) {

                $rowColor = "Gray"

            }

 

            if ($RowHighlightRules) {

                foreach($ruleName in $RowHighlightRules.Keys){

                    $rule = $RowHighlightRules[$ruleName]

                    if($item | Where-Object $rule.Condition){

                        if ($rule.FG -and $rule.FG -match '^(Black|DarkBlue|DarkGreen|DarkCyan|DarkRed|DarkMagenta|DarkYellow|Gray|DarkGray|Blue|Green|Cyan|Red|Magenta|Yellow|White)$') {

                            $rowColor = $rule.FG

                        }

                        break

                    }

                }

            }

           

            foreach ($col in $Columns) {

                $value = Get-PropertyValue $item $col.Name

                $alignData = if ($col.AlignData) { $col.AlignData } else { "Left" }

                $cellText = Format-TableCell -Text $value -Width $col.Width -Align $alignData -Wrap:$Wrap

               

                Write-Host $cellText -NoNewline -ForegroundColor $rowColor

                Write-Host $border.Vertical -NoNewline

            }

            Write-Host

            $rowIndex++

        }

       

        # Draw bottom border

        Write-Host $border.BottomLeft -NoNewline

        for ($i = 0; $i -lt $Columns.Count; $i++) {

            Write-Host ($border.Horizontal * $Columns[$i].Width) -NoNewline

            if ($i -lt $Columns.Count - 1) { Write-Host $border.TBottom -NoNewline }

        }

        Write-Host $border.BottomRight

    }

}

 

 

function global:Format-TableCell {

    param(

        [string]$Text,

        [int]$Width,

        [string]$Align = "Left",

        [switch]$Wrap # If true, text wrapping would be handled here (more complex)

    )

   

    $Text = if ($null -eq $Text) { "" } else { $Text.ToString() }

 

    if ($Width -lt 1) { $Width = 1 } # Ensure minimum width

 

    # Simple truncation for now, no wrapping implemented in this version

    if ($Text.Length -gt $Width) {

        if ($Width -ge 1) { # Allow for ellipsis if space

            $Text = $Text.Substring(0, [Math]::Max(0, $Width - 1)) + ""

        } else {

            $Text = $Text.Substring(0, [Math]::Max(0, $Width))

        }

    }

   

    # Pad with spaces. For tables, usually 1 space padding on each side is visually included in cell width.

    # This function should return the content to fit *within* the given width.

    # The calling function (Format-TableUnicode) adds border chars.

    # Let's assume $Width is the total characters for the content, including internal padding.

   

    $contentWidth = $Width - 2 # Available space for text after 1-char padding on each side

    if ($contentWidth -lt 0) {$contentWidth = 0}

 

    if ($Text.Length -gt $contentWidth) {

        if ($contentWidth -ge 1) { $Text = $Text.Substring(0, [Math]::Max(0, $contentWidth -1)) + "" }

        else {$Text = ""} # Not enough space for even one char + ellipsis

    }

 

    $paddedText = switch ($Align.ToLower()) {

        "center" { $Text.PadLeft([int](($contentWidth + $Text.Length) / 2)).PadRight($contentWidth) }

        "right"  { $Text.PadLeft($contentWidth) }

        default  { $Text.PadRight($contentWidth) }

    }

    return " $paddedText " # Add the 1-char padding

}

 

function global:Get-PropertyValue {

    param($Object, $PropertyName)

   

    if ($null -eq $Object) { return "" }

    if ([string]::IsNullOrEmpty($PropertyName)) { return "" }

 

    if ($PropertyName -contains ".") {

        $parts = $PropertyName -split '\.'

        $current = $Object

        foreach ($part in $parts) {

            try {

                # Check if $current is a PSObject and has the property, or if it's a hashtable

                if ($current -is [psobject] -and $current.PSObject.Properties[$part]) {

                    $current = $current.$part

                } elseif ($current -is [hashtable] -and $current.ContainsKey($part)) {

                    $current = $current[$part]

                } else {

                    return "" # Property path not found

                }

                if ($null -eq $current) { return "" }

            } catch { return "" }

        }

        return if ($null -eq $current) { "" } else { $current.ToString() }

    }

   

    try {

        $value = $Object.$PropertyName # Works for PSObjects

        if ($null -eq $value -and $Object -is [hashtable] -and $Object.ContainsKey($PropertyName)) {

            $value = $Object[$PropertyName] # Works for Hashtables

        }

        if ($null -eq $value) { return "" }

        return $value.ToString()

    } catch { return "" }

}

 

#endregion

 

#region Dashboard Display

 

function global:Show-Dashboard {

#    Clear-Host

   

    $headerColor = Get-ThemeProperty "Palette.AccentFG"

    Write-Host @"



          UNIFIED PRODUCTIVITY SUITE v5.0                  

               All-in-One Command Center                   



"@ -ForegroundColor $headerColor

 

    $activeTimers = if ($script:Data.ActiveTimers) { $script:Data.ActiveTimers.Count } else { 0 }

    $activeTasks = ($script:Data.Tasks | Where-Object { (-not $_.Completed) -and ($_.IsCommand -ne $true) }).Count

    $todayHours = 0.0

    if ($script:Data.TimeEntries) {

        $todayHours = ($script:Data.TimeEntries | Where-Object { $_.Date -eq (Get-Date).ToString("yyyy-MM-dd") } | Measure-Object -Property Hours -Sum).Sum

        $todayHours = if ($todayHours) { [Math]::Round($todayHours, 2) } else { 0.0 }

    }

   

    Write-Host "`n CURRENT STATUS" -ForegroundColor (Get-ThemeProperty "Palette.WarningFG")

    Write-Host ("" * 47) -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG")

    

    Write-Host "   Today: " -NoNewline; Write-Host (Get-Date).ToString("dddd, MMMM dd, yyyy") -ForegroundColor (Get-ThemeProperty "Palette.PrimaryFG")

    Write-Host "    Today's Hours: " -NoNewline

    if ($todayHours -gt 0) { Write-Host "$todayHours" -ForegroundColor (Get-ThemeProperty "Palette.SuccessFG") }

    else { Write-Host "None logged" -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG") }

   

    Write-Host "   Active Timers: " -NoNewline

    if ($activeTimers -gt 0) {

        Write-Host "$activeTimers running" -ForegroundColor (Get-ThemeProperty "Palette.ErrorFG")

        foreach ($timer in $script:Data.ActiveTimers.GetEnumerator() | Select-Object -First 2) {

            $elapsed = (Get-Date) - [DateTime]$timer.Value.StartTime

            $project = Get-ProjectOrTemplate $timer.Value.ProjectKey

            $projectName = if($project){$project.Name}else{"Unknown"}

            Write-Host "      $projectName $([Math]::Floor($elapsed.TotalHours)):$($elapsed.ToString('mm\:ss'))" -ForegroundColor (Get-ThemeProperty "Palette.InfoFG")

        }

        if ($script:Data.ActiveTimers.Count -gt 2) { Write-Host "      ... and $($script:Data.ActiveTimers.Count - 2) more" -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG") }

    } else { Write-Host "None" -ForegroundColor (Get-ThemeProperty "Palette.SuccessFG") }

   

    Write-Host "   Active Tasks: " -NoNewline

    if ($activeTasks -gt 0) {

        Write-Host "$activeTasks" -ForegroundColor (Get-ThemeProperty "Palette.WarningFG")

        $overdue = $script:Data.Tasks | Where-Object { (-not [string]::IsNullOrEmpty($_.DueDate)) -and ([datetime]::Parse($_.DueDate).Date -lt [datetime]::Today.Date) -and (-not $_.Completed) -and ($_.IsCommand -ne $true) }

        $dueToday = $script:Data.Tasks | Where-Object { (-not [string]::IsNullOrEmpty($_.DueDate)) -and ([datetime]::Parse($_.DueDate).Date -eq [datetime]::Today.Date) -and (-not $_.Completed) -and ($_.IsCommand -ne $true) }

        if ($overdue.Count -gt 0) { Write-Host "       $($overdue.Count) overdue!" -ForegroundColor (Get-ThemeProperty "Palette.ErrorFG") }

        if ($dueToday.Count -gt 0) { Write-Host "      $($dueToday.Count) due today" -ForegroundColor (Get-ThemeProperty "Palette.WarningFG") }

    } else { Write-Host "None - inbox zero! " -ForegroundColor (Get-ThemeProperty "Palette.SuccessFG") }

   

    $activeProjectsCount = if ($script:Data.Projects) { ($script:Data.Projects.Values | Where-Object { $_.Status -eq "Active" }).Count } else { 0 }

    Write-Host "   Active Projects: " -NoNewline; Write-Host $activeProjectsCount -ForegroundColor (Get-ThemeProperty "Palette.InfoFG")

    

    $commandCount = ($script:Data.Tasks | Where-Object { $_.IsCommand -eq $true }).Count

    if ($commandCount -gt 0) { Write-Host "   Command Snippets: " -NoNewline; Write-Host $commandCount -ForegroundColor (Get-ThemeProperty "Palette.AccentFG") }

   

    Write-Host "`n WEEK SUMMARY" -ForegroundColor (Get-ThemeProperty "Palette.WarningFG")

    Write-Host ("" * 47) -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG")

    

    $weekStart = Get-WeekStart

    $weekHours = 0.0

    if ($script:Data.TimeEntries) {

        $weekEntries = $script:Data.TimeEntries | Where-Object { (-not [string]::IsNullOrEmpty($_.Date)) -and ([DateTime]::Parse($_.Date).Date -ge $weekStart.Date) -and ([DateTime]::Parse($_.Date).Date -lt $weekStart.AddDays(7).Date) }

        $weekHours = ($weekEntries | Measure-Object -Property Hours -Sum).Sum

        $weekHours = if ($weekHours) { [Math]::Round($weekHours, 2) } else { 0.0 }

    }

    $targetWeeklyHours = $script:Data.Settings.HoursPerDay * $script:Data.Settings.DaysPerWeek

    Write-Host "  Week of: $($weekStart.ToString('MMM dd, yyyy'))"

    Write-Host "  Total Hours: $weekHours / $targetWeeklyHours target"

   

    $weekProgress = if ($targetWeeklyHours -gt 0) { [Math]::Min(100, [Math]::Round(($weekHours / $targetWeeklyHours) * 100, 0)) } else { 0 }

    $progressBarWidth = 20 # Define width for progress bar

    $filledBlocks = [Math]::Floor($progressBarWidth * $weekProgress / 100)

    $emptyBlocks = $progressBarWidth - $filledBlocks

    $progressBar = "[" + ("" * $filledBlocks) + ("" * $emptyBlocks) + "]"

    $progressColor = if ($weekProgress -ge 80) { (Get-ThemeProperty "Palette.SuccessFG") }

                     elseif ($weekProgress -ge 50) { (Get-ThemeProperty "Palette.WarningFG") }

                     else { (Get-ThemeProperty "Palette.ErrorFG") }

    Write-Host "  Progress: $(Apply-PSStyle -Text "$progressBar $weekProgress%" -FG $progressColor)"

   

    Write-Host "`n QUICK ACTIONS" -ForegroundColor (Get-ThemeProperty "Palette.WarningFG")

    Write-Host ("" * 47) -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG")

    Write-Host "  [M] Manual Time Entry    [S] Start Timer      [+key] Quick Actions Menu"

    Write-Host "  [A] Add Task            [V] View Active Timers"

    Write-Host "  [T] Today's View        [W] Week Report" # Changed T from Tasks to Today's View

    Write-Host "  [P] Project Details     [H] Help"

   

    Write-Host "`n FULL MENU OPTIONS" -ForegroundColor (Get-ThemeProperty "Palette.WarningFG")

    Write-Host ("" * 47) -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG")

    Write-Host "  [1] Time Management     [4] Projects & Clients"

    Write-Host "  [2] Task Management     [5] Tools & Utilities"

    Write-Host "  [3] Reports & Analytics [6] Settings & Config"

    Write-Host "`n  [Q] Quit"

}

 

#endregion

 

#region Calendar Display

 

function global:Show-Calendar {

    param(

        [DateTime]$MonthToDisplay = (Get-Date),

        [DateTime[]]$DatesToHighlight = @() # Not fully used yet

    )

   

    Write-Header "Calendar - $($MonthToDisplay.ToString('MMMM yyyy'))"

    

    $firstDayOfMonth = Get-Date $MonthToDisplay -Day 1

    $lastDayOfMonth = $firstDayOfMonth.AddMonths(1).AddDays(-1)

    $startOffset = [int]$firstDayOfMonth.DayOfWeek

    

    Write-Host "  Sun  Mon  Tue  Wed  Thu  Fri  Sat" -ForegroundColor (Get-ThemeProperty "Palette.InfoFG")

    Write-Host "  " + ("" * 35) -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG")

    

    $tasksByDate = @{}

    if ($script:Data.Tasks) {

        $script:Data.Tasks | Where-Object { (-not [string]::IsNullOrEmpty($_.DueDate)) -and ($_.IsCommand -ne $true) } | ForEach-Object {

            try {

                $taskDueDate = [DateTime]::Parse($_.DueDate).Date

                if ($taskDueDate.Month -eq $MonthToDisplay.Month -and $taskDueDate.Year -eq $MonthToDisplay.Year) {

                    if (-not $tasksByDate.ContainsKey($taskDueDate)) { $tasksByDate[$taskDueDate] = 0 }

                    $tasksByDate[$taskDueDate]++

                }

            } catch { /* Ignore tasks with invalid DueDate */ }

        }

    }

   

    Write-Host -NoNewline (" " * ($startOffset * 5)) # Adjust spacing for start offset

   

    for ($day = 1; $day -le $lastDayOfMonth.Day; $day++) {

        $currentDate = Get-Date -Year $MonthToDisplay.Year -Month $MonthToDisplay.Month -Day $day

        $dayOfWeek = [int]$currentDate.DayOfWeek

       

        $dayStr = $day.ToString().PadLeft(2) # Pad to 2 for consistency

        $displayStr = $dayStr

        $fgColor = Get-ThemeProperty "Palette.PrimaryFG"

        $taskIndicator = " "

 

        if ($tasksByDate.ContainsKey($currentDate.Date)) {

            $taskIndicator = "*" # Indicate tasks exist

            $count = $tasksByDate[$currentDate.Date]

            if ($count -ge 3) { $fgColor = Get-ThemeProperty "Palette.ErrorFG" }

            elseif ($count -ge 1) { $fgColor = Get-ThemeProperty "Palette.WarningFG" }

        }

       

        if ($currentDate.Date -eq [DateTime]::Today.Date) {

            $fgColor = Get-ThemeProperty "Palette.SuccessFG"

            $displayStr = "[$dayStr]" # Highlight today

        } elseif ($dayOfWeek -eq 0 -or $dayOfWeek -eq 6) { # Weekend

            if($fgColor -eq (Get-ThemeProperty "Palette.PrimaryFG")) {$fgColor = Get-ThemeProperty "Palette.SubtleFG"} # Dim if no tasks

        }

       

        Write-Host -NoNewline (Apply-PSStyle -Text $displayStr.PadRight(3) -FG $fgColor)

        Write-Host -NoNewline (Apply-PSStyle -Text $taskIndicator -FG (Get-ThemeProperty "Palette.InfoFG"))

       

        if ($dayOfWeek -eq 6) { # Saturday

            Write-Host

            if ($day -lt $lastDayOfMonth.Day) { Write-Host -NoNewline "  " }

        } else { Write-Host -NoNewline " " }

    }

    Write-Host "`n"

   

    Write-Host "  Legend: $(Apply-PSStyle -Text '[Today]' -FG (Get-ThemeProperty "Palette.SuccessFG")) | $(Apply-PSStyle -Text 'Tasks*' -FG (Get-ThemeProperty "Palette.InfoFG")) | $(Apply-PSStyle -Text 'Busy (Yellow/Red)' -FG (Get-ThemeProperty "Palette.WarningFG"))"

    Write-Host

   

    $navigationChoice = ""

    while($navigationChoice.ToUpper() -ne "B"){

        $navigationChoice = Read-Host "  [P]revious Month | [N]ext Month | [T]oday's Month | [Y]ear View | [B]ack to Menu"

        switch ($navigationChoice.ToUpper()) {

            "P" { Show-Calendar -MonthToDisplay $MonthToDisplay.AddMonths(-1); return } # Recurse and return to break loop

            "N" { Show-Calendar -MonthToDisplay $MonthToDisplay.AddMonths(1); return }

            "T" { Show-Calendar -MonthToDisplay (Get-Date); return }

            "Y" { Show-YearCalendar -Year $MonthToDisplay.Year; return } # ShowYearCalendar will handle its own loop or return

            "B" { return } # Exit this calendar view

            default { Write-Warning "Invalid choice."}

        }

    }

}

 

function global:Show-YearCalendar {

    param([int]$YearToDisplay = (Get-Date).Year)

   

    Write-Header "Year Calendar - $YearToDisplay"

    

    for ($row = 0; $row -lt 4; $row++) { # 4 rows of 3 months

        $monthsInRow = @()

        for ($col = 0; $col -lt 3; $col++) {

            $monthNum = $row * 3 + $col + 1

            if ($monthNum -le 12) { $monthsInRow += Get-Date -Year $YearToDisplay -Month $monthNum -Day 1 }

        }

       

        Write-Host # Blank line before month names

        foreach ($monthDate in $monthsInRow) {

            Write-Host ("  " + $monthDate.ToString("MMMM").PadRight(22)) -NoNewline -ForegroundColor (Get-ThemeProperty "Palette.InfoFG")

        }

        Write-Host

       

        foreach ($monthDate in $monthsInRow) {

            Write-Host "  Su Mo Tu We Th Fr Sa  " -NoNewline -ForegroundColor (Get-ThemeProperty "Palette.AccentFG")

        }

        Write-Host

       

        $maxWeeks = 6

        $dayBuffers = @{} # Store lines for each month in the row

        foreach($m in $monthsInRow){ $dayBuffers[$m.Month] = @("","","","","","") }

 

        foreach ($monthDate in $monthsInRow) {

            $firstDay = Get-Date $monthDate -Day 1

            $lastDay = $firstDay.AddMonths(1).AddDays(-1)

            $startOffset = [int]$firstDay.DayOfWeek

            

            $currentDay = 1

            for($weekIndex = 0; $weekIndex -lt $maxWeeks; $weekIndex++){

                $line = "  "

                for($dayOfWeekIndex = 0; $dayOfWeekIndex -lt 7; $dayOfWeekIndex++){

                    if(($weekIndex -eq 0 -and $dayOfWeekIndex -lt $startOffset) -or $currentDay -gt $lastDay.Day){

                        $line += "   " # Empty space

                    } else {

                        $dateForCell = Get-Date -Year $YearToDisplay -Month $monthDate.Month -Day $currentDay

                        $displayDay = $currentDay.ToString().PadLeft(2)

                        if($dateForCell.Date -eq [datetime]::Today.Date){

                            $line += Apply-PSStyle -Text $displayDay -FG (Get-ThemeProperty "Palette.SuccessFG") + " "

                        } else {

                            $line += "$displayDay "

                        }

                        $currentDay++

                    }

                }

                $dayBuffers[$monthDate.Month][$weekIndex] = $line.TrimEnd()

            }

        }

        # Print the weeks for the row of months

        for($weekNum = 0; $weekNum -lt $maxWeeks; $weekNum++){

            $fullLine = ""

            foreach($mDate in $monthsInRow){

                $fullLine += ($dayBuffers[$mDate.Month][$weekNum]).PadRight(24) # 24 = 3*7 + 3 spaces

            }

            Write-Host $fullLine

        }

    }

   

    $navigationChoice = Read-Host "`n[P]revious Year | [N]ext Year | [C]hange Year | [B]ack to Monthly Calendar"

    switch($navigationChoice.ToUpper()){

        "P" { Show-YearCalendar -YearToDisplay ($YearToDisplay - 1) }

        "N" { Show-YearCalendar -YearToDisplay ($YearToDisplay + 1) }

        "C" { $newYear = Read-Host "Enter year"; if($newYear -match "^\d{4}$"){ Show-YearCalendar -YearToDisplay ([int]$newYear)} else {Write-Warning "Invalid year."}}

        "B" { return } # Returns to the monthly calendar which called it, or main if called directly

    }

}

 

#endregion

 

#region Progress Bar

 

function global:Draw-ProgressBar {

    param(

        [int]$Percent,

        [int]$Width = 20,

        [string]$FillChar = "", # Or use themed block characters

        [string]$EmptyChar = "",

        [string]$ForegroundColorName = "Green",

        [string]$BackgroundColorName = "DarkGray"

    )

    if($Percent -lt 0) {$Percent = 0} elseif($Percent -gt 100) {$Percent = 100}

    if($Width -lt 5) {$Width = 5}

 

    $filledBlocks = [Math]::Floor($Width * ($Percent / 100))

    $emptyBlocks = $Width - $filledBlocks

   

    Write-Host "[" -NoNewline

    Write-Host ($FillChar * $filledBlocks) -NoNewline -ForegroundColor $ForegroundColorName

    Write-Host ($EmptyChar * $emptyBlocks) -NoNewline -ForegroundColor $BackgroundColorName

    Write-Host "] $($Percent.ToString().PadLeft(3))%" -NoNewline # Pad percent for consistent width

}

 

#endregion

 

#region Menu Display

 

function global:Show-MenuSelection {

    param(

        [string]$Title,

        [string[]]$Options,

        [string]$PromptMessage = "Select option",

        [switch]$AllowMultiple,

        [switch]$ReturnIndex

    )

   

    Write-Header $Title

    

    if (-not $Options -or $Options.Count -eq 0) {

        Write-Warning "No options available for selection."

        return if ($AllowMultiple) { @() } else { $null }

    }

 

    for ($i = 0; $i -lt $Options.Count; $i++) { Write-Host "[$($i + 1)] $($Options[$i])" }

   

    if ($AllowMultiple) {

        Write-Host "`nEnter numbers separated by commas (e.g., 1,3,5), 'all', or 'none'."

    } else { Write-Host "`n[0] Cancel selection" }

   

    $selectionInput = Read-Host "`n$PromptMessage"

   

    if ($AllowMultiple) {

        if ($selectionInput.ToLower() -eq 'all') {

            return if ($ReturnIndex) { 0..($Options.Count - 1) } else { $Options }

        } elseif ($selectionInput.ToLower() -eq 'none' -or [string]::IsNullOrWhiteSpace($selectionInput)) {

            return @()

        }

       

        $selectedIndices = $selectionInput -split ',' | ForEach-Object {

            $numStr = $_.Trim()

            if ($numStr -match '^\d+$') {

                $idx = [int]$numStr - 1

                if ($idx -ge 0 -and $idx -lt $Options.Count) {

                    if ($ReturnIndex) { $idx } else { $Options[$idx] }

                } else { Write-Warning "Invalid option number ignored: $numStr" }

            } else { Write-Warning "Invalid input ignored: $numStr" }

        }

        return $selectedIndices | Where-Object {$_ -ne $null}

    } else { # Single selection

        if ($selectionInput -eq '0' -or [string]::IsNullOrWhiteSpace($selectionInput)) { return $null } # Cancelled

       

        if ($selectionInput -match '^\d+$') {

            $idx = [int]$selectionInput - 1

            if ($idx -ge 0 -and $idx -lt $Options.Count) {

                return if ($ReturnIndex) { $idx } else { $Options[$idx] }

            }

        }

        Write-Warning "Invalid selection '$selectionInput'."

        return $null

    }

}

 

#endregion

 

#region Help Display

 

function global:Show-Help {

    Clear-Host

    Write-Header "Help & Documentation - Unified Productivity Suite v5.0"

    

    Write-Host @"

This integrated suite combines time tracking, task management, project

management, Excel integration, and command snippets into a seamless

productivity system.

 

QUICK ACTIONS (use '+' followed by a keyword from any prompt):

-------------------------------------------------------------

  Time: +time, +timer, +stop

  Task: +task, +qa (quick add)

  Views: +today (overview), +v (active timers), +w (week report), +t (task menu)

  Project: +p (project detail), +projects (project menu)

  Snippets: +c or +cmd (command snippets)

  Other: +h or +help (this screen), +? (quick action list)

 

MAIN MENU NAVIGATION:

---------------------

  Use numbers [1-6] to access main sections from the dashboard.

  Use [M, S, A, V, T, W, P, H] for direct dashboard shortcuts.

  [Q] to Quit.

 

KEY CONCEPTS:

-------------

- Projects & Templates: Organize work. Templates (ADMIN, MEETING) are for recurring non-billable time.

- Tasks: Specific to-do items, can be linked to projects. Use `qa` for fast entry.

  Syntax: `qa Task Description #category @tag1 @tag2 !Priority due:yyyy-mm-dd project:KEY est:Hours`

- Time Entries: Log time manually (preferred for accuracy) or via timers. Can be linked to tasks.

- Command Snippets: Store reusable shell commands or code. Accessed via Tools or `+c`.

- Excel Integration: Import project details from pre-formatted Excel files.

 

DATA & SETTINGS:

----------------

- Data stored in: `$script:DataPath` (usually `\$env:USERPROFILE\.ProductivitySuite`)

- Backups: Automatic, stored in `$script:BackupPath`.

- Settings: Configurable via option [6] in the main menu. Includes theme, defaults, etc.

 

COMMON WORKFLOWS:

-----------------

1. Add a Project: Main Menu -> [4] Projects & Clients -> [1] Add Project

2. Add a Task: Main Menu -> [2] Task Management -> [A]dd Task (or use `+qa` or `qa` shortcuts)

3. Log Time Manually: Main Menu -> [1] Time Management -> [1] Manual Time Entry (or `+time`)

4. Start/Stop Timer: Main Menu -> [1] Time Management -> [2]/[3] (or `+timer`/`+stop`)

5. View Today's Tasks: Dashboard -> [T] Today's View (or `+today`)

6. Generate Week Report: Main Menu -> [3] Reports & Analytics -> [1] Week Report (or `+w`)

7. Add Command Snippet: Main Menu -> [5] Tools & Utilities -> [1] Command Snippets -> [A]dd (or `+c`)

8. Import Project from Excel: Main Menu -> [4] Projects & Clients -> [2] Import from Excel

 

TROUBLESHOOTING:

----------------

- If colors look wrong: Your terminal might not fully support ANSI escape codes or PSStyle.

  The script attempts to use basic ConsoleColor names as a fallback.

- "Function not found": Ensure all .ps1 module files are in the same directory as `main.ps1`.

  The script root is detected automatically; verify it's correct if issues persist.

- Data not saving: Check permissions for the data path (`$script:DataPath`).

- Excel errors: Ensure Microsoft Excel is installed for Excel-related features. Use "Test Excel Connection".

 

For further assistance or to report bugs, please refer to the project documentation (if available).

"@ -ForegroundColor (Get-ThemeProperty "Palette.PrimaryFG")

    

    Write-Host "`nPress any key to return to the previous menu..." -ForegroundColor (Get-ThemeProperty "Palette.SubtleFG")

    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")

}

 

#endregion