# PMC Terminal v3.0 - Main Entry Point
# This file orchestrates module loading and application startup

# Set strict mode for better error handling
Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

# Get the directory where this script is located
$script:BasePath = Split-Path -Parent $MyInvocation.MyCommand.Path

# Module loading order is critical - dependencies must load first
$script:ModulesToLoad = @(
    @{ Name = "logger"; Path = "modules\logger.psm1"; Required = $true },
    @{ Name = "event-system"; Path = "modules\event-system.psm1"; Required = $true },
    @{ Name = "data-manager"; Path = "modules\data-manager.psm1"; Required = $true },
    @{ Name = "theme-manager"; Path = "modules\theme-manager.psm1"; Required = $true },
    @{ Name = "tui-engine-v2"; Path = "modules\tui-engine-v2.psm1"; Required = $true },
    @{ Name = "dialog-system"; Path = "modules\dialog-system.psm1"; Required = $true },
    @{ Name = "tui-components"; Path = "components\tui-components.psm1"; Required = $true },
    @{ Name = "advanced-input-components"; Path = "components\advanced-input-components.psm1"; Required = $false },
    @{ Name = "advanced-data-components"; Path = "components\advanced-data-components.psm1"; Required = $true },
    @{ Name = "layout-manager"; Path = "utilities\layout-manager.psm1"; Required = $false },
    @{ Name = "positioning-helper"; Path = "utilities\positioning-helper.psm1"; Required = $false },
    @{ Name = "focus-manager"; Path = "utilities\focus-manager.psm1"; Required = $false },
    @{ Name = "tui-framework"; Path = "modules\tui-framework.psm1"; Required = $false }
)

# Screen modules will be loaded dynamically
$script:ScreenModules = @(
    "dashboard-screen-grid",
    "time-entry-screen",
    "timer-start-screen",
    "task-screen",
    "project-management-screen",
    "timer-management-screen",
    "reports-screen",
    "settings-screen",
    "debug-log-screen",
    "demo-screen"
)

function Initialize-PMCModules {
    param([bool]$Silent = $false)
    
    # Console size validation
    $minWidth = 80
    $minHeight = 24
    $currentWidth = [Console]::WindowWidth
    $currentHeight = [Console]::WindowHeight
    
    if ($currentWidth -lt $minWidth -or $currentHeight -lt $minHeight) {
        Write-Host "Console window too small!" -ForegroundColor Red
        Write-Host "Current size: ${currentWidth}x${currentHeight}" -ForegroundColor Yellow
        Write-Host "Minimum required: ${minWidth}x${minHeight}" -ForegroundColor Green
        Write-Host ""
        Write-Host "Please resize your console window and try again." -ForegroundColor White
        Write-Host "Press any key to exit..." -ForegroundColor Gray
        $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
        exit 1
    }
    
    if (-not $Silent) {
        Write-Host "Initializing PMC Terminal v3.0..." -ForegroundColor Cyan
    }
    
    $loadedModules = @()
    
    foreach ($module in $script:ModulesToLoad) {
        $modulePath = Join-Path $script:BasePath $module.Path
        
        try {
            if (Test-Path $modulePath) {
                if (-not $Silent) {
                    Write-Host "  Loading $($module.Name)..." -ForegroundColor Gray
                }
                Import-Module $modulePath -Force -Global -ErrorAction Stop
                $loadedModules += $module.Name
            } elseif ($module.Required) {
                throw "Required module not found: $($module.Name) at $modulePath"
            }
        } catch {
            if ($module.Required) {
                throw "Failed to load required module $($module.Name): $_"
            } else {
                if (-not $Silent) {
                    Write-Host "  Optional module $($module.Name) not loaded: $_" -ForegroundColor Yellow
                }
            }
        }
    }
    
    if (-not $Silent) {
        Write-Host "Loaded $($loadedModules.Count) modules successfully" -ForegroundColor Green
    }
    return $loadedModules
}

function Initialize-PMCScreens {
    param([bool]$Silent = $false)
    
    if (-not $Silent) {
        Write-Host "Loading screens..." -ForegroundColor Cyan
    }
    
    $loadedScreens = @()
    
    foreach ($screenName in $script:ScreenModules) {
        $screenPath = Join-Path $script:BasePath "screens\$screenName.psm1"
        
        try {
            if (Test-Path $screenPath) {
                Import-Module $screenPath -Force -Global -ErrorAction SilentlyContinue
                $loadedScreens += $screenName
            } else {
                if (-not $Silent) {
                    Write-Host "  Screen module not found: $screenName" -ForegroundColor Yellow
                }
            }
        } catch {
            if (-not $Silent) {
                Write-Host "  Failed to load screen: $screenName - $_" -ForegroundColor Yellow
            }
        }
    }
    
    if (-not $Silent) {
        Write-Host "Loaded $($loadedScreens.Count) screens" -ForegroundColor Green
    }
    return $loadedScreens
}

function Start-PMCTerminal {
    param([bool]$Silent = $false)
    
    try {
        $loadedModules = Initialize-PMCModules -Silent:$Silent
        
        if (-not $Silent) {
            Write-Host "`nInitializing subsystems..." -ForegroundColor Cyan
        }
        
        # Initialize logger first to capture all subsequent events
        if (Get-Command Initialize-Logger -ErrorAction SilentlyContinue) {
            Initialize-Logger
            Write-Log -Level Info -Message "PMC Terminal startup initiated"
            Write-Log -Level Info -Message "Loaded modules: $($loadedModules -join ', ')"
        }
        
        # Initialize core systems in correct order
        # Event system MUST be first as other systems depend on it
        Initialize-EventSystem
        
        # Theme manager and data manager can initialize after events
        Initialize-ThemeManager
        Initialize-DataManager
        
        # TUI Engine MUST be initialized BEFORE dialog system
        # as dialog system uses TUI functions
        Initialize-TuiEngine
        
        # Dialog system depends on TUI engine
        Initialize-DialogSystem
        
        # Load data after all systems are initialized
        Load-UnifiedData
        
        # Initialize optional framework
        if (Get-Command -Name "Initialize-TuiFramework" -ErrorAction SilentlyContinue) {
            Initialize-TuiFramework
            if (-not $Silent) {
                Write-Host "  TUI Framework initialized" -ForegroundColor Gray
            }
        }
        
        # Initialize focus manager
        if (Get-Command -Name "Initialize-FocusManager" -ErrorAction SilentlyContinue) {
            Initialize-FocusManager
            if (-not $Silent) {
                Write-Host "  Focus Manager initialized" -ForegroundColor Gray
            }
        }
        
        # Load screens
        Initialize-PMCScreens -Silent:$Silent
        
        if (-not $Silent) {
            Write-Host "`nStarting application..." -ForegroundColor Green
        }
        
        # Clear the console completely before starting TUI
        Clear-Host
        
        # Check if demo mode is requested
        if ($args -contains "-demo") {
            if (Get-Command -Name "Get-DemoScreen" -ErrorAction SilentlyContinue) {
                $demoScreen = Get-DemoScreen
                Push-Screen -Screen $demoScreen
            }
        } else {
            # Normal startup
            if (Get-Command -Name "Get-DashboardScreen" -ErrorAction SilentlyContinue) {
                $dashboardScreen = Get-DashboardScreen
                Push-Screen -Screen $dashboardScreen
            } else {
                # Fallback welcome screen
                $welcomeScreen = @{
                    Name = "WelcomeScreen"
                    State = @{}
                    
                    Render = { 
                        Write-BufferBox -X 10 -Y 5 -Width 60 -Height 15 -Title " PMC Terminal v3.0 " -BorderColor "Cyan"
                        Write-BufferString -X 15 -Y 8 -Text "Welcome to PMC Terminal!" -ForegroundColor "White"
                        Write-BufferString -X 15 -Y 10 -Text "Dashboard screen could not be loaded." -ForegroundColor "Gray"
                        Write-BufferString -X 15 -Y 12 -Text "Press Q to quit or D for demo" -ForegroundColor "Yellow"
                    }
                    
                    HandleInput = { 
                        param($self, $Key)
                        switch ($Key.Key) {
                            ([ConsoleKey]::Q) { return "Quit" }
                            ([ConsoleKey]::D) {
                                if (Get-Command -Name "Get-DemoScreen" -ErrorAction SilentlyContinue) {
                                    Push-Screen -Screen (Get-DemoScreen)
                                }
                                return $true
                            }
                        }
                        return $false
                    }
                }
                Push-Screen -Screen $welcomeScreen
            }
        }
        
        # Start the main loop
        Start-TuiLoop
        
    } catch {
        if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
            Write-Log -Level Error -Message "FATAL: Failed to initialize PMC Terminal" -Data $_
        }
        Write-Error "FATAL: Failed to initialize PMC Terminal: $_"
        throw
    } finally {
        if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
            Write-Log -Level Info -Message "PMC Terminal shutting down"
        }
        # Cleanup
        if (Get-Command -Name "Stop-TuiEngine" -ErrorAction SilentlyContinue) {
            if (-not $Silent) {
                Write-Host "`nShutting down..." -ForegroundColor Yellow
            }
            Stop-TuiEngine
        }
        
        if ($Data -and (Get-Command -Name "Save-UnifiedData" -ErrorAction SilentlyContinue)) {
            if (-not $Silent) {
                Write-Host "`nSaving data..." -ForegroundColor Yellow -NoNewline
            }
            Save-UnifiedData
            if (-not $Silent) {
                Write-Host " Done!" -ForegroundColor Green
            }
        }
        
        if (-not $Silent) {
            Write-Host "Goodbye!" -ForegroundColor Green
        }
        
        if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
            Write-Log -Level Info -Message "PMC Terminal shutdown complete"
        }
    }
}

# Parse command line arguments
$script:args = $args
$script:Silent = $args -contains "-silent" -or $args -contains "-s"

try {
    Clear-Host
    Start-PMCTerminal -Silent:$script:Silent
} catch {
    Write-Error "Fatal error: $_"
    Write-Host "`nPress any key to exit..." -ForegroundColor Red
    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
    exit 1
}
# Task Management Screen - COMPLIANT VERSION
# Using programmatic pattern with DataTable component

function global:Get-TaskManagementScreen {
    $screen = @{
        Name = "TaskScreen"
        
        # 1. State: Central data model for the screen
        State = @{
            tasks = @()
            filter = "all"
            sortBy = "priority"
            categories = @("Work", "Personal", "Urgent", "Projects")
            showingForm = $false
            editingTaskId = $null
            showHelp = $false
        }
        
        # 2. Components: Storage for instantiated component objects
        Components = @{}
        
        # Focus management
        FocusedComponentName = 'taskTable'
        
        # Define helper methods directly on the screen
        GetFilteredTasks = {
            param($screen)
            $tasks = $screen.State.tasks
            $filter = $screen.State.filter
            
            # Apply filter
            $filtered = switch ($filter) {
                "active" { $tasks | Where-Object { $_.Status -eq "Active" } }
                "completed" { $tasks | Where-Object { $_.Status -eq "Completed" } }
                default { $tasks }
            }
            
            # Apply sort
            $sorted = switch ($screen.State.sortBy) {
                "priority" { 
                    $filtered | Sort-Object @{
                        Expression = {
                            switch ($_.Priority) {
                                "Critical" { 0 }
                                "High" { 1 }
                                "Medium" { 2 }
                                "Low" { 3 }
                            }
                        }
                    }, Created
                }
                "dueDate" { $filtered | Sort-Object DueDate, Priority }
                "created" { $filtered | Sort-Object Created -Descending }
                default { $filtered }
            }
            
            # Transform for table display
            return @($sorted | ForEach-Object {
                @{
                    Id = $_.Id
                    Status = if ($_.Status -eq "Completed") { "X" } else { " " }
                    Priority = $_.Priority
                    Title = if ($_.Title.Length -gt 30) { $_.Title.Substring(0, 27) + "..." } else { $_.Title }
                    Category = $_.Category
                    DueDate = $_.DueDate
                }
            })
        }
        
        RefreshTaskTable = {
            param($screen)
            $tableData = & $screen.GetFilteredTasks -screen $screen
            $screen.Components.taskTable.Data = $tableData
            # Force process data to refresh the display
            if ($screen.Components.taskTable.ProcessData) {
                & $screen.Components.taskTable.ProcessData -self $screen.Components.taskTable
            }
            Request-TuiRefresh
        }
        
        ShowAddTaskForm = {
            param($screen)
            $screen.State.showingForm = $true
            $screen.State.editingTaskId = $null
            
            # Update form components
            $screen.Components.formTitle.Text = ""
            $screen.Components.formDescription.Text = ""
            $screen.Components.formCategory.Value = "Work"
            $screen.Components.formPriority.Value = "Medium"
            $screen.Components.formDueDate.Value = (Get-Date).AddDays(7)
            
            # Center the form panel
            $formWidth = 60
            $formHeight = 24
            $screen.Components.formPanel.X = [Math]::Floor(($global:TuiState.BufferWidth - $formWidth) / 2)
            $screen.Components.formPanel.Y = 6
            $screen.Components.formPanel.Title = " New Task "
            
            # Show form panel
            $screen.Components.formPanel.Visible = $true
            
            # Enable focus on form components
            $screen.Components.formTitle.IsFocusable = $true
            $screen.Components.formDescription.IsFocusable = $true
            $screen.Components.formCategory.IsFocusable = $true
            $screen.Components.formPriority.IsFocusable = $true
            $screen.Components.formDueDate.IsFocusable = $true
            $screen.Components.formSaveButton.IsFocusable = $true
            $screen.Components.formCancelButton.IsFocusable = $true
            
            # Hide table
            if ($screen.Components.taskTable) {
                $screen.Components.taskTable.Visible = $false
                $screen.Components.taskTable.IsFocusable = $false
                $screen.Components.taskTable.IsFocused = $false
            }
            
            # Focus first field
            $screen.FocusedComponentName = 'formTitle'
            $screen.Components.formTitle.IsFocused = $true
            
            # Update engine focus
            if (Get-Command Set-ComponentFocus -ErrorAction SilentlyContinue) {
                Set-ComponentFocus -Component $screen.Components.formTitle
            }
            
            Request-TuiRefresh
        }
        
        ShowEditTaskForm = {
            param($screen, $taskId)
            $task = $screen.State.tasks | Where-Object { $_.Id -eq $taskId }
            if (-not $task) { return }
            
            $screen.State.showingForm = $true
            $screen.State.editingTaskId = $task.Id
            
            # Update form components
            $screen.Components.formTitle.Text = $task.Title
            $screen.Components.formDescription.Text = $task.Description
            $screen.Components.formCategory.Value = $task.Category
            $screen.Components.formPriority.Value = $task.Priority
            $screen.Components.formDueDate.Value = [DateTime]::Parse($task.DueDate)
            
            # Center the form panel
            $formWidth = 60
            $formHeight = 24
            $screen.Components.formPanel.X = [Math]::Floor(($global:TuiState.BufferWidth - $formWidth) / 2)
            $screen.Components.formPanel.Y = 6
            $screen.Components.formPanel.Title = " Edit Task "
            
            # Show form panel
            $screen.Components.formPanel.Visible = $true
            
            # Enable focus on form components
            $screen.Components.formTitle.IsFocusable = $true
            $screen.Components.formDescription.IsFocusable = $true
            $screen.Components.formCategory.IsFocusable = $true
            $screen.Components.formPriority.IsFocusable = $true
            $screen.Components.formDueDate.IsFocusable = $true
            $screen.Components.formSaveButton.IsFocusable = $true
            $screen.Components.formCancelButton.IsFocusable = $true
            
            # Hide table
            if ($screen.Components.taskTable) {
                $screen.Components.taskTable.Visible = $false
                $screen.Components.taskTable.IsFocusable = $false
                $screen.Components.taskTable.IsFocused = $false
            }
            
            # Focus first field
            $screen.FocusedComponentName = 'formTitle'
            $screen.Components.formTitle.IsFocused = $true
            
            # Update engine focus
            if (Get-Command Set-ComponentFocus -ErrorAction SilentlyContinue) {
                Set-ComponentFocus -Component $screen.Components.formTitle
            }
            
            Request-TuiRefresh
        }
        
        SaveTask = {
            param($screen)
            
            # Get current values from form components
            $title = $screen.Components.formTitle.Text
            $description = $screen.Components.formDescription.Text
            $category = $screen.Components.formCategory.Value
            $priority = $screen.Components.formPriority.Value
            $dueDate = $screen.Components.formDueDate.Value
            
            $editingId = $screen.State.editingTaskId
            
            if ($editingId) {
                # Update existing
                $task = $screen.State.tasks | Where-Object { $_.Id -eq $editingId }
                if ($task) {
                    $task.Title = $title
                    $task.Description = $description
                    $task.Category = $category
                    $task.Priority = $priority
                    $task.DueDate = if ($dueDate -is [DateTime]) { $dueDate.ToString("MM/dd/yy") } else { $dueDate }
                }
            } else {
                # Add new
                $newTask = @{
                    Id = [Guid]::NewGuid().ToString()
                    Title = $title
                    Description = $description
                    Category = $category
                    Priority = $priority
                    Status = "Active"
                    DueDate = if ($dueDate -is [DateTime]) { $dueDate.ToString("MM/dd/yy") } else { $dueDate }
                    Created = Get-Date
                    Completed = $null
                }
                $screen.State.tasks += $newTask
            }
            
            & $screen.HideForm -screen $screen
            & $screen.RefreshTaskTable -screen $screen
        }
        
        HideForm = {
            param($screen)
            $screen.State.showingForm = $false
            
            # Hide form panel
            $screen.Components.formPanel.Visible = $false
            
            # Disable focus on form components
            $screen.Components.formTitle.IsFocusable = $false
            $screen.Components.formTitle.IsFocused = $false
            $screen.Components.formDescription.IsFocusable = $false
            $screen.Components.formDescription.IsFocused = $false
            $screen.Components.formCategory.IsFocusable = $false
            $screen.Components.formCategory.IsFocused = $false
            $screen.Components.formPriority.IsFocusable = $false
            $screen.Components.formPriority.IsFocused = $false
            $screen.Components.formDueDate.IsFocusable = $false
            $screen.Components.formDueDate.IsFocused = $false
            $screen.Components.formSaveButton.IsFocusable = $false
            $screen.Components.formSaveButton.IsFocused = $false
            $screen.Components.formCancelButton.IsFocusable = $false
            $screen.Components.formCancelButton.IsFocused = $false
            
            # Show table
            if ($screen.Components.taskTable) {
                $screen.Components.taskTable.Visible = $true
                $screen.Components.taskTable.IsFocusable = $true
            }
            $screen.FocusedComponentName = 'taskTable'
            Request-TuiRefresh
        }
        
        DeleteTask = {
            param($screen)
            $selectedRow = $screen.Components.taskTable.SelectedRow
            if ($selectedRow -ge 0 -and $selectedRow -lt $screen.Components.taskTable.ProcessedData.Count) {
                $taskData = $screen.Components.taskTable.ProcessedData[$selectedRow]
                $screen.State.tasks = @($screen.State.tasks | Where-Object { $_.Id -ne $taskData.Id })
                & $screen.RefreshTaskTable -screen $screen
            }
        }
        
        ToggleTaskStatus = {
            param($screen)
            $selectedRow = $screen.Components.taskTable.SelectedRow
            if ($selectedRow -ge 0 -and $selectedRow -lt $screen.Components.taskTable.ProcessedData.Count) {
                $taskData = $screen.Components.taskTable.ProcessedData[$selectedRow]
                $task = $screen.State.tasks | Where-Object { $_.Id -eq $taskData.Id }
                if ($task) {
                    if ($task.Status -eq "Active") {
                        $task.Status = "Completed"
                        $task.Completed = Get-Date
                    } else {
                        $task.Status = "Active"
                        $task.Completed = $null
                    }
                    & $screen.RefreshTaskTable -screen $screen
                }
            }
        }
        
        # 3. Init: One-time setup
        Init = {
            param($self)
            
            # Try to load from global data first
            if ($global:Data -and $global:Data.Tasks -and $global:Data.Tasks.Count -gt 0) {
                $self.State.tasks = @($global:Data.Tasks | ForEach-Object { $_ })
                Write-Log -Level Debug -Message "Loaded $($self.State.tasks.Count) tasks from global data"
            } else {
                # Initialize sample tasks
            $sampleTasks = @(
                @{
                    Id = [Guid]::NewGuid().ToString()
                    Title = "Review documentation"
                    Description = "Go through TUI framework docs and identify gaps"
                    Category = "Work"
                    Priority = "High"
                    Status = "Active"
                    DueDate = (Get-Date).AddDays(2).ToString("MM/dd/yy")
                    Created = (Get-Date).AddDays(-3)
                    Completed = $null
                }
                @{
                    Id = [Guid]::NewGuid().ToString()
                    Title = "Fix memory leaks"
                    Description = "Address critical memory leak issues in event system"
                    Category = "Urgent"
                    Priority = "Critical"
                    Status = "Active"
                    DueDate = (Get-Date).AddDays(1).ToString("MM/dd/yy")
                    Created = (Get-Date).AddDays(-1)
                    Completed = $null
                }
                @{
                    Id = [Guid]::NewGuid().ToString()
                    Title = "Add clipboard support"
                    Description = "Implement Ctrl+C/V in text components"
                    Category = "Projects"
                    Priority = "Medium"
                    Status = "Completed"
                    DueDate = (Get-Date).AddDays(-1).ToString("MM/dd/yy")
                    Created = (Get-Date).AddDays(-7)
                    Completed = (Get-Date).AddDays(-1)
                }
            )
            
                $self.State.tasks = $sampleTasks
                Write-Log -Level Debug -Message "Using sample tasks data"
            }
            
            # Create main task table
            $tableScreen = $self  # Capture reference for closure
            $self.Components.taskTable = New-TuiDataTable -Props @{
                X = 2; Y = 5; Width = 76; Height = 20
                Columns = @(
                    @{ Name = "Status"; Header = "✓"; Width = 3 }
                    @{ Name = "Priority"; Header = "Priority"; Width = 10 }
                    @{ Name = "Title"; Header = "Title"; Width = 30 }
                    @{ Name = "Category"; Header = "Category"; Width = 11 }
                    @{ Name = "DueDate"; Header = "Due Date"; Width = 10 }
                )
                Data = & $self.GetFilteredTasks -screen $self
                AllowSort = $false  # We handle sorting ourselves
                AllowFilter = $false
                MultiSelect = $false
                Title = "Tasks"
                OnRowSelect = {
                    param($SelectedData, $SelectedIndex)
                    # Toggle task status on Enter
                    $task = $tableScreen.State.tasks | Where-Object { $_.Id -eq $SelectedData.Id }
                    if ($task) {
                        if ($task.Status -eq "Active") {
                            $task.Status = "Completed"
                            $task.Completed = Get-Date
                        } else {
                            $task.Status = "Active"
                            $task.Completed = $null
                        }
                        & $tableScreen.RefreshTaskTable -screen $tableScreen
                    }
                }
            }
            
            # Force process data to ensure display
            if ($self.Components.taskTable.ProcessData) {
                & $self.Components.taskTable.ProcessData -self $self.Components.taskTable
            }
            
            # Form components (hidden by default)
            $formScreen = $self  # Capture reference for closures
            
            # Create form panel that will contain all form elements
            $self.Components.formPanel = New-TuiPanel -Props @{
                X = 0; Y = 0; Width = 60; Height = 24  # Will be positioned when shown
                Layout = 'Stack'
                Orientation = 'Vertical' 
                Spacing = 1
                Padding = 2
                ShowBorder = $true
                Title = " Task Form "
                Visible = $false
            }
            
            # Title label and textbox in a row
            $titleRow = New-TuiPanel -Props @{
                Width = 56; Height = 4
                Layout = 'Stack'
                Orientation = 'Vertical'
                Spacing = 0
                Padding = 0
            }
            $titleLabel = New-TuiLabel -Props @{ Text = "Title:"; Width = 50 }
            $self.Components.formTitle = New-TuiTextBox -Props @{
                Width = 54; Height = 3
                Placeholder = "Enter task title..."
                IsFocusable = $false
            }
            $titleRow.AddChild($titleRow, $titleLabel)
            $titleRow.AddChild($titleRow, $self.Components.formTitle)
            
            # Description label and textarea in a row
            $descRow = New-TuiPanel -Props @{
                Width = 56; Height = 6
                Layout = 'Stack'
                Orientation = 'Vertical'
                Spacing = 0
                Padding = 0
            }
            $descLabel = New-TuiLabel -Props @{ Text = "Description:"; Width = 50 }
            $self.Components.formDescription = New-TuiTextArea -Props @{
                Width = 54; Height = 5
                Placeholder = "Enter task description..."
                IsFocusable = $false
            }
            $descRow.AddChild($descRow, $descLabel)
            $descRow.AddChild($descRow, $self.Components.formDescription)
            
            # Category and Priority in horizontal layout
            $categoryPriorityRow = New-TuiPanel -Props @{
                Width = 56; Height = 4
                Layout = 'Stack'
                Orientation = 'Horizontal'
                Spacing = 5
                Padding = 0
            }
            
            $categoryPanel = New-TuiPanel -Props @{
                Width = 25; Height = 4
                Layout = 'Stack'
                Orientation = 'Vertical'
                Spacing = 0
                Padding = 0
            }
            $categoryLabel = New-TuiLabel -Props @{ Text = "Category:"; Width = 20 }
            $self.Components.formCategory = New-TuiDropdown -Props @{
                Width = 20; Height = 3
                Options = $self.State.categories | ForEach-Object { @{ Display = $_; Value = $_ } }
                IsFocusable = $false
            }
            $categoryPanel.AddChild($categoryPanel, $categoryLabel)
            $categoryPanel.AddChild($categoryPanel, $self.Components.formCategory)
            
            $priorityPanel = New-TuiPanel -Props @{
                Width = 25; Height = 4
                Layout = 'Stack'
                Orientation = 'Vertical'
                Spacing = 0
                Padding = 0
            }
            $priorityLabel = New-TuiLabel -Props @{ Text = "Priority:"; Width = 20 }
            $self.Components.formPriority = New-TuiDropdown -Props @{
                Width = 20; Height = 3
                Options = @(
                    @{ Display = "Critical"; Value = "Critical" }
                    @{ Display = "High"; Value = "High" }
                    @{ Display = "Medium"; Value = "Medium" }
                    @{ Display = "Low"; Value = "Low" }
                )
                IsFocusable = $false
            }
            $priorityPanel.AddChild($priorityPanel, $priorityLabel)
            $priorityPanel.AddChild($priorityPanel, $self.Components.formPriority)
            
            $categoryPriorityRow.AddChild($categoryPriorityRow, $categoryPanel)
            $categoryPriorityRow.AddChild($categoryPriorityRow, $priorityPanel)
            
            # Due Date row
            $dueDateRow = New-TuiPanel -Props @{
                Width = 56; Height = 4
                Layout = 'Stack'
                Orientation = 'Vertical'
                Spacing = 0
                Padding = 0
            }
            $dueDateLabel = New-TuiLabel -Props @{ Text = "Due Date:"; Width = 50 }
            $self.Components.formDueDate = New-TuiDatePicker -Props @{
                Width = 20; Height = 3
                IsFocusable = $false
            }
            $dueDateRow.AddChild($dueDateRow, $dueDateLabel)
            $dueDateRow.AddChild($dueDateRow, $self.Components.formDueDate)
            
            # Button row
            $buttonRow = New-TuiPanel -Props @{
                Width = 56; Height = 3
                Layout = 'Stack'
                Orientation = 'Horizontal'
                Spacing = 5
                Padding = 0
            }
            
            $self.Components.formSaveButton = New-TuiButton -Props @{
                Width = 15; Height = 3
                Text = "Save"
                IsFocusable = $false
                OnClick = { & $formScreen.SaveTask -screen $formScreen }
            }
            
            $self.Components.formCancelButton = New-TuiButton -Props @{
                Width = 15; Height = 3
                Text = "Cancel"
                IsFocusable = $false
                OnClick = { & $formScreen.HideForm -screen $formScreen }
            }
            
            $buttonRow.AddChild($buttonRow, $self.Components.formSaveButton)
            $buttonRow.AddChild($buttonRow, $self.Components.formCancelButton)
            
            # Add all rows to form panel
            $self.Components.formPanel.AddChild($self.Components.formPanel, $titleRow)
            $self.Components.formPanel.AddChild($self.Components.formPanel, $descRow)
            $self.Components.formPanel.AddChild($self.Components.formPanel, $categoryPriorityRow)
            $self.Components.formPanel.AddChild($self.Components.formPanel, $dueDateRow)
            $self.Components.formPanel.AddChild($self.Components.formPanel, $buttonRow)
        }
        
        # 4. Render: Draw the screen and its components
        Render = {
            param($self)
            
            # Header
            $headerColor = Get-ThemeColor "Header" -Default ([ConsoleColor]::Cyan)
            Write-BufferString -X 2 -Y 1 -Text "Task Management" -ForegroundColor $headerColor
            
            # Filter/Sort toolbar
            $toolbarY = 3
            Write-BufferString -X 2 -Y $toolbarY -Text "Filter: " -ForegroundColor ([ConsoleColor]::Gray)
            $filterOptions = @("All", "Active", "Completed")
            $filterX = 10
            foreach ($option in $filterOptions) {
                $isSelected = ($option.ToLower() -eq $self.State.filter)
                $color = if ($isSelected) { [ConsoleColor]::Yellow } else { [ConsoleColor]::White }
                Write-BufferString -X $filterX -Y $toolbarY -Text "[$option]" -ForegroundColor $color
                $filterX += $option.Length + 4
            }
            
            Write-BufferString -X 40 -Y $toolbarY -Text "Sort: " -ForegroundColor ([ConsoleColor]::Gray)
            $sortOptions = @(@{Display="Priority"; Value="priority"}, @{Display="Due Date"; Value="dueDate"}, @{Display="Created"; Value="created"})
            $sortX = 46
            foreach ($option in $sortOptions) {
                $isSelected = ($option.Value -eq $self.State.sortBy)
                $color = if ($isSelected) { [ConsoleColor]::Yellow } else { [ConsoleColor]::White }
                Write-BufferString -X $sortX -Y $toolbarY -Text "[$($option.Display)]" -ForegroundColor $color
                $sortX += $option.Display.Length + 4
            }
            
            # Help panel
            if ($self.State.showHelp) {
                $helpWidth = 40
                $helpHeight = 20
                $helpX = $global:TuiState.BufferWidth - $helpWidth - 2
                $helpY = 5
                
                # Help background
                for ($y = $helpY; $y -lt ($helpY + $helpHeight); $y++) {
                    for ($x = $helpX; $x -lt ($helpX + $helpWidth); $x++) {
                        Write-BufferString -X $x -Y $y -Text " " -BackgroundColor ([ConsoleColor]::DarkBlue)
                    }
                }
                
                Write-BufferBox -X $helpX -Y $helpY -Width $helpWidth -Height $helpHeight -Title " Help " -BorderColor ([ConsoleColor]::Yellow)
                
                $commands = @(
                    @{ Key = "↑/↓"; Description = "Navigate tasks" }
                    @{ Key = "Space"; Description = "Toggle task completion" }
                    @{ Key = "N"; Description = "Add new task" }
                    @{ Key = "E"; Description = "Edit selected task" }
                    @{ Key = "D"; Description = "Delete selected task" }
                    @{ Key = "1-3"; Description = "Change filter" }
                    @{ Key = "P"; Description = "Sort by priority" }
                    @{ Key = "U"; Description = "Sort by due date" }
                    @{ Key = "C"; Description = "Sort by created date" }
                    @{ Key = "H"; Description = "Toggle this help" }
                    @{ Key = "Q/Esc"; Description = "Go back" }
                )
                
                $cmdY = $helpY + 2
                foreach ($cmd in $commands) {
                    Write-BufferString -X ($helpX + 2) -Y $cmdY -Text $cmd.Key -ForegroundColor ([ConsoleColor]::Yellow)
                    Write-BufferString -X ($helpX + 10) -Y $cmdY -Text $cmd.Description -ForegroundColor ([ConsoleColor]::White)
                    $cmdY++
                }
            }
            
            # Render all components
            foreach ($kvp in $self.Components.GetEnumerator()) {
                $component = $kvp.Value
                if ($component -and $component.Visible -ne $false) {
                    # Set focus state
                    $component.IsFocused = ($self.FocusedComponentName -eq $kvp.Key)
                    if ($component.Render) {
                        & $component.Render -self $component
                    }
                }
            }
            
            # Status bar
            $statusY = $global:TuiState.BufferHeight - 2
            $statusText = if ($self.State.showingForm) {
                "Tab: Next Field • Enter: Save • Esc: Cancel"
            } elseif ($self.State.showHelp) {
                "Esc/H: Close Help"
            } else {
                "↑↓: Navigate • Space: Toggle • N: New • E: Edit • D: Delete • H: Help • Q: Back"
            }
            Write-BufferString -X 2 -Y $statusY -Text $statusText -ForegroundColor ([ConsoleColor]::Gray)
        }
        
        # 5. HandleInput: Global input handling for the screen
        HandleInput = {
            param($self, $Key)
            
            if ($self.State.showingForm) {
                # Handle form navigation
                switch ($Key.Key) {
                    ([ConsoleKey]::Escape) {
                        & $self.HideForm -screen $self
                        return $true
                    }
                    ([ConsoleKey]::Tab) {
                        # Cycle through form fields
                        $formFields = @('formTitle', 'formDescription', 'formCategory', 'formPriority', 'formDueDate', 'formSaveButton', 'formCancelButton')
                        $visibleFields = $formFields | Where-Object { $self.Components[$_] -and $self.Components[$_].Visible }
                        
                        if ($visibleFields.Count -gt 0) {
                            $currentIndex = [array]::IndexOf($visibleFields, $self.FocusedComponentName)
                            if ($currentIndex -eq -1) { $currentIndex = 0 }
                            
                            if ($Key.Modifiers -band [ConsoleModifiers]::Shift) {
                                # Shift+Tab - go backwards
                                $nextIndex = ($currentIndex - 1 + $visibleFields.Count) % $visibleFields.Count
                            } else {
                                # Tab - go forwards
                                $nextIndex = ($currentIndex + 1) % $visibleFields.Count
                            }
                            
                            $self.FocusedComponentName = $visibleFields[$nextIndex]
                            
                            # Update component focus states
                            foreach ($field in $formFields) {
                                if ($self.Components[$field]) {
                                    $self.Components[$field].IsFocused = ($field -eq $self.FocusedComponentName)
                                }
                            }
                            
                            # Update engine's focus tracking
                            $focusedComponent = $self.Components[$self.FocusedComponentName]
                            if ($focusedComponent -and (Get-Command Set-ComponentFocus -ErrorAction SilentlyContinue)) {
                                Set-ComponentFocus -Component $focusedComponent
                            }
                        }
                        
                        Request-TuiRefresh
                        return $true
                    }
                }
                
                # Delegate to focused form component
                $focusedComponent = if ($self.FocusedComponentName) { $self.Components[$self.FocusedComponentName] } else { $null }
                if ($focusedComponent -and $focusedComponent.HandleInput) {
                    $result = & $focusedComponent.HandleInput -self $focusedComponent -Key $Key
                    if ($result) {
                        Request-TuiRefresh
                        return $true
                    }
                }
                return $false
            }
            
            # Handle list navigation
            switch ($Key.Key) {
                ([ConsoleKey]::H) {
                    $self.State.showHelp = -not $self.State.showHelp
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::Q) { return "Back" }
                ([ConsoleKey]::Escape) {
                    if ($self.State.showHelp) {
                        $self.State.showHelp = $false
                        Request-TuiRefresh
                        return $true
                    }
                    return "Back"
                }
                ([ConsoleKey]::Spacebar) {
                    & $self.ToggleTaskStatus -screen $self
                    return $true
                }
            }
            
            # Handle key characters
            if ($Key.KeyChar) {
                switch ($Key.KeyChar.ToString().ToUpper()) {
                    'N' {
                        & $self.ShowAddTaskForm -screen $self
                        return $true
                    }
                    'E' {
                        $selectedRow = $self.Components.taskTable.SelectedRow
                        if ($selectedRow -ge 0 -and $selectedRow -lt $self.Components.taskTable.ProcessedData.Count) {
                            $taskData = $self.Components.taskTable.ProcessedData[$selectedRow]
                            & $self.ShowEditTaskForm -screen $self -taskId $taskData.Id
                        }
                        return $true
                    }
                    'D' {
                        & $self.DeleteTask -screen $self
                        return $true
                    }
                    '1' {
                        $self.State.filter = "all"
                        & $self.RefreshTaskTable -screen $self
                        return $true
                    }
                    '2' {
                        $self.State.filter = "active"
                        & $self.RefreshTaskTable -screen $self
                        return $true
                    }
                    '3' {
                        $self.State.filter = "completed"
                        & $self.RefreshTaskTable -screen $self
                        return $true
                    }
                    'P' {
                        $self.State.sortBy = "priority"
                        & $self.RefreshTaskTable -screen $self
                        return $true
                    }
                    'U' {
                        $self.State.sortBy = "dueDate"
                        & $self.RefreshTaskTable -screen $self
                        return $true
                    }
                    'C' {
                        $self.State.sortBy = "created"
                        & $self.RefreshTaskTable -screen $self
                        return $true
                    }
                }
            }
            
            # Delegate to task table
            if ($self.Components.taskTable.Visible -and $self.Components.taskTable.HandleInput) {
                $result = & $self.Components.taskTable.HandleInput -self $self.Components.taskTable -Key $Key
                if ($result) {
                    Request-TuiRefresh
                    return $true
                }
            }
            
            return $false
        }
        
        # 6. Lifecycle Hooks
        OnResume = {
            param($self)
            # Refresh tasks from global data when returning to screen
            if ($global:Data -and $global:Data.Tasks) {
                $self.State.tasks = @($global:Data.Tasks | ForEach-Object { $_ })
                & $self.RefreshTaskTable -screen $self
                Write-Log -Level Debug -Message "Refreshed tasks from global data: $($self.State.tasks.Count) tasks"
            }
            Request-TuiRefresh
        }
    }
    
    return $screen
}

# Alias for compatibility
function global:Get-TaskScreen {
    return Get-TaskManagementScreen
}

Export-ModuleMember -Function Get-TaskManagementScreen, Get-TaskScreen
# Dashboard Screen - FIXED COMPLIANT VERSION
# Using programmatic pattern with component-based architecture

function global:Get-DashboardScreen {
    $screen = @{
        Name = "DashboardScreen"
        
        # 1. State: Central data model for the screen
        State = @{
            ActiveTimers = @()
            TodaysTasks = @()
            RecentEntries = @()
            QuickStats = @{
                TodayHours = 0
                WeekHours = 0
                ActiveTasks = 0
                RunningTimers = 0
            }
            LastRefresh = [DateTime]::MinValue
            AutoRefreshInterval = 5
        }
        
        # 2. Components: Storage for instantiated component objects
        Components = @{}
        
        # Focus management
        FocusedComponentName = "quickActions"
        
        # Define refresh method directly on the hashtable
        RefreshData = {
            param($screen)
            
            Write-Log -Level Debug -Message "RefreshData called"
            
            try {
                # Refresh Active Timers
                if ($global:Data -and $global:Data.ActiveTimers) {
                    $timerData = @()
                    foreach ($timerEntry in $global:Data.ActiveTimers.GetEnumerator()) {
                        $timer = $timerEntry.Value
                        if ($timer -and $timer.StartTime) {
                            $elapsed = (Get-Date) - [DateTime]$timer.StartTime
                            $project = if ($global:Data.Projects -and $timer.ProjectKey) { 
                                $global:Data.Projects[$timer.ProjectKey].Name 
                            } else { 
                                "Unknown" 
                            }
                            
                            $timerData += @{
                                Project = $project
                                Time = "{0:00}:{1:00}:{2:00}" -f [Math]::Floor($elapsed.TotalHours), $elapsed.Minutes, $elapsed.Seconds
                            }
                        }
                    }
                    if ($screen.Components.activeTimers) {
                        $screen.Components.activeTimers.Data = $timerData
                        # Force process data to refresh display
                        if ($screen.Components.activeTimers.ProcessData) {
                            & $screen.Components.activeTimers.ProcessData -self $screen.Components.activeTimers
                        }
                    }
                    Write-Log -Level Debug -Message "Active timers updated: $($timerData.Count) timers"
                }
                
                # Refresh Today's Tasks
                if ($global:Data -and $global:Data.Tasks) {
                    $today = (Get-Date).ToString("yyyy-MM-dd")
                    $taskData = @()
                    foreach ($task in $global:Data.Tasks) {
                        if ($task -and -not $task.Completed -and ($task.DueDate -eq $today -or [string]::IsNullOrEmpty($task.DueDate))) {
                            $project = if ($global:Data.Projects -and $task.ProjectKey) { 
                                $global:Data.Projects[$task.ProjectKey].Name 
                            } else { 
                                "None" 
                            }
                            
                            $taskData += @{
                                Priority = $task.Priority ?? "Medium"
                                Description = $task.Description
                                Project = $project
                            }
                        }
                    }
                    if ($screen.Components.todaysTasks) {
                        $screen.Components.todaysTasks.Data = $taskData | Sort-Object Priority, Description
                        # Force process data to refresh display
                        if ($screen.Components.todaysTasks.ProcessData) {
                            & $screen.Components.todaysTasks.ProcessData -self $screen.Components.todaysTasks
                        }
                    }
                    Write-Log -Level Debug -Message "Today's tasks updated: $($taskData.Count) tasks"
                }
                
                # Refresh Stats
                $stats = @{ TodayHours = 0; WeekHours = 0; ActiveTasks = 0; RunningTimers = 0 }
                
                if ($global:Data) {
                    $today = (Get-Date).ToString("yyyy-MM-dd")
                    
                    if ($global:Data.TimeEntries) {
                        $todayEntries = @($global:Data.TimeEntries | Where-Object { $_ -and $_.Date -eq $today })
                        $stats.TodayHours = [Math]::Round(($todayEntries | Measure-Object -Property Hours -Sum).Sum, 2)
                        
                        $weekStart = (Get-Date).AddDays(-[int](Get-Date).DayOfWeek).Date
                        $weekEntries = @($global:Data.TimeEntries | Where-Object { 
                            $_ -and $_.Date -and ([DateTime]::Parse($_.Date) -ge $weekStart)
                        })
                        $stats.WeekHours = [Math]::Round(($weekEntries | Measure-Object -Property Hours -Sum).Sum, 2)
                    }
                    
                    if ($global:Data.Tasks) {
                        $stats.ActiveTasks = @($global:Data.Tasks | Where-Object { $_ -and -not $_.Completed }).Count
                    }
                    
                    if ($global:Data.ActiveTimers) {
                        $stats.RunningTimers = $global:Data.ActiveTimers.Count
                    }
                }
                
                $screen.State.QuickStats = $stats
                $screen.Components.todayHoursLabel.Text = "Today: $($stats.TodayHours)h"
                $screen.Components.weekHoursLabel.Text = "Week: $($stats.WeekHours)h"
                $screen.Components.activeTasksLabel.Text = "Tasks: $($stats.ActiveTasks)"
                $screen.Components.runningTimersLabel.Text = "Timers: $($stats.RunningTimers)"
                
                Write-Log -Level Debug -Message "Stats updated: Today=$($stats.TodayHours)h, Week=$($stats.WeekHours)h, Tasks=$($stats.ActiveTasks), Timers=$($stats.RunningTimers)"
            } catch {
                Write-Log -Level Error -Message "RefreshData error: $_" -Data $_
            }
        }
        
        # 3. Init: One-time setup
        Init = {
            param($self)
            
            Write-Log -Level Debug -Message "Dashboard Init started"
            
            try {
                # Create a reference to the screen for closures
                $screenRef = $self
                
                # Quick Actions - Simple implementation
                if (Get-Command New-TuiDataTable -ErrorAction SilentlyContinue) {
                    $self.Components.quickActions = New-TuiDataTable -Props @{
                        X = 2; Y = 4; Width = 35; Height = 12
                        IsFocusable = $true
                        ShowBorder = $false  # Parent screen draws the border
                        Columns = @(
                            @{ Name = "Action"; Header = "Quick Actions" }  # Let width auto-calculate
                        )
                        Data = @(
                            @{ Action = "1. Add Time Entry" }
                            @{ Action = "2. Start Timer" }
                            @{ Action = "3. Manage Tasks" }
                            @{ Action = "4. Manage Projects" }
                            @{ Action = "5. View Reports" }
                            @{ Action = "6. Settings" }
                        )
                        AllowSort = $false
                        AllowFilter = $false
                        MultiSelect = $false
                        ShowHeader = $false
                        ShowFooter = $false
                        Title = "Quick Actions"
                        OnRowSelect = {
                            param($SelectedData, $SelectedIndex)
                            Write-Log -Level Debug -Message "Quick action selected: $SelectedIndex"
                            switch ($SelectedIndex) {
                                0 { if (Get-Command Get-TimeEntryFormScreen -ErrorAction SilentlyContinue) { Push-Screen -Screen (Get-TimeEntryFormScreen) } }
                                1 { if (Get-Command Get-TimerStartScreen -ErrorAction SilentlyContinue) { Push-Screen -Screen (Get-TimerStartScreen) } }
                                2 { if (Get-Command Get-TaskScreen -ErrorAction SilentlyContinue) { Push-Screen -Screen (Get-TaskScreen) } elseif (Get-Command Get-TaskManagementScreen -ErrorAction SilentlyContinue) { Push-Screen -Screen (Get-TaskManagementScreen) } }
                                3 { if (Get-Command Get-ProjectManagementScreen -ErrorAction SilentlyContinue) { Push-Screen -Screen (Get-ProjectManagementScreen) } }
                                4 { if (Get-Command Get-ReportsScreen -ErrorAction SilentlyContinue) { Push-Screen -Screen (Get-ReportsScreen) } }
                                5 { if (Get-Command Get-SettingsScreen -ErrorAction SilentlyContinue) { Push-Screen -Screen (Get-SettingsScreen) } }
                            }
                        }
                    }
                    
                    # Debug logging
                    Write-Log -Level Debug -Message "Quick Actions DataTable created with data:"
                    foreach ($item in $self.Components.quickActions.Data) {
                        Write-Log -Level Debug -Message "  Action: '$($item.Action)' (Length: $($item.Action.Length))"
                    }
                    
                    # Force process data to ensure display
                    if ($self.Components.quickActions.ProcessData) {
                        & $self.Components.quickActions.ProcessData -self $self.Components.quickActions
                        Write-Log -Level Debug -Message "ProcessedData count: $($self.Components.quickActions.ProcessedData.Count)"
                        if ($self.Components.quickActions.ProcessedData.Count -gt 0) {
                            Write-Log -Level Debug -Message "First processed item: $($self.Components.quickActions.ProcessedData[0] | ConvertTo-Json -Compress)"
                        }
                    }
                    Write-Log -Level Debug -Message "Quick Actions DataTable ProcessData called"
                } else {
                    Write-Log -Level Warning -Message "DataTable component not available, using basic rendering"
                    # Fallback to simple rendering
                    $self.Components.quickActions = @{
                        Type = "QuickActionsList"
                        X = 2; Y = 4; Width = 35; Height = 12
                        IsFocusable = $true
                        Visible = $true
                        SelectedIndex = 0
                        Items = @(
                            "1. Add Time Entry"
                            "2. Start Timer"
                            "3. Manage Tasks"
                            "4. Manage Projects"
                            "5. View Reports"
                            "6. Settings"
                        )
                        Render = {
                            param($self)
                            $y = $self.Y
                            foreach ($i in 0..($self.Items.Count - 1)) {
                                $item = $self.Items[$i]
                                $fg = if ($self.IsFocused -and $i -eq $self.SelectedIndex) { 
                                    Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
                                } else { 
                                    Get-ThemeColor "Primary" -Default ([ConsoleColor]::White)
                                }
                                Write-BufferString -X $self.X -Y $y -Text $item -ForegroundColor $fg
                                $y++
                            }
                        }
                        HandleInput = {
                            param($self, $Key)
                            switch ($Key.Key) {
                                ([ConsoleKey]::UpArrow) {
                                    if ($self.SelectedIndex -gt 0) {
                                        $self.SelectedIndex--
                                        Request-TuiRefresh
                                    }
                                    return $true
                                }
                                ([ConsoleKey]::DownArrow) {
                                    if ($self.SelectedIndex -lt $self.Items.Count - 1) {
                                        $self.SelectedIndex++
                                        Request-TuiRefresh
                                    }
                                    return $true
                                }
                                ([ConsoleKey]::Enter) {
                                    switch ($self.SelectedIndex) {
                                        0 { if (Get-Command Get-TimeEntryFormScreen -ErrorAction SilentlyContinue) { Push-Screen -Screen (Get-TimeEntryFormScreen) } }
                                        1 { if (Get-Command Get-TimerStartScreen -ErrorAction SilentlyContinue) { Push-Screen -Screen (Get-TimerStartScreen) } }
                                        2 { if (Get-Command Get-TaskScreen -ErrorAction SilentlyContinue) { Push-Screen -Screen (Get-TaskScreen) } }
                                        3 { if (Get-Command Get-ProjectManagementScreen -ErrorAction SilentlyContinue) { Push-Screen -Screen (Get-ProjectManagementScreen) } }
                                        4 { if (Get-Command Get-ReportsScreen -ErrorAction SilentlyContinue) { Push-Screen -Screen (Get-ReportsScreen) } }
                                        5 { if (Get-Command Get-SettingsScreen -ErrorAction SilentlyContinue) { Push-Screen -Screen (Get-SettingsScreen) } }
                                    }
                                    return $true
                                }
                            }
                            return $false
                        }
                    }
                }
                
                # Active Timers
                if (Get-Command New-TuiDataTable -ErrorAction SilentlyContinue) {
                    $self.Components.activeTimers = New-TuiDataTable -Props @{
                        X = 40; Y = 4; Width = 40; Height = 12
                        IsFocusable = $true
                        ShowBorder = $false  # Parent screen draws the border
                        Columns = @(
                            @{ Name = "Project"; Header = "Project"; Width = 20 }
                            @{ Name = "Time"; Header = "Time"; Width = 10 }
                        )
                        Data = @()
                        AllowSort = $false
                        AllowFilter = $false
                        MultiSelect = $false
                        Title = "Active Timers"
                        ShowFooter = $false
                    }
                    # Force process data to ensure display
                    if ($self.Components.activeTimers.ProcessData) {
                        & $self.Components.activeTimers.ProcessData -self $self.Components.activeTimers
                    }
                    Write-Log -Level Debug -Message "Active Timers DataTable created"
                }
                
                # Today's Tasks
                if (Get-Command New-TuiDataTable -ErrorAction SilentlyContinue) {
                    $self.Components.todaysTasks = New-TuiDataTable -Props @{
                        X = 2; Y = 18; Width = 78; Height = 10
                        IsFocusable = $true
                        ShowBorder = $false  # Parent screen draws the border
                        Columns = @(
                            @{ Name = "Priority"; Header = "Pri"; Width = 8 }
                            @{ Name = "Description"; Header = "Task"; Width = 50 }
                            @{ Name = "Project"; Header = "Project"; Width = 15 }
                        )
                        Data = @()
                        AllowSort = $true
                        AllowFilter = $false
                        MultiSelect = $false
                        Title = "Today's Tasks"
                        ShowFooter = $false
                    }
                    # Force process data to ensure display
                    if ($self.Components.todaysTasks.ProcessData) {
                        & $self.Components.todaysTasks.ProcessData -self $self.Components.todaysTasks
                    }
                    Write-Log -Level Debug -Message "Today's Tasks DataTable created"
                }
                
                # Stats Labels
                $self.Components.statsLabel = New-TuiLabel -Props @{
                    X = 84; Y = 4; Text = "Today's Stats"
                }
                
                $self.Components.todayHoursLabel = New-TuiLabel -Props @{
                    X = 84; Y = 6; Text = "Today: 0h"
                }
                
                $self.Components.weekHoursLabel = New-TuiLabel -Props @{
                    X = 84; Y = 8; Text = "Week: 0h"
                }
                
                $self.Components.activeTasksLabel = New-TuiLabel -Props @{
                    X = 84; Y = 10; Text = "Tasks: 0"
                }
                
                $self.Components.runningTimersLabel = New-TuiLabel -Props @{
                    X = 84; Y = 12; Text = "Timers: 0"
                }
                
                Write-Log -Level Debug -Message "Stats labels created"
                
                # Initial refresh - call with the screen as parameter
                & $self.RefreshData -screen $self
                
            } catch {
                Write-Log -Level Error -Message "Dashboard Init error: $_" -Data $_
            }
        }
        
        # 4. Render: Draw the screen and its components
        Render = {
            param($self)
            
            try {
                # Auto-refresh check
                if (([DateTime]::Now - $self.State.LastRefresh).TotalSeconds -gt $self.State.AutoRefreshInterval) {
                    & $self.RefreshData -screen $self
                    $self.State.LastRefresh = [DateTime]::Now
                }
                
                # Header
                $headerColor = Get-ThemeColor "Header" -Default ([ConsoleColor]::Cyan)
                $currentTime = Get-Date -Format 'dddd, MMMM dd, yyyy HH:mm:ss'
                Write-BufferString -X 2 -Y 1 -Text "PMC Terminal Dashboard - $currentTime" -ForegroundColor $headerColor
                
                # Active timer indicator
                if ($self.State.QuickStats.RunningTimers -gt 0) {
                    $timerText = "● TIMER ACTIVE"
                    $timerX = $global:TuiState.BufferWidth - $timerText.Length - 2
                    Write-BufferString -X $timerX -Y 1 -Text $timerText -ForegroundColor Red
                }
                
                # Draw boxes for organization
                Write-BufferBox -X 1 -Y 3 -Width 37 -Height 14 -Title " Quick Actions " -BorderColor (Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan))
                Write-BufferBox -X 39 -Y 3 -Width 42 -Height 14 -Title " Active Timers " -BorderColor (Get-ThemeColor "Info" -Default ([ConsoleColor]::Blue))
                Write-BufferBox -X 83 -Y 3 -Width 20 -Height 14 -Title " Stats " -BorderColor (Get-ThemeColor "Success" -Default ([ConsoleColor]::Green))
                Write-BufferBox -X 1 -Y 17 -Width 80 -Height 12 -Title " Today's Tasks " -BorderColor (Get-ThemeColor "Warning" -Default ([ConsoleColor]::Yellow))
                
                # Render all components
                foreach ($kvp in $self.Components.GetEnumerator()) {
                    $component = $kvp.Value
                    if ($component -and $component.Visible -ne $false) {
                        # Set focus state based on screen's tracking
                        $component.IsFocused = ($self.FocusedComponentName -eq $kvp.Key)
                        if ($component.Render) {
                            & $component.Render -self $component
                        }
                    }
                }
                
                # Status bar
                $subtleColor = Get-ThemeColor "Subtle" -Default ([ConsoleColor]::DarkGray)
                $statusY = $global:TuiState.BufferHeight - 2
                Write-BufferString -X 2 -Y $statusY -Text "Tab: Switch Focus • Enter: Select • R: Refresh • Q: Quit • F12: Debug Log" -ForegroundColor $subtleColor
                
            } catch {
                Write-Log -Level Error -Message "Dashboard Render error: $_" -Data $_
                Write-BufferString -X 2 -Y 2 -Text "Error rendering dashboard: $_" -ForegroundColor Red
            }
        }
        
        # 5. HandleInput: Global input handling for the screen
        HandleInput = {
            param($self, $Key)
            
            try {
                # Debug log access
                if ($Key.Key -eq [ConsoleKey]::F12) {
                    if (Get-Command Get-DebugLogScreen -ErrorAction SilentlyContinue) {
                        Push-Screen -Screen (Get-DebugLogScreen)
                    }
                    return $true
                }
                
                # Debug overlay toggle
                if ($Key.Key -eq [ConsoleKey]::F10) {
                    $global:TuiState.DebugOverlayEnabled = -not $global:TuiState.DebugOverlayEnabled
                    Request-TuiRefresh
                    return $true
                }
                
                # Screen-level shortcuts
                switch ($Key.Key) {
                    ([ConsoleKey]::R) {
                        # Manual refresh
                        Write-Log -Level Debug -Message "Manual refresh requested"
                        & $self.RefreshData -screen $self
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::Q) { 
                        Write-Log -Level Debug -Message "Quit requested"
                        return "Quit" 
                    }
                    ([ConsoleKey]::Escape) { 
                        Write-Log -Level Debug -Message "Escape pressed - quitting"
                        return "Quit" 
                    }
                    ([ConsoleKey]::Tab) {
                        # Cycle focus between tables
                        $focusableComponents = @("quickActions", "activeTimers", "todaysTasks") | 
                            Where-Object { $self.Components.$_ -and $self.Components.$_.IsFocusable }
                        
                        if ($focusableComponents.Count -gt 0) {
                            $currentIndex = [array]::IndexOf($focusableComponents, $self.FocusedComponentName)
                            if ($Key.Modifiers -band [ConsoleModifiers]::Shift) {
                                # Shift+Tab - go backwards
                                $nextIndex = ($currentIndex - 1 + $focusableComponents.Count) % $focusableComponents.Count
                            } else {
                                # Tab - go forwards
                                $nextIndex = ($currentIndex + 1) % $focusableComponents.Count
                            }
                            $self.FocusedComponentName = $focusableComponents[$nextIndex]
                            
                            # Update engine's focus tracking
                            $focusedComponent = $self.Components[$self.FocusedComponentName]
                            if ($focusedComponent -and (Get-Command Set-ComponentFocus -ErrorAction SilentlyContinue)) {
                                Set-ComponentFocus -Component $focusedComponent
                            }
                            
                            Write-Log -Level Debug -Message "Focus changed to: $($self.FocusedComponentName)"
                            Request-TuiRefresh
                        }
                        return $true
                    }
                }
                
                # Number keys for quick actions
                if ($Key.KeyChar -ge '1' -and $Key.KeyChar -le '6') {
                    $index = [int]$Key.KeyChar.ToString() - 1
                    Write-Log -Level Debug -Message "Number key pressed: $($Key.KeyChar)"
                    switch ($index) {
                        0 { if (Get-Command Get-TimeEntryFormScreen -ErrorAction SilentlyContinue) { Push-Screen -Screen (Get-TimeEntryFormScreen) } }
                        1 { if (Get-Command Get-TimerStartScreen -ErrorAction SilentlyContinue) { Push-Screen -Screen (Get-TimerStartScreen) } }
                        2 { if (Get-Command Get-TaskScreen -ErrorAction SilentlyContinue) { Push-Screen -Screen (Get-TaskScreen) } elseif (Get-Command Get-TaskManagementScreen -ErrorAction SilentlyContinue) { Push-Screen -Screen (Get-TaskManagementScreen) } }
                        3 { if (Get-Command Get-ProjectManagementScreen -ErrorAction SilentlyContinue) { Push-Screen -Screen (Get-ProjectManagementScreen) } }
                        4 { if (Get-Command Get-ReportsScreen -ErrorAction SilentlyContinue) { Push-Screen -Screen (Get-ReportsScreen) } }
                        5 { if (Get-Command Get-SettingsScreen -ErrorAction SilentlyContinue) { Push-Screen -Screen (Get-SettingsScreen) } }
                    }
                    return $true
                }
                

                
                # Delegate to focused component
                $focusedComponent = if ($self.FocusedComponentName) { $self.Components[$self.FocusedComponentName] } else { $null }
                if ($focusedComponent -and $focusedComponent.HandleInput) {
                    $result = & $focusedComponent.HandleInput -self $focusedComponent -Key $Key
                    if ($result) {
                        Request-TuiRefresh
                        return $true
                    }
                }
                
            } catch {
                Write-Log -Level Error -Message "HandleInput error: $_" -Data $_
            }
            
            return $false
        }
        
        # 6. Lifecycle Hooks
        OnExit = {
            param($self)
            Write-Log -Level Debug -Message "Dashboard screen exiting"
        }
        
        OnResume = {
            param($self)
            Write-Log -Level Debug -Message "Dashboard screen resuming"
            # Refresh data when returning to dashboard
            & $self.RefreshData -screen $self
            
            # Restore focus to the first focusable component
            if (-not $self.FocusedComponentName -or -not $self.Components[$self.FocusedComponentName]) {
                $self.FocusedComponentName = "quickActions"
            }
            
            # Ensure the focused component knows it's focused
            foreach ($kvp in $self.Components.GetEnumerator()) {
                $component = $kvp.Value
                if ($component) {
                    $component.IsFocused = ($kvp.Key -eq $self.FocusedComponentName)
                }
            }
            
            # Set engine focus to match screen's focus
            $focusedComponent = $self.Components[$self.FocusedComponentName]
            if ($focusedComponent -and (Get-Command Set-ComponentFocus -ErrorAction SilentlyContinue)) {
                Set-ComponentFocus -Component $focusedComponent
            }
            
            Request-TuiRefresh
        }
    }
    
    return $screen
}

Export-ModuleMember -Function Get-DashboardScreen
# Demo Screen - Shows all component types
# Demonstrates the TUI framework capabilities

function global:Get-DemoScreen {
    $screen = @{
        Name = "DemoScreen"
        
        State = @{
            textValue = "Hello, TUI!"
            checkboxValue = $true
            selectedDropdown = "Option2"
            progressValue = 35
            selectedDate = Get-Date
            selectedTime = @{ Hour = 14; Minute = 30 }
            tableData = @(
                @{ Name = "John Doe"; Role = "Developer"; Status = "Active" }
                @{ Name = "Jane Smith"; Role = "Designer"; Status = "Active" }
                @{ Name = "Bob Johnson"; Role = "Manager"; Status = "Away" }
            )
            textAreaContent = "This is a multi-line`ntext area example.`nYou can edit this text!"
            numberValue = 42
            sliderValue = 65
        }
        
        Components = @{}
        FocusedComponentName = "textBox"
        
        Init = {
            param($self)
            
            # Use layout manager for organized positioning
            if (Get-Command New-TuiLayoutManager -ErrorAction SilentlyContinue) {
                $layout = New-TuiLayoutManager -Container @{X=2; Y=4; Width=76; Height=20} -Mode 'Manual'
            }
            
            # Basic Components Section
            $self.Components.basicLabel = New-TuiLabel -Props @{
                X = 2; Y = 2; Text = "TUI Component Demo - Basic Components"
                ForegroundColor = (Get-ThemeColor "Header")
            }
            
            $self.Components.textBox = New-TuiTextBox -Props @{
                X = 2; Y = 4; Width = 30; Height = 3
                Text = $self.State.textValue
                Placeholder = "Enter text here..."
                OnChange = { param($NewValue) $self.State.textValue = $NewValue }
            }
            
            $self.Components.button = New-TuiButton -Props @{
                X = 35; Y = 4; Width = 15; Height = 3
                Text = "Click Me!"
                OnClick = { 
                    Show-AlertDialog -Title "Button Clicked" -Message "You entered: $($self.State.textValue)"
                }
            }
            
            $self.Components.checkbox = New-TuiCheckBox -Props @{
                X = 52; Y = 5; Width = 20
                Text = "Enable feature"
                Checked = $self.State.checkboxValue
                OnChange = { param($NewValue) $self.State.checkboxValue = $NewValue }
            }
            
            $self.Components.dropdown = New-TuiDropdown -Props @{
                X = 2; Y = 8; Width = 25; Height = 3
                Options = @(
                    @{ Display = "Option 1"; Value = "Option1" }
                    @{ Display = "Option 2"; Value = "Option2" }
                    @{ Display = "Option 3"; Value = "Option3" }
                )
                Value = $self.State.selectedDropdown
                OnChange = { param($NewValue) $self.State.selectedDropdown = $NewValue }
            }
            
            $self.Components.progressBar = New-TuiProgressBar -Props @{
                X = 30; Y = 9; Width = 30
                Value = $self.State.progressValue
                Max = 100
                ShowPercent = $true
            }
            
            # Date/Time Components
            $self.Components.dateTimeLabel = New-TuiLabel -Props @{
                X = 2; Y = 12; Text = "Date/Time Components:"
                ForegroundColor = (Get-ThemeColor "Info")
            }
            
            $self.Components.datePicker = New-TuiDatePicker -Props @{
                X = 2; Y = 14; Width = 20; Height = 3
                Value = $self.State.selectedDate
                OnChange = { param($NewValue) $self.State.selectedDate = $NewValue }
            }
            
            $self.Components.timePicker = New-TuiTimePicker -Props @{
                X = 25; Y = 14; Width = 15; Height = 3
                Hour = $self.State.selectedTime.Hour
                Minute = $self.State.selectedTime.Minute
                OnChange = { 
                    param($NewHour, $NewMinute) 
                    $self.State.selectedTime = @{ Hour = $NewHour; Minute = $NewMinute }
                }
            }
            
            # Advanced Components (if available)
            if (Get-Command New-TuiNumberInput -ErrorAction SilentlyContinue) {
                $self.Components.numberInput = New-TuiNumberInput -Props @{
                    X = 43; Y = 14; Width = 15; Height = 3
                    Value = $self.State.numberValue
                    Min = 0
                    Max = 100
                    Step = 1
                    OnChange = { param($NewValue) $self.State.numberValue = $NewValue }
                }
            }
            
            if (Get-Command New-TuiSlider -ErrorAction SilentlyContinue) {
                $self.Components.slider = New-TuiSlider -Props @{
                    X = 61; Y = 14; Width = 20; Height = 3
                    Value = $self.State.sliderValue
                    Min = 0
                    Max = 100
                    OnChange = { param($NewValue) $self.State.sliderValue = $NewValue }
                }
            }
            
            # Text Area
            $self.Components.textAreaLabel = New-TuiLabel -Props @{
                X = 2; Y = 18; Text = "Text Area:"
                ForegroundColor = (Get-ThemeColor "Info")
            }
            
            $self.Components.textArea = New-TuiTextArea -Props @{
                X = 2; Y = 20; Width = 40; Height = 6
                Text = $self.State.textAreaContent
                OnChange = { param($NewValue) $self.State.textAreaContent = $NewValue }
            }
            
            # Simple Table
            $self.Components.tableLabel = New-TuiLabel -Props @{
                X = 45; Y = 18; Text = "Data Table:"
                ForegroundColor = (Get-ThemeColor "Info")
            }
            
            $self.Components.table = New-TuiTable -Props @{
                X = 45; Y = 20; Width = 35; Height = 8
                Columns = @(
                    @{ Name = "Name"; Header = "Name"; Width = 15 }
                    @{ Name = "Role"; Header = "Role"; Width = 10 }
                    @{ Name = "Status"; Header = "Status"; Width = 8 }
                )
                Rows = $self.State.tableData
                OnRowSelect = {
                    param($Row, $Index)
                    Show-AlertDialog -Title "Row Selected" -Message "You selected: $($Row.Name)"
                }
            }
            
            # Chart (if available)
            $self.Components.chartLabel = New-TuiLabel -Props @{
                X = 84; Y = 2; Text = "Chart:"
                ForegroundColor = (Get-ThemeColor "Info")
            }
            
            $self.Components.chart = New-TuiChart -Props @{
                X = 84; Y = 4; Width = 20; Height = 10
                ChartType = "Bar"
                Data = @(
                    @{ Label = "Mon"; Value = 20 }
                    @{ Label = "Tue"; Value = 35 }
                    @{ Label = "Wed"; Value = 15 }
                    @{ Label = "Thu"; Value = 40 }
                    @{ Label = "Fri"; Value = 25 }
                )
            }
            
            # Interactive elements
            $self.Components.incrementButton = New-TuiButton -Props @{
                X = 84; Y = 15; Width = 10; Height = 3
                Text = "Progress+"
                OnClick = {
                    $self.State.progressValue = [Math]::Min(100, $self.State.progressValue + 10)
                    $self.Components.progressBar.Value = $self.State.progressValue
                    Request-TuiRefresh
                }
            }
            
            $self.Components.decrementButton = New-TuiButton -Props @{
                X = 95; Y = 15; Width = 10; Height = 3
                Text = "Progress-"
                OnClick = {
                    $self.State.progressValue = [Math]::Max(0, $self.State.progressValue - 10)
                    $self.Components.progressBar.Value = $self.State.progressValue
                    Request-TuiRefresh
                }
            }
            
            # Set initial focus
            if ($self.Components.textBox) {
                $self.Components.textBox.IsFocused = $true
            }
        }
        
        Render = {
            param($self)
            
            # Background
            $bgColor = Get-ThemeColor "Background"
            for ($y = 0; $y -lt $global:TuiState.BufferHeight; $y++) {
                Write-BufferString -X 0 -Y $y -Text (" " * $global:TuiState.BufferWidth) -BackgroundColor $bgColor
            }
            
            # Main container
            Write-BufferBox -X 0 -Y 0 -Width $global:TuiState.BufferWidth -Height ($global:TuiState.BufferHeight - 1) `
                -Title " Component Demo " -BorderColor (Get-ThemeColor "Border")
            
            # Render all components
            foreach ($kvp in $self.Components.GetEnumerator()) {
                $component = $kvp.Value
                if ($component -and $component.Visible -ne $false) {
                    # Update focus state
                    $component.IsFocused = ($self.FocusedComponentName -eq $kvp.Key)
                    
                    if ($component.Render) {
                        & $component.Render -self $component
                    }
                }
            }
            
            # Status bar
            $statusY = $global:TuiState.BufferHeight - 2
            $statusText = "Tab: Next Component • Shift+Tab: Previous • Space/Enter: Interact • Esc: Exit"
            Write-BufferString -X 2 -Y $statusY -Text $statusText -ForegroundColor (Get-ThemeColor "Subtle")
            
            # Current values display
            $valuesX = $global:TuiState.BufferWidth - 40
            Write-BufferString -X $valuesX -Y 20 -Text "Current Values:" -ForegroundColor (Get-ThemeColor "Header")
            Write-BufferString -X $valuesX -Y 21 -Text "Text: $($self.State.textValue.Substring(0, [Math]::Min(20, $self.State.textValue.Length)))" -ForegroundColor (Get-ThemeColor "Info")
            Write-BufferString -X $valuesX -Y 22 -Text "Checkbox: $($self.State.checkboxValue)" -ForegroundColor (Get-ThemeColor "Info")
            Write-BufferString -X $valuesX -Y 23 -Text "Dropdown: $($self.State.selectedDropdown)" -ForegroundColor (Get-ThemeColor "Info")
            Write-BufferString -X $valuesX -Y 24 -Text "Progress: $($self.State.progressValue)%" -ForegroundColor (Get-ThemeColor "Info")
            Write-BufferString -X $valuesX -Y 25 -Text "Date: $($self.State.selectedDate.ToString('yyyy-MM-dd'))" -ForegroundColor (Get-ThemeColor "Info")
            if ($self.State.numberValue) {
                Write-BufferString -X $valuesX -Y 26 -Text "Number: $($self.State.numberValue)" -ForegroundColor (Get-ThemeColor "Info")
            }
        }
        
        HandleInput = {
            param($self, $Key)
            
            # Screen-level shortcuts
            if ($Key.Key -eq [ConsoleKey]::Escape) {
                return "Back"
            }
            
            if ($Key.Key -eq [ConsoleKey]::F5) {
                # Refresh demo data
                $self.State.tableData = @(
                    @{ Name = "Alice Brown"; Role = "Developer"; Status = "Active" }
                    @{ Name = "Charlie Davis"; Role = "Tester"; Status = "Busy" }
                    @{ Name = "Eve Wilson"; Role = "Lead"; Status = "Active" }
                    @{ Name = "Frank Miller"; Role = "Analyst"; Status = "Away" }
                )
                $self.Components.table.Rows = $self.State.tableData
                Request-TuiRefresh
                return $true
            }
            
            # Tab navigation
            if ($Key.Key -eq [ConsoleKey]::Tab) {
                # Get all focusable components
                $focusableComponents = @()
                $focusableNames = @()
                
                foreach ($kvp in $self.Components.GetEnumerator()) {
                    if ($kvp.Value.IsFocusable -ne $false -and $kvp.Value.Visible -ne $false) {
                        $focusableComponents += $kvp.Value
                        $focusableNames += $kvp.Key
                    }
                }
                
                if ($focusableNames.Count -gt 0) {
                    $currentIndex = [array]::IndexOf($focusableNames, $self.FocusedComponentName)
                    if ($currentIndex -eq -1) { $currentIndex = 0 }
                    
                    if ($Key.Modifiers -band [ConsoleModifiers]::Shift) {
                        # Shift+Tab - go backwards
                        $nextIndex = ($currentIndex - 1 + $focusableNames.Count) % $focusableNames.Count
                    } else {
                        # Tab - go forwards
                        $nextIndex = ($currentIndex + 1) % $focusableNames.Count
                    }
                    
                    $self.FocusedComponentName = $focusableNames[$nextIndex]
                    
                    # Update engine focus
                    $focusedComponent = $self.Components[$self.FocusedComponentName]
                    if ($focusedComponent -and (Get-Command Set-ComponentFocus -ErrorAction SilentlyContinue)) {
                        Set-ComponentFocus -Component $focusedComponent
                    }
                    
                    Request-TuiRefresh
                }
                return $true
            }
            
            # Delegate to focused component
            $focusedComponent = if ($self.FocusedComponentName) { $self.Components[$self.FocusedComponentName] } else { $null }
            if ($focusedComponent -and $focusedComponent.HandleInput) {
                $result = & $focusedComponent.HandleInput -self $focusedComponent -Key $Key
                if ($result) {
                    Request-TuiRefresh
                    return $true
                }
            }
            
            return $false
        }
        
        OnExit = {
            param($self)
            Write-Log -Level Debug -Message "Demo screen exiting"
        }
    }
    
    return $screen
}

Export-ModuleMember -Function Get-DemoScreen
# Debug Log Screen
# Shows application log entries for debugging

function global:Get-DebugLogScreen {
    $screen = @{
        Name = "DebugLogScreen"
        
        State = @{
            logEntries = @()
            scrollOffset = 0
            selectedLine = 0
            filterLevel = "All"
            autoScroll = $true
            lastLogCount = 0
        }
        
        Components = @{}
        
        Init = {
            param($self)
            
            # Get initial log entries
            if (Get-Command Get-LogEntries -ErrorAction SilentlyContinue) {
                $self.State.logEntries = @(Get-LogEntries -Count 500)
                $self.State.lastLogCount = $self.State.logEntries.Count
            }
            
            # Auto-scroll to bottom
            if ($self.State.autoScroll -and $self.State.logEntries.Count -gt 0) {
                $visibleLines = $global:TuiState.BufferHeight - 8
                $self.State.scrollOffset = [Math]::Max(0, $self.State.logEntries.Count - $visibleLines)
                $self.State.selectedLine = $self.State.logEntries.Count - 1
            }
        }
        
        Render = {
            param($self)
            
            # Update log entries if new ones available
            if (Get-Command Get-LogEntries -ErrorAction SilentlyContinue) {
                $currentEntries = @(Get-LogEntries -Count 500)
                if ($currentEntries.Count -ne $self.State.lastLogCount) {
                    $self.State.logEntries = $currentEntries
                    $self.State.lastLogCount = $currentEntries.Count
                    
                    # Auto-scroll to bottom for new entries
                    if ($self.State.autoScroll) {
                        $visibleLines = $global:TuiState.BufferHeight - 8
                        $self.State.scrollOffset = [Math]::Max(0, $self.State.logEntries.Count - $visibleLines)
                        $self.State.selectedLine = $self.State.logEntries.Count - 1
                    }
                }
            }
            
            # Header
            $headerColor = Get-ThemeColor "Header"
            Write-BufferString -X 2 -Y 1 -Text "Debug Log Viewer" -ForegroundColor $headerColor
            Write-BufferString -X 30 -Y 1 -Text "Filter: $($self.State.filterLevel)" -ForegroundColor (Get-ThemeColor "Info")
            Write-BufferString -X 50 -Y 1 -Text "Auto-scroll: $($self.State.autoScroll)" -ForegroundColor (Get-ThemeColor "Success")
            
            # Main log area
            $logY = 3
            $logHeight = $global:TuiState.BufferHeight - 6
            Write-BufferBox -X 1 -Y 2 -Width ($global:TuiState.BufferWidth - 2) -Height ($logHeight + 2) `
                -Title " Log Entries ($($self.State.logEntries.Count)) " -BorderColor (Get-ThemeColor "Border")
            
            # Filter entries
            $filteredEntries = if ($self.State.filterLevel -eq "All") {
                $self.State.logEntries
            } else {
                $self.State.logEntries | Where-Object { $_.Level -eq $self.State.filterLevel }
            }
            
            # Display log entries
            $visibleStart = $self.State.scrollOffset
            $visibleEnd = [Math]::Min($filteredEntries.Count - 1, $visibleStart + $logHeight - 1)
            
            for ($i = $visibleStart; $i -le $visibleEnd; $i++) {
                $entry = $filteredEntries[$i]
                if (-not $entry) { continue }
                
                $y = $logY + ($i - $visibleStart)
                $isSelected = ($i -eq $self.State.selectedLine)
                
                # Level colors
                $levelColor = switch ($entry.Level) {
                    "Debug" { Get-ThemeColor "Subtle" }
                    "Verbose" { Get-ThemeColor "Secondary" }
                    "Info" { Get-ThemeColor "Primary" }
                    "Warning" { Get-ThemeColor "Warning" }
                    "Error" { Get-ThemeColor "Danger" }
                    default { Get-ThemeColor "Primary" }
                }
                
                # Background for selected line
                if ($isSelected) {
                    $bg = Get-ThemeColor "Accent"
                    Write-BufferString -X 2 -Y $y -Text (" " * ($global:TuiState.BufferWidth - 4)) -BackgroundColor $bg
                } else {
                    $bg = Get-ThemeColor "Background"
                }
                
                # Format log line
                $timestamp = if ($entry.Timestamp) { $entry.Timestamp } else { "" }
                $level = if ($entry.Level) { "[$($entry.Level.PadRight(7))]" } else { "[Unknown]" }
                $message = if ($entry.Message) { $entry.Message } else { "" }
                
                # Truncate message if too long
                $maxMessageLength = $global:TuiState.BufferWidth - 30
                if ($message.Length -gt $maxMessageLength) {
                    $message = $message.Substring(0, $maxMessageLength - 3) + "..."
                }
                
                # Write log entry
                Write-BufferString -X 2 -Y $y -Text $timestamp -ForegroundColor (Get-ThemeColor "Subtle") -BackgroundColor $bg
                Write-BufferString -X 25 -Y $y -Text $level -ForegroundColor $levelColor -BackgroundColor $bg
                Write-BufferString -X 35 -Y $y -Text $message -ForegroundColor (Get-ThemeColor "Primary") -BackgroundColor $bg
            }
            
            # Scrollbar
            if ($filteredEntries.Count -gt $logHeight) {
                $scrollbarHeight = $logHeight
                $scrollPos = if ($filteredEntries.Count -gt 1) {
                    [Math]::Floor(($self.State.scrollOffset / ($filteredEntries.Count - $logHeight)) * ($scrollbarHeight - 1))
                } else { 0 }
                
                for ($i = 0; $i -lt $scrollbarHeight; $i++) {
                    $char = if ($i -eq $scrollPos) { "█" } else { "│" }
                    $color = if ($i -eq $scrollPos) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Subtle" }
                    Write-BufferString -X ($global:TuiState.BufferWidth - 2) -Y ($logY + $i) -Text $char -ForegroundColor $color
                }
            }
            
            # Status bar
            $statusY = $global:TuiState.BufferHeight - 2
            Write-BufferString -X 2 -Y $statusY -Text "↑↓: Navigate • F: Filter • A: Auto-scroll • C: Clear • Esc: Back" `
                -ForegroundColor (Get-ThemeColor "Subtle")
            
            # Display selected entry details if available
            if ($isSelected -and $entry.Data) {
                $detailText = "Data: $($entry.Data | ConvertTo-Json -Compress)"
                if ($detailText.Length -gt ($global:TuiState.BufferWidth - 4)) {
                    $detailText = $detailText.Substring(0, $global:TuiState.BufferWidth - 7) + "..."
                }
                Write-BufferString -X 2 -Y ($statusY - 1) -Text $detailText -ForegroundColor (Get-ThemeColor "Info")
            }
        }
        
        HandleInput = {
            param($self, $Key)
            
            $filteredEntries = if ($self.State.filterLevel -eq "All") {
                $self.State.logEntries
            } else {
                $self.State.logEntries | Where-Object { $_.Level -eq $self.State.filterLevel }
            }
            
            $logHeight = $global:TuiState.BufferHeight - 8
            
            switch ($Key.Key) {
                ([ConsoleKey]::Escape) { return "Back" }
                ([ConsoleKey]::UpArrow) {
                    if ($self.State.selectedLine -gt 0) {
                        $self.State.selectedLine--
                        $self.State.autoScroll = $false
                        
                        # Adjust scroll if needed
                        if ($self.State.selectedLine -lt $self.State.scrollOffset) {
                            $self.State.scrollOffset = $self.State.selectedLine
                        }
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::DownArrow) {
                    if ($self.State.selectedLine -lt ($filteredEntries.Count - 1)) {
                        $self.State.selectedLine++
                        
                        # Re-enable auto-scroll if at bottom
                        if ($self.State.selectedLine -eq ($filteredEntries.Count - 1)) {
                            $self.State.autoScroll = $true
                        }
                        
                        # Adjust scroll if needed
                        if ($self.State.selectedLine -ge ($self.State.scrollOffset + $logHeight)) {
                            $self.State.scrollOffset = $self.State.selectedLine - $logHeight + 1
                        }
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::PageUp) {
                    $self.State.selectedLine = [Math]::Max(0, $self.State.selectedLine - $logHeight)
                    $self.State.scrollOffset = [Math]::Max(0, $self.State.scrollOffset - $logHeight)
                    $self.State.autoScroll = $false
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::PageDown) {
                    $maxLine = $filteredEntries.Count - 1
                    $self.State.selectedLine = [Math]::Min($maxLine, $self.State.selectedLine + $logHeight)
                    $self.State.scrollOffset = [Math]::Min([Math]::Max(0, $maxLine - $logHeight + 1), $self.State.scrollOffset + $logHeight)
                    
                    # Re-enable auto-scroll if at bottom
                    if ($self.State.selectedLine -eq $maxLine) {
                        $self.State.autoScroll = $true
                    }
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::Home) {
                    $self.State.selectedLine = 0
                    $self.State.scrollOffset = 0
                    $self.State.autoScroll = $false
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::End) {
                    $self.State.selectedLine = $filteredEntries.Count - 1
                    $self.State.scrollOffset = [Math]::Max(0, $filteredEntries.Count - $logHeight)
                    $self.State.autoScroll = $true
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::F) {
                    # Cycle through filter levels
                    $levels = @("All", "Debug", "Verbose", "Info", "Warning", "Error")
                    $currentIndex = [array]::IndexOf($levels, $self.State.filterLevel)
                    $self.State.filterLevel = $levels[($currentIndex + 1) % $levels.Count]
                    
                    # Reset selection
                    $self.State.selectedLine = 0
                    $self.State.scrollOffset = 0
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::A) {
                    # Toggle auto-scroll
                    $self.State.autoScroll = -not $self.State.autoScroll
                    if ($self.State.autoScroll) {
                        # Jump to bottom
                        $self.State.selectedLine = $filteredEntries.Count - 1
                        $self.State.scrollOffset = [Math]::Max(0, $filteredEntries.Count - $logHeight)
                    }
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::C) {
                    # Clear log
                    if (Get-Command Clear-LogQueue -ErrorAction SilentlyContinue) {
                        Clear-LogQueue
                        $self.State.logEntries = @()
                        $self.State.scrollOffset = 0
                        $self.State.selectedLine = 0
                        $self.State.lastLogCount = 0
                        Request-TuiRefresh
                    }
                    return $true
                }
            }
            
            return $false
        }
    }
    
    return $screen
}

Export-ModuleMember -Function Get-DebugLogScreen
# Timer Start Screen Module - COMPLIANT VERSION
# Simple screen for starting/stopping timers

function global:Get-TimerStartScreen {
    $screen = @{
        Name = "TimerStartScreen"
        
        # State
        State = @{
            ProjectKey = ""
            ProjectName = ""
            Description = ""
            ActiveTimer = $null
        }
        
        # Components
        Components = @{}
        FocusedComponentName = "projectButton"
        
        # Init
        Init = {
            param($self)
            
            # Calculate form position
            $formWidth = 50
            $formHeight = 15
            $formX = [Math]::Floor(($global:TuiState.BufferWidth - $formWidth) / 2)
            $formY = [Math]::Floor(($global:TuiState.BufferHeight - $formHeight) / 2)
            
            # Check if there's an active timer
            if ($global:Data -and $global:Data.ActiveTimers -and $global:Data.ActiveTimers.Count -gt 0) {
                $activeTimer = $global:Data.ActiveTimers.GetEnumerator() | Select-Object -First 1
                if ($activeTimer) {
                    $self.State.ActiveTimer = $activeTimer.Value
                    $self.State.ProjectKey = $activeTimer.Value.ProjectKey
                    if ($global:Data.Projects -and $global:Data.Projects[$self.State.ProjectKey]) {
                        $self.State.ProjectName = $global:Data.Projects[$self.State.ProjectKey].Name
                    }
                    $self.State.Description = $activeTimer.Value.Description
                }
            }
            
            # Project selection button
            $self.Components.projectButton = New-TuiButton -Props @{
                X = $formX + 15; Y = $formY + 3; Width = 30; Height = 3
                Text = if ($self.State.ProjectName) { $self.State.ProjectName } else { "[ Select Project ]" }
                OnClick = {
                    if ($self.State.ActiveTimer) { return } # Can't change project while timer is running
                    
                    if (Get-Command Show-ListDialog -ErrorAction SilentlyContinue) {
                        $projects = @()
                        if ($global:Data -and $global:Data.Projects) {
                            $projects = $global:Data.Projects.GetEnumerator() | ForEach-Object {
                                @{ Display = $_.Value.Name; Value = $_.Key }
                            } | Sort-Object Display
                        }
                        
                        if ($projects.Count -gt 0) {
                            Show-ListDialog -Title "Select Project" -Prompt "Choose a project:" -Items $projects -OnSelect {
                                param($item)
                                $self.State.ProjectKey = $item.Value
                                $self.State.ProjectName = $item.Display
                                $self.Components.projectButton.Text = $item.Display
                                Request-TuiRefresh
                            }
                        } else {
                            Show-AlertDialog -Title "No Projects" -Message "No projects available. Please create a project first."
                        }
                    }
                }
            }
            
            # Description input
            $self.Components.descriptionTextBox = New-TuiTextBox -Props @{
                X = $formX + 15; Y = $formY + 6; Width = 30; Height = 3
                Placeholder = "Task description..."
                Text = $self.State.Description
                OnChange = {
                    param($NewValue)
                    $self.State.Description = $NewValue
                }
            }
            
            # Timer display
            $self.Components.timerLabel = New-TuiLabel -Props @{
                X = $formX + 15; Y = $formY + 9
                Text = "00:00:00"
                ForegroundColor = if ($self.State.ActiveTimer) { [ConsoleColor]::Green } else { [ConsoleColor]::White }
            }
            
            # Start/Stop button
            $self.Components.actionButton = New-TuiButton -Props @{
                X = $formX + 15; Y = $formY + 11; Width = 20; Height = 3
                Text = if ($self.State.ActiveTimer) { "Stop Timer" } else { "Start Timer" }
                OnClick = {
                    if ($self.State.ActiveTimer) {
                        # Stop timer
                        $elapsed = (Get-Date) - [DateTime]$self.State.ActiveTimer.StartTime
                        $hours = [Math]::Round($elapsed.TotalHours, 2)
                        
                        # Create time entry
                        $timeEntry = @{
                            Id = [Guid]::NewGuid().ToString()
                            ProjectKey = $self.State.ActiveTimer.ProjectKey
                            Hours = $hours
                            Description = $self.State.ActiveTimer.Description
                            Date = (Get-Date).ToString("yyyy-MM-dd")
                            Created = Get-Date
                        }
                        
                        # Add to data
                        if ($global:Data) {
                            if (-not $global:Data.TimeEntries) {
                                $global:Data.TimeEntries = @()
                            }
                            $global:Data.TimeEntries += $timeEntry
                            
                            # Remove active timer
                            $global:Data.ActiveTimers.Remove($self.State.ActiveTimer.Id)
                            
                            # Save data
                            if (Get-Command Save-UnifiedData -ErrorAction SilentlyContinue) {
                                Save-UnifiedData -Data $global:Data
                            }
                        }
                        
                        # Reset state
                        $self.State.ActiveTimer = $null
                        $self.Components.actionButton.Text = "Start Timer"
                        $self.Components.timerLabel.ForegroundColor = [ConsoleColor]::White
                        
                        Show-AlertDialog -Title "Timer Stopped" -Message "Time entry created: $hours hours"
                        Request-TuiRefresh
                    } else {
                        # Start timer
                        if ([string]::IsNullOrEmpty($self.State.ProjectKey)) {
                            Show-AlertDialog -Title "Error" -Message "Please select a project first."
                            return
                        }
                        
                        $timer = @{
                            Id = [Guid]::NewGuid().ToString()
                            ProjectKey = $self.State.ProjectKey
                            Description = $self.State.Description
                            StartTime = Get-Date
                        }
                        
                        # Add to active timers
                        if ($global:Data) {
                            if (-not $global:Data.ActiveTimers) {
                                $global:Data.ActiveTimers = @{}
                            }
                            $global:Data.ActiveTimers[$timer.Id] = $timer
                            
                            # Save data
                            if (Get-Command Save-UnifiedData -ErrorAction SilentlyContinue) {
                                Save-UnifiedData -Data $global:Data
                            }
                        }
                        
                        $self.State.ActiveTimer = $timer
                        $self.Components.actionButton.Text = "Stop Timer"
                        $self.Components.timerLabel.ForegroundColor = [ConsoleColor]::Green
                        
                        Request-TuiRefresh
                    }
                }
            }
            
            # Labels
            $self.Components.projectLabel = New-TuiLabel -Props @{
                X = $formX + 3; Y = $formY + 4
                Text = "Project:"
            }
            
            $self.Components.descriptionLabel = New-TuiLabel -Props @{
                X = $formX + 3; Y = $formY + 7
                Text = "Description:"
            }
            
            # Update timer
            $self.UpdateTimer = {
                param($self)
                if ($self.State.ActiveTimer) {
                    $elapsed = (Get-Date) - [DateTime]$self.State.ActiveTimer.StartTime
                    $self.Components.timerLabel.Text = "{0:00}:{1:00}:{2:00}" -f [Math]::Floor($elapsed.TotalHours), $elapsed.Minutes, $elapsed.Seconds
                }
            }
        }
        
        # Render
        Render = {
            param($self)
            
            # Calculate form position
            $formWidth = 50
            $formHeight = 15
            $formX = [Math]::Floor(($global:TuiState.BufferWidth - $formWidth) / 2)
            $formY = [Math]::Floor(($global:TuiState.BufferHeight - $formHeight) / 2)
            
            # Draw form box
            Write-BufferBox -X $formX -Y $formY -Width $formWidth -Height $formHeight `
                -Title " Timer " -BorderColor (Get-ThemeColor "Accent")
            
            # Update timer display
            & $self.UpdateTimer $self
            
            # Render all components
            foreach ($kvp in $self.Components.GetEnumerator()) {
                $component = $kvp.Value
                if ($component -and $component.Visible -ne $false) {
                    # Set focus state
                    $component.IsFocused = ($self.FocusedComponentName -eq $kvp.Key)
                    if ($component.Render) {
                        & $component.Render -self $component
                    }
                }
            }
            
            # Status
            $statusY = $formY + $formHeight - 2
            if ($self.State.ActiveTimer) {
                Write-BufferString -X ($formX + 3) -Y $statusY -Text "Timer is running..." -ForegroundColor Green
            } else {
                Write-BufferString -X ($formX + 3) -Y $statusY -Text "Tab: Next Field • Enter: Action • Esc: Back" -ForegroundColor (Get-ThemeColor "Subtle")
            }
        }
        
        # HandleInput
        HandleInput = {
            param($self, $Key)
            
            # Global navigation
            switch ($Key.Key) {
                ([ConsoleKey]::Escape) { 
                    Pop-Screen
                    return $true 
                }
                ([ConsoleKey]::Tab) {
                    # Simple focus cycling
                    $focusable = @("projectButton", "descriptionTextBox", "actionButton")
                    $currentIndex = [array]::IndexOf($focusable, $self.FocusedComponentName)
                    if ($currentIndex -eq -1) { $currentIndex = 0 }
                    
                    $nextIndex = ($currentIndex + 1) % $focusable.Count
                    $self.FocusedComponentName = $focusable[$nextIndex]
                    Request-TuiRefresh
                    return $true
                }
            }
            
            # Delegate to focused component
            $focusedComponent = if ($self.FocusedComponentName) { $self.Components[$self.FocusedComponentName] } else { $null }
            if ($focusedComponent -and $focusedComponent.HandleInput) {
                $result = & $focusedComponent.HandleInput -self $focusedComponent -Key $Key
                if ($result) {
                    Request-TuiRefresh
                    return $true
                }
            }
            
            return $false
        }
    }
    
    return $screen
}

Export-ModuleMember -Function 'Get-TimerStartScreen'
# Timer Management Screen - STUB IMPLEMENTATION
# This is a placeholder screen that will be properly implemented later

function global:Get-TimerManagementScreen {
    $screen = @{
        Name = "TimerManagementScreen"
        
        # 1. State: Central data model for the screen
        State = @{
            message = "Timer Management - Coming Soon"
        }
        
        # 2. Components: Storage for instantiated component objects
        Components = @{}
        
        # 3. Init: One-time setup
        Init = {
            param($self)
            
            # Create a simple message label
            $self.Components.messageLabel = New-TuiLabel -Props @{
                X = 10
                Y = 10
                Text = "Timer Management Screen - Under Construction"
            }
            
            $self.Components.infoLabel = New-TuiLabel -Props @{
                X = 10
                Y = 12
                Text = "Manage running timers and timer history here."
            }
            
            $self.Components.backButton = New-TuiButton -Props @{
                X = 10
                Y = 15
                Width = 15
                Height = 3
                Text = "Go Back"
                OnClick = { Pop-Screen }
            }
            
            # Focus management
            $self.FocusedComponentName = 'backButton'
        }
        
        # 4. Render: Draw the screen and its components
        Render = {
            param($self)
            
            # Clear and draw header
            $headerColor = Get-ThemeColor "Header"
            Write-BufferString -X 2 -Y 1 -Text "Timer Management" -ForegroundColor $headerColor
            
            # Draw placeholder box
            Write-BufferBox -X 5 -Y 5 -Width 70 -Height 20 -Title " Timers " -BorderColor (Get-ThemeColor "Success")
            
            # Render components
            foreach ($kvp in $self.Components.GetEnumerator()) {
                $component = $kvp.Value
                if ($component -and $component.Visible -ne $false) {
                    # Set focus state
                    $component.IsFocused = ($self.FocusedComponentName -eq $kvp.Key)
                    if ($component.Render) {
                        & $component.Render -self $component
                    }
                }
            }
            
            # Status bar
            $statusY = $global:TuiState.BufferHeight - 2
            Write-BufferString -X 2 -Y $statusY -Text "Esc: Back to Dashboard" -ForegroundColor (Get-ThemeColor "Subtle")
        }
        
        # 5. HandleInput: Global input handling for the screen
        HandleInput = {
            param($self, $Key)
            
            # Screen-level shortcuts
            switch ($Key.Key) {
                ([ConsoleKey]::Escape) { return "Back" }
                ([ConsoleKey]::Q) { return "Back" }
            }
            
            # Delegate to focused component
            $focusedComponent = if ($self.FocusedComponentName) { $self.Components[$self.FocusedComponentName] } else { $null }
            if ($focusedComponent -and $focusedComponent.HandleInput) {
                $result = & $focusedComponent.HandleInput -self $focusedComponent -Key $Key
                if ($result) {
                    Request-TuiRefresh
                    return $true
                }
            }
            
            return $false
        }
    }
    
    return $screen
}

Export-ModuleMember -Function Get-TimerManagementScreen
# Settings Screen - STUB IMPLEMENTATION
# This is a placeholder screen that will be properly implemented later

function global:Get-SettingsScreen {
    $screen = @{
        Name = "SettingsScreen"
        
        # 1. State: Central data model for the screen
        State = @{
            message = "Settings - Coming Soon"
        }
        
        # 2. Components: Storage for instantiated component objects
        Components = @{}
        
        # 3. Init: One-time setup
        Init = {
            param($self)
            
            # Create a simple message label
            $self.Components.messageLabel = New-TuiLabel -Props @{
                X = 10
                Y = 10
                Text = "Settings Screen - Under Construction"
            }
            
            $self.Components.infoLabel = New-TuiLabel -Props @{
                X = 10
                Y = 12
                Text = "Application settings and preferences will be available here."
            }
            
            $self.Components.backButton = New-TuiButton -Props @{
                X = 10
                Y = 15
                Width = 15
                Height = 3
                Text = "Go Back"
                OnClick = { Pop-Screen }
            }
            
            # Focus management
            $self.FocusedComponentName = 'backButton'
        }
        
        # 4. Render: Draw the screen and its components
        Render = {
            param($self)
            
            # Clear and draw header
            $headerColor = Get-ThemeColor "Header"
            Write-BufferString -X 2 -Y 1 -Text "Settings" -ForegroundColor $headerColor
            
            # Draw placeholder box
            Write-BufferBox -X 5 -Y 5 -Width 70 -Height 20 -Title " Settings " -BorderColor (Get-ThemeColor "Info")
            
            # Render components
            foreach ($kvp in $self.Components.GetEnumerator()) {
                $component = $kvp.Value
                if ($component -and $component.Visible -ne $false) {
                    # Set focus state
                    $component.IsFocused = ($self.FocusedComponentName -eq $kvp.Key)
                    if ($component.Render) {
                        & $component.Render -self $component
                    }
                }
            }
            
            # Status bar
            $statusY = $global:TuiState.BufferHeight - 2
            Write-BufferString -X 2 -Y $statusY -Text "Esc: Back to Dashboard" -ForegroundColor (Get-ThemeColor "Subtle")
        }
        
        # 5. HandleInput: Global input handling for the screen
        HandleInput = {
            param($self, $Key)
            
            # Screen-level shortcuts
            switch ($Key.Key) {
                ([ConsoleKey]::Escape) { return "Back" }
                ([ConsoleKey]::Q) { return "Back" }
            }
            
            # Delegate to focused component
            $focusedComponent = if ($self.FocusedComponentName) { $self.Components[$self.FocusedComponentName] } else { $null }
            if ($focusedComponent -and $focusedComponent.HandleInput) {
                $result = & $focusedComponent.HandleInput -self $focusedComponent -Key $Key
                if ($result) {
                    Request-TuiRefresh
                    return $true
                }
            }
            
            return $false
        }
    }
    
    return $screen
}

Export-ModuleMember -Function Get-SettingsScreen
# Reports Screen - STUB IMPLEMENTATION
# This is a placeholder screen that will be properly implemented later

function global:Get-ReportsScreen {
    $screen = @{
        Name = "ReportsScreen"
        
        # 1. State: Central data model for the screen
        State = @{
            message = "Reports - Coming Soon"
        }
        
        # 2. Components: Storage for instantiated component objects
        Components = @{}
        
        # 3. Init: One-time setup
        Init = {
            param($self)
            
            # Create a simple message label
            $self.Components.messageLabel = New-TuiLabel -Props @{
                X = 10
                Y = 10
                Text = "Reports Screen - Under Construction"
            }
            
            $self.Components.infoLabel = New-TuiLabel -Props @{
                X = 10
                Y = 12
                Text = "Time tracking reports and analytics will be available here."
            }
            
            $self.Components.backButton = New-TuiButton -Props @{
                X = 10
                Y = 15
                Width = 15
                Height = 3
                Text = "Go Back"
                OnClick = { Pop-Screen }
            }
            
            # Focus management
            $self.FocusedComponentName = 'backButton'
        }
        
        # 4. Render: Draw the screen and its components
        Render = {
            param($self)
            
            # Clear and draw header
            $headerColor = Get-ThemeColor "Header"
            Write-BufferString -X 2 -Y 1 -Text "Reports" -ForegroundColor $headerColor
            
            # Draw placeholder box
            Write-BufferBox -X 5 -Y 5 -Width 70 -Height 20 -Title " Reports " -BorderColor (Get-ThemeColor "Warning")
            
            # Render components
            foreach ($kvp in $self.Components.GetEnumerator()) {
                $component = $kvp.Value
                if ($component -and $component.Visible -ne $false) {
                    # Set focus state
                    $component.IsFocused = ($self.FocusedComponentName -eq $kvp.Key)
                    if ($component.Render) {
                        & $component.Render -self $component
                    }
                }
            }
            
            # Status bar
            $statusY = $global:TuiState.BufferHeight - 2
            Write-BufferString -X 2 -Y $statusY -Text "Esc: Back to Dashboard" -ForegroundColor (Get-ThemeColor "Subtle")
        }
        
        # 5. HandleInput: Global input handling for the screen
        HandleInput = {
            param($self, $Key)
            
            # Screen-level shortcuts
            switch ($Key.Key) {
                ([ConsoleKey]::Escape) { return "Back" }
                ([ConsoleKey]::Q) { return "Back" }
            }
            
            # Delegate to focused component
            $focusedComponent = if ($self.FocusedComponentName) { $self.Components[$self.FocusedComponentName] } else { $null }
            if ($focusedComponent -and $focusedComponent.HandleInput) {
                $result = & $focusedComponent.HandleInput -self $focusedComponent -Key $Key
                if ($result) {
                    Request-TuiRefresh
                    return $true
                }
            }
            
            return $false
        }
    }
    
    return $screen
}

Export-ModuleMember -Function Get-ReportsScreen
# Project Management Screen - STUB IMPLEMENTATION
# This is a placeholder screen that will be properly implemented later

function global:Get-ProjectManagementScreen {
    $screen = @{
        Name = "ProjectManagementScreen"
        
        # 1. State: Central data model for the screen
        State = @{
            message = "Project Management - Coming Soon"
        }
        
        # 2. Components: Storage for instantiated component objects
        Components = @{}
        
        # 3. Init: One-time setup
        Init = {
            param($self)
            
            # Create a simple message label
            $self.Components.messageLabel = New-TuiLabel -Props @{
                X = 10
                Y = 10
                Text = "Project Management Screen - Under Construction"
            }
            
            $self.Components.backButton = New-TuiButton -Props @{
                X = 10
                Y = 15
                Width = 15
                Height = 3
                Text = "Go Back"
                OnClick = { Pop-Screen }
            }
            
            # Focus management
            $self.FocusedComponentName = 'backButton'
        }
        
        # 4. Render: Draw the screen and its components
        Render = {
            param($self)
            
            # Clear and draw header
            $headerColor = Get-ThemeColor "Header"
            Write-BufferString -X 2 -Y 1 -Text "Project Management" -ForegroundColor $headerColor
            
            # Draw placeholder box
            Write-BufferBox -X 5 -Y 5 -Width 70 -Height 20 -Title " Projects " -BorderColor (Get-ThemeColor "Accent")
            
            # Render components
            foreach ($kvp in $self.Components.GetEnumerator()) {
                $component = $kvp.Value
                if ($component -and $component.Visible -ne $false) {
                    # Set focus state
                    $component.IsFocused = ($self.FocusedComponentName -eq $kvp.Key)
                    if ($component.Render) {
                        & $component.Render -self $component
                    }
                }
            }
            
            # Status bar
            $statusY = $global:TuiState.BufferHeight - 2
            Write-BufferString -X 2 -Y $statusY -Text "Esc: Back to Dashboard" -ForegroundColor (Get-ThemeColor "Subtle")
        }
        
        # 5. HandleInput: Global input handling for the screen
        HandleInput = {
            param($self, $Key)
            
            # Screen-level shortcuts
            switch ($Key.Key) {
                ([ConsoleKey]::Escape) { return "Back" }
                ([ConsoleKey]::Q) { return "Back" }
            }
            
            # Delegate to focused component
            $focusedComponent = if ($self.FocusedComponentName) { $self.Components[$self.FocusedComponentName] } else { $null }
            if ($focusedComponent -and $focusedComponent.HandleInput) {
                $result = & $focusedComponent.HandleInput -self $focusedComponent -Key $Key
                if ($result) {
                    Request-TuiRefresh
                    return $true
                }
            }
            
            return $false
        }
    }
    
    return $screen
}

Export-ModuleMember -Function Get-ProjectManagementScreen
# Time Entry Form Screen Module - COMPLIANT VERSION
# Using programmatic pattern with component-based architecture

function global:Get-TimeEntryFormScreen {
    $screen = @{
        Name = "TimeEntryFormScreen"
        
        # 1. State: Central data model for the screen
        State = @{
            ProjectKey = ""
            ProjectName = ""
            Hours = ""
            Description = ""
            Date = (Get-Date).ToString("yyyy-MM-dd")
            ValidationErrors = @{}
        }
        
        # 2. Components: Storage for instantiated component objects
        Components = @{}
        
        # 3. Init: One-time setup
        Init = {
            param($self)
            
            # Pre-populate with project from context if available
            if ($script:ContextData -and $script:ContextData.ProjectKey) {
                $self.State.ProjectKey = $script:ContextData.ProjectKey
                # Try to get project name
                if ($global:Data -and $global:Data.Projects -and $global:Data.Projects[$self.State.ProjectKey]) {
                    $self.State.ProjectName = $global:Data.Projects[$self.State.ProjectKey].Name
                }
            }
            
            # Calculate form position
            $formWidth = 60
            $formHeight = 20
            $formX = [Math]::Floor(($global:TuiState.BufferWidth - $formWidth) / 2)
            $formY = [Math]::Floor(($global:TuiState.BufferHeight - $formHeight) / 2)
            
            # Project selection button
            $self.Components.projectButton = New-TuiButton -Props @{
                X = $formX + 21; Y = $formY + 3; Width = 30; Height = 3
                Text = if ($self.State.ProjectName) { $self.State.ProjectName } else { "[ Select Project ]" }
                OnClick = {
                    # Show project selector dialog
                    if (Get-Command Show-ListDialog -ErrorAction SilentlyContinue) {
                        # Get available projects
                        $projects = @()
                        if ($global:Data -and $global:Data.Projects) {
                            $projects = $global:Data.Projects.GetEnumerator() | ForEach-Object {
                                @{ Display = $_.Value.Name; Value = $_.Key }
                            } | Sort-Object Display
                        }
                        
                        if ($projects.Count -gt 0) {
                            Show-ListDialog -Title "Select Project" -Prompt "Choose a project:" -Items $projects -OnSelect {
                                param($item)
                                $self.State.ProjectKey = $item.Value
                                $self.State.ProjectName = $item.Display
                                $self.Components.projectButton.Text = $item.Display
                                Request-TuiRefresh
                            }
                        } else {
                            Show-AlertDialog -Title "No Projects" -Message "No projects available. Please create a project first."
                        }
                    }
                }
            }
            
            # Hours input
            $self.Components.hoursTextBox = New-TuiTextBox -Props @{
                X = $formX + 21; Y = $formY + 6; Width = 20; Height = 3
                Placeholder = "0.0"
                Text = $self.State.Hours
                OnChange = {
                    param($NewValue)
                    $self.State.Hours = $NewValue
                    # Clear validation error when user types
                    if ($self.State.ValidationErrors.Hours) {
                        $self.State.ValidationErrors.Remove("Hours")
                    }
                }
            }
            
            # Description input
            $self.Components.descriptionTextArea = New-TuiTextArea -Props @{
                X = $formX + 21; Y = $formY + 9; Width = 35; Height = 4
                Placeholder = "What did you work on?"
                Text = $self.State.Description
                OnChange = {
                    param($NewValue)
                    $self.State.Description = $NewValue
                }
            }
            
            # Date input
            $self.Components.datePicker = New-TuiDatePicker -Props @{
                X = $formX + 21; Y = $formY + 13; Width = 20; Height = 3
                Value = [DateTime]::Parse($self.State.Date)
                Format = "yyyy-MM-dd"
                OnChange = {
                    param($NewValue)
                    $self.State.Date = $NewValue.ToString("yyyy-MM-dd")
                }
            }
            
            # Submit button
            $self.Components.submitButton = New-TuiButton -Props @{
                X = $formX + 15; Y = $formY + 17; Width = 12; Height = 3
                Text = "Submit"
                OnClick = {
                    # Validate form
                    $self.State.ValidationErrors = @{}
                    $isValid = $true
                    
                    # Validate project
                    if ([string]::IsNullOrEmpty($self.State.ProjectKey)) {
                        $self.State.ValidationErrors.Project = "Project is required"
                        $isValid = $false
                    }
                    
                    # Validate hours
                    $hours = 0.0
                    if (-not [double]::TryParse($self.State.Hours, [ref]$hours) -or $hours -le 0) {
                        $self.State.ValidationErrors.Hours = "Valid hours required (e.g., 2.5)"
                        $self.FocusedComponentName = "hoursTextBox"
                        $isValid = $false
                    }
                    
                    if ($isValid) {
                        # Create time entry
                        $timeEntry = @{
                            Id = [Guid]::NewGuid().ToString()
                            ProjectKey = $self.State.ProjectKey
                            Hours = $hours
                            Description = $self.State.Description
                            Date = $self.State.Date
                            Created = Get-Date
                        }
                        
                        # Add to data
                        if ($global:Data) {
                            if (-not $global:Data.TimeEntries) {
                                $global:Data.TimeEntries = @()
                            }
                            $global:Data.TimeEntries += $timeEntry
                            
                            # Save data
                            if (Get-Command Save-UnifiedData -ErrorAction SilentlyContinue) {
                                Save-UnifiedData -Data $global:Data
                            }
                        }
                        
                        # Publish event
                        if (Get-Command Publish-Event -ErrorAction SilentlyContinue) {
                            Publish-Event -EventName "Data.Create.TimeEntry" -Data $timeEntry
                        }
                        
                        # Show success and go back
                        if (Get-Command Show-AlertDialog -ErrorAction SilentlyContinue) {
                            Show-AlertDialog -Title "Success" -Message "Time entry added successfully!"
                        }
                        
                        Pop-Screen
                    } else {
                        Request-TuiRefresh
                    }
                }
            }
            
            # Cancel button
            $self.Components.cancelButton = New-TuiButton -Props @{
                X = $formX + 30; Y = $formY + 17; Width = 12; Height = 3
                Text = "Cancel"
                OnClick = { Pop-Screen }
            }
            
            # Labels
            $self.Components.projectLabel = New-TuiLabel -Props @{
                X = $formX + 3; Y = $formY + 4
                Text = "Project/Template:"
            }
            
            $self.Components.hoursLabel = New-TuiLabel -Props @{
                X = $formX + 3; Y = $formY + 7
                Text = "Hours:"
            }
            
            $self.Components.descriptionLabel = New-TuiLabel -Props @{
                X = $formX + 3; Y = $formY + 10
                Text = "Description:"
            }
            
            $self.Components.dateLabel = New-TuiLabel -Props @{
                X = $formX + 3; Y = $formY + 14
                Text = "Date:"
            }
            
            # Error labels
            $self.Components.projectError = New-TuiLabel -Props @{
                X = $formX + 21; Y = $formY + 5
                Text = ""
                ForegroundColor = [ConsoleColor]::Red
            }
            
            $self.Components.hoursError = New-TuiLabel -Props @{
                X = $formX + 21; Y = $formY + 8
                Text = ""
                ForegroundColor = [ConsoleColor]::Red
            }
            
            # Focus management
            $self.FocusableComponents = @("projectButton", "hoursTextBox", "descriptionTextArea", "datePicker", "submitButton", "cancelButton")
            $self.FocusedComponentName = if ($self.State.ProjectKey) { "hoursTextBox" } else { "projectButton" }
        }
        
        # 4. Render: Draw the screen and its components
        Render = {
            param($self)
            
            # Calculate form position
            $formWidth = 60
            $formHeight = 20
            $formX = [Math]::Floor(($global:TuiState.BufferWidth - $formWidth) / 2)
            $formY = [Math]::Floor(($global:TuiState.BufferHeight - $formHeight) / 2)
            
            # Draw form box
            Write-BufferBox -X $formX -Y $formY -Width $formWidth -Height $formHeight `
                -Title " Add Time Entry " -BorderColor (Get-ThemeColor "Accent")
            
            # Update error visibility
            if ($self.State.ValidationErrors.Project) {
                $self.Components.projectError.Text = $self.State.ValidationErrors.Project
            } else {
                $self.Components.projectError.Text = ""
            }
            
            if ($self.State.ValidationErrors.Hours) {
                $self.Components.hoursError.Text = $self.State.ValidationErrors.Hours
            } else {
                $self.Components.hoursError.Text = ""
            }
            
            # Render all components
            foreach ($kvp in $self.Components.GetEnumerator()) {
                $component = $kvp.Value
                if ($component -and $component.Visible -ne $false) {
                    # Set focus state
                    $component.IsFocused = ($self.FocusedComponentName -eq $kvp.Key)
                    if ($component.Render) {
                        & $component.Render -self $component
                    }
                }
            }
            
            # Instructions
            Write-BufferString -X ($formX + 3) -Y ($formY + $formHeight - 2) `
                -Text "Tab: Next Field • Enter: Submit • Esc: Cancel" `
                -ForegroundColor (Get-ThemeColor "Subtle")
        }
        
        # 5. HandleInput: Global input handling for the screen
        HandleInput = {
            param($self, $Key)
            
            # Global navigation
            switch ($Key.Key) {
                ([ConsoleKey]::Escape) { 
                    Pop-Screen
                    return $true 
                }
                ([ConsoleKey]::Tab) {
                    # Cycle through focusable components
                    $currentIndex = [array]::IndexOf($self.FocusableComponents, $self.FocusedComponentName)
                    if ($currentIndex -eq -1) { $currentIndex = 0 }
                    
                    $direction = if ($Key.Modifiers -band [ConsoleModifiers]::Shift) { -1 } else { 1 }
                    $nextIndex = ($currentIndex + $direction + $self.FocusableComponents.Count) % $self.FocusableComponents.Count
                    $self.FocusedComponentName = $self.FocusableComponents[$nextIndex]
                    Request-TuiRefresh
                    return $true
                }
            }
            
            # Delegate to focused component
            $focusedComponent = if ($self.FocusedComponentName) { $self.Components[$self.FocusedComponentName] } else { $null }
            if ($focusedComponent -and $focusedComponent.HandleInput) {
                $result = & $focusedComponent.HandleInput -self $focusedComponent -Key $Key
                if ($result) {
                    Request-TuiRefresh
                    return $true
                }
            }
            
            return $false
        }
    }
    
    return $screen
}

# Export module members
Export-ModuleMember -Function 'Get-TimeEntryFormScreen'
# Simple Logger Module for PMC Terminal
# Provides basic logging functionality

$script:LogPath = $null
$script:LogLevel = "Info"
$script:LogQueue = @()
$script:MaxLogSize = 1MB
$script:LogInitialized = $false

function global:Initialize-Logger {
    param(
        [string]$LogDirectory = (Join-Path $env:TEMP "PMCTerminal"),
        [string]$LogFileName = "pmc_terminal_{0:yyyy-MM-dd}.log" -f (Get-Date),
        [string]$Level = "Info"
    )
    
    try {
        # Create log directory if it doesn't exist
        if (-not (Test-Path $LogDirectory)) {
            New-Item -ItemType Directory -Path $LogDirectory -Force | Out-Null
        }
        
        $script:LogPath = Join-Path $LogDirectory $LogFileName
        $script:LogLevel = $Level
        $script:LogInitialized = $true
        
        # Write initialization message
        Write-Log -Level Info -Message "Logger initialized at $($script:LogPath)"
        
    } catch {
        Write-Warning "Failed to initialize logger: $_"
        $script:LogInitialized = $false
    }
}

function global:Write-Log {
    param(
        [ValidateSet("Debug", "Verbose", "Info", "Warning", "Error")]
        [string]$Level = "Info",
        [Parameter(Mandatory)]
        [string]$Message,
        [object]$Data = $null
    )
    
    # Skip if logger not initialized or if level is below threshold
    if (-not $script:LogInitialized) { return }
    
    $levelPriority = @{
        Debug = 0
        Verbose = 1
        Info = 2
        Warning = 3
        Error = 4
    }
    
    if ($levelPriority[$Level] -lt $levelPriority[$script:LogLevel]) { return }
    
    try {
        $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss.fff"
        $logEntry = "$timestamp [$Level] $Message"
        
        if ($Data) {
            $dataStr = if ($Data -is [Exception]) {
                "`n  Exception: $($Data.Message)`n  StackTrace: $($Data.StackTrace)"
            } else {
                "`n  Data: $($Data | ConvertTo-Json -Compress -Depth 2)"
            }
            $logEntry += $dataStr
        }
        
        # Add to in-memory queue (for debug screen)
        $script:LogQueue += @{
            Timestamp = $timestamp
            Level = $Level
            Message = $Message
            Data = $Data
        }
        
        # Keep only last 1000 entries in memory
        if ($script:LogQueue.Count -gt 1000) {
            $script:LogQueue = $script:LogQueue[-1000..-1]
        }
        
        # Write to file
        if ($script:LogPath) {
            # Check file size and rotate if needed
            if ((Test-Path $script:LogPath) -and (Get-Item $script:LogPath).Length -gt $script:MaxLogSize) {
                $archivePath = $script:LogPath -replace '\.log$', "_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"
                Move-Item $script:LogPath $archivePath -Force
            }
            
            Add-Content -Path $script:LogPath -Value $logEntry -Encoding UTF8
        }
        
    } catch {
        # Silently fail - we don't want logging errors to break the application
    }
}

function global:Get-LogEntries {
    param(
        [int]$Count = 100,
        [string]$Level = $null
    )
    
    $entries = $script:LogQueue
    
    if ($Level) {
        $entries = $entries | Where-Object { $_.Level -eq $Level }
    }
    
    return $entries | Select-Object -Last $Count
}

function global:Clear-LogQueue {
    $script:LogQueue = @()
}

function global:Set-LogLevel {
    param(
        [ValidateSet("Debug", "Verbose", "Info", "Warning", "Error")]
        [string]$Level
    )
    
    $script:LogLevel = $Level
    Write-Log -Level Info -Message "Log level changed to $Level"
}

function global:Get-LogPath {
    return $script:LogPath
}

Export-ModuleMember -Function @(
    'Initialize-Logger',
    'Write-Log',
    'Get-LogEntries',
    'Clear-LogQueue',
    'Set-LogLevel',
    'Get-LogPath'
)
# Data Manager Module
# Unified data persistence and CRUD operations with event integration

$script:Data = @{
    Projects = @{}
    Tasks = @()
    TimeEntries = @()
    ActiveTimers = @{}
    TodoTemplates = @{}
    Settings = @{
        DefaultView = "Dashboard"
        Theme = "Modern"
        AutoSave = $true
        BackupCount = 5
    }
}

$script:DataPath = Join-Path ([Environment]::GetFolderPath("LocalApplicationData")) "PMCTerminal\pmc-data.json"
$script:BackupPath = Join-Path ([Environment]::GetFolderPath("LocalApplicationData")) "PMCTerminal\backups"
$script:LastSaveTime = $null
$script:DataModified = $false

function global:Initialize-DataManager {
    <#
    .SYNOPSIS
    Initializes the data management system
    #>
    
    # Ensure data directory exists
    $dataDir = Split-Path $script:DataPath -Parent
    if (-not (Test-Path $dataDir)) {
        New-Item -ItemType Directory -Path $dataDir -Force | Out-Null
    }
    
    # Ensure backup directory exists
    if (-not (Test-Path $script:BackupPath)) {
        New-Item -ItemType Directory -Path $script:BackupPath -Force | Out-Null
    }
    
    # Initialize event handlers
    Initialize-DataEventHandlers
    
    # Make data globally accessible
    $global:Data = $script:Data
    
    Write-Verbose "Data manager initialized"
}

function global:Load-UnifiedData {
    <#
    .SYNOPSIS
    Loads data from the persistent storage
    #>
    
    if (Test-Path $script:DataPath) {
        try {
            $jsonContent = Get-Content $script:DataPath -Raw
            # Use -Depth to ensure deeply nested objects are properly deserialized
            $loadedData = $jsonContent | ConvertFrom-Json -AsHashtable -Depth 20
            
            # Merge with default structure to ensure all keys exist
            foreach ($key in $loadedData.Keys) {
                $script:Data[$key] = $loadedData[$key]
            }
            
            $script:LastSaveTime = (Get-Item $script:DataPath).LastWriteTime
            Write-Verbose "Data loaded from $script:DataPath"
            
            # Publish event
            Publish-Event -EventName "Data.Loaded" -Data @{ 
                Path = $script:DataPath
                ItemCount = @{
                    Projects = $script:Data.Projects.Count
                    Tasks = $script:Data.Tasks.Count
                    TimeEntries = $script:Data.TimeEntries.Count
                    ActiveTimers = $script:Data.ActiveTimers.Count
                }
            }
        } catch {
            Write-Warning "Failed to load data: $_"
            Write-Warning "Using default data structure"
        }
    } else {
        Write-Verbose "No existing data file found at $script:DataPath"
        # Initialize with sample data
        Initialize-SampleData
    }
    
    # Sync global variable
    $global:Data = $script:Data
}

function global:Save-UnifiedData {
    <#
    .SYNOPSIS
    Saves data to persistent storage with backup
    #>
    
    try {
        # Create backup if file exists
        if (Test-Path $script:DataPath) {
            $backupName = "pmc-data_$(Get-Date -Format 'yyyyMMdd_HHmmss').json"
            $backupFile = Join-Path $script:BackupPath $backupName
            Copy-Item $script:DataPath $backupFile -Force
            
            # Clean old backups
            $backups = Get-ChildItem $script:BackupPath -Filter "pmc-data_*.json" | 
                       Sort-Object LastWriteTime -Descending
            
            if ($backups.Count -gt $script:Data.Settings.BackupCount) {
                $backups | Select-Object -Skip $script:Data.Settings.BackupCount | 
                          Remove-Item -Force
            }
        }
        
        # Save data with increased depth to handle nested objects
        # Use -Compress to reduce file size and -WarningAction to suppress depth warnings
        $jsonContent = $script:Data | ConvertTo-Json -Depth 20 -Compress -WarningAction SilentlyContinue
        Set-Content -Path $script:DataPath -Value $jsonContent -Force
        
        $script:LastSaveTime = Get-Date
        $script:DataModified = $false
        
        Write-Verbose "Data saved to $script:DataPath"
        
        # Publish event
        Publish-Event -EventName "Data.Saved" -Data @{ Path = $script:DataPath }
        
    } catch {
        Write-Error "Failed to save data: $_"
        Publish-Event -EventName "Data.SaveError" -Data @{ Error = $_.ToString() }
    }
}

function global:Initialize-DataEventHandlers {
    <#
    .SYNOPSIS
    Sets up event handlers for data operations
    #>
    
    # Time Entry Creation
    $null = Subscribe-Event -EventName "Data.Create.TimeEntry" -Handler {
        param($EventData)
        $data = $EventData.Data
        
        try {
            # Validate required fields
            if (-not $data.Project) { throw "Project is required" }
            if (-not $data.Hours -or $data.Hours -le 0) { throw "Valid hours required" }
            
            $newEntry = @{
                Id = New-Guid
                ProjectKey = $data.Project
                Hours = [double]$data.Hours
                Description = if ($data.Description) { $data.Description } else { "" }
                Date = if ($data.Date) { $data.Date } else { (Get-Date).ToString("yyyy-MM-dd") }
                EnteredAt = (Get-Date).ToString("o")
                TaskId = $data.TaskId
            }
            
            $script:Data.TimeEntries += $newEntry
            $script:DataModified = $true
            
            if ($script:Data.Settings.AutoSave) {
                Save-UnifiedData
            }
            
            Publish-Event -EventName "Notification.Show" -Data @{ 
                Text = "Time entry saved: $($data.Hours)h for $($data.Project)"
                Type = "Success" 
            }
            
            Publish-Event -EventName "Data.TimeEntry.Created" -Data @{ Entry = $newEntry }
            
        } catch {
            Publish-Event -EventName "Notification.Show" -Data @{ 
                Text = "Failed to create time entry: $_"
                Type = "Error" 
            }
        }
    }
    
    # Project Creation
    $null = Subscribe-Event -EventName "Data.Create.Project" -Handler {
        param($EventData)
        $data = $EventData.Data
        
        try {
            if (-not $data.Key) { throw "Project key is required" }
            if (-not $data.Name) { throw "Project name is required" }
            
            if ($script:Data.Projects.ContainsKey($data.Key)) {
                throw "Project key '$($data.Key)' already exists"
            }
            
            $newProject = @{
                Key = $data.Key
                Name = $data.Name
                Client = if ($data.Client) { $data.Client } else { "" }
                BillingType = if ($data.BillingType) { $data.BillingType } else { "NonBillable" }
                Rate = [double](if ($data.Rate) { $data.Rate } else { 0 })
                Budget = [double](if ($data.Budget) { $data.Budget } else { 0 })
                Id1 = if ($data.Id1) { $data.Id1 } else { "" }
                Id2 = if ($data.Id2) { $data.Id2 } else { "" }
                CreatedAt = (Get-Date).ToString("o")
                Active = $true
            }
            
            $script:Data.Projects[$data.Key] = $newProject
            $script:DataModified = $true
            
            if ($script:Data.Settings.AutoSave) {
                Save-UnifiedData
            }
            
            Publish-Event -EventName "Notification.Show" -Data @{ 
                Text = "Project created: $($data.Name)"
                Type = "Success" 
            }
            
            Publish-Event -EventName "Data.Project.Created" -Data @{ Project = $newProject }
            
        } catch {
            Publish-Event -EventName "Notification.Show" -Data @{ 
                Text = "Failed to create project: $_"
                Type = "Error" 
            }
        }
    }
    
    # Task Creation
    $null = Subscribe-Event -EventName "Data.Create.Task" -Handler {
        param($EventData)
        $data = $EventData.Data
        
        try {
            if (-not $data.Description) { throw "Task description is required" }
            
            $newTask = @{
                Id = New-Guid
                Description = $data.Description
                ProjectKey = $data.ProjectKey
                Priority = if ($data.Priority) { $data.Priority } else { "Medium" }
                DueDate = $data.DueDate
                Tags = @(if ($data.Tags) { $data.Tags } else { @() })
                Completed = $false
                CreatedAt = (Get-Date).ToString("o")
                Progress = 0
            }
            
            $script:Data.Tasks += $newTask
            $script:DataModified = $true
            
            if ($script:Data.Settings.AutoSave) {
                Save-UnifiedData
            }
            
            Publish-Event -EventName "Notification.Show" -Data @{ 
                Text = "Task created: $($data.Description)"
                Type = "Success" 
            }
            
            Publish-Event -EventName "Data.Task.Created" -Data @{ Task = $newTask }
            
        } catch {
            Publish-Event -EventName "Notification.Show" -Data @{ 
                Text = "Failed to create task: $_"
                Type = "Error" 
            }
        }
    }
    
    # Timer Start
    $null = Subscribe-Event -EventName "Data.Timer.Start" -Handler {
        param($EventData)
        $data = $EventData.Data
        
        try {
            if (-not $data.ProjectKey) { throw "Project is required to start timer" }
            
            $timerKey = "$($data.ProjectKey)_$(Get-Date -Format 'yyyyMMddHHmmss')"
            
            $newTimer = @{
                Key = $timerKey
                ProjectKey = $data.ProjectKey
                TaskId = $data.TaskId
                Description = if ($data.Description) { $data.Description } else { "" }
                StartTime = (Get-Date).ToString("o")
            }
            
            $script:Data.ActiveTimers[$timerKey] = $newTimer
            $script:DataModified = $true
            
            if ($script:Data.Settings.AutoSave) {
                Save-UnifiedData
            }
            
            $project = $script:Data.Projects[$data.ProjectKey]
            Publish-Event -EventName "Notification.Show" -Data @{ 
                Text = "Timer started for: $($project.Name)"
                Type = "Success" 
            }
            
            Publish-Event -EventName "Data.Timer.Started" -Data @{ Timer = $newTimer }
            
        } catch {
            Publish-Event -EventName "Notification.Show" -Data @{ 
                Text = "Failed to start timer: $_"
                Type = "Error" 
            }
        }
    }
    
    # Timer Stop
    $null = Subscribe-Event -EventName "Data.Timer.Stop" -Handler {
        param($EventData)
        $data = $EventData.Data
        
        try {
            if (-not $data.TimerKey) { throw "Timer key is required" }
            
            if (-not $script:Data.ActiveTimers.ContainsKey($data.TimerKey)) {
                throw "Timer not found: $($data.TimerKey)"
            }
            
            $timer = $script:Data.ActiveTimers[$data.TimerKey]
            $startTime = [DateTime]$timer.StartTime
            $elapsed = (Get-Date) - $startTime
            
            # Create time entry from timer
            $timeEntry = @{
                Id = New-Guid
                ProjectKey = $timer.ProjectKey
                Hours = [Math]::Round($elapsed.TotalHours, 2)
                Description = $timer.Description
                Date = $startTime.ToString("yyyy-MM-dd")
                EnteredAt = (Get-Date).ToString("o")
                TaskId = $timer.TaskId
                FromTimer = $true
            }
            
            $script:Data.TimeEntries += $timeEntry
            $script:Data.ActiveTimers.Remove($data.TimerKey)
            $script:DataModified = $true
            
            if ($script:Data.Settings.AutoSave) {
                Save-UnifiedData
            }
            
            Publish-Event -EventName "Notification.Show" -Data @{ 
                Text = "Timer stopped: $([Math]::Round($elapsed.TotalHours, 2))h recorded"
                Type = "Success" 
            }
            
            Publish-Event -EventName "Data.Timer.Stopped" -Data @{ 
                Timer = $timer
                TimeEntry = $timeEntry 
            }
            
        } catch {
            Publish-Event -EventName "Notification.Show" -Data @{ 
                Text = "Failed to stop timer: $_"
                Type = "Error" 
            }
        }
    }
    
    # Stop All Timers
    $null = Subscribe-Event -EventName "Data.Timer.StopAll" -Handler {
        param($EventData)
        
        $timerKeys = @($script:Data.ActiveTimers.Keys)
        foreach ($timerKey in $timerKeys) {
            Publish-Event -EventName "Data.Timer.Stop" -Data @{ TimerKey = $timerKey }
        }
    }
}

function global:Get-ProjectOrTemplate {
    <#
    .SYNOPSIS
    Gets a project or template by key
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$Key
    )
    
    if ($script:Data.Projects.ContainsKey($Key)) {
        return $script:Data.Projects[$Key]
    } elseif ($script:Data.TodoTemplates.ContainsKey($Key)) {
        return $script:Data.TodoTemplates[$Key]
    } else {
        return @{ 
            Key = $Key
            Name = $Key
            Client = ""
            BillingType = "NonBillable"
            Rate = 0
        }
    }
}

function global:New-Guid {
    <#
    .SYNOPSIS
    Generates a new unique identifier
    #>
    return [Guid]::NewGuid().ToString()
}

function Initialize-SampleData {
    <#
    .SYNOPSIS
    Initializes sample data for first-time users
    #>
    
    # Sample projects
    $script:Data.Projects["INTERNAL"] = @{
        Key = "INTERNAL"
        Name = "Internal Work"
        Client = "Company"
        BillingType = "NonBillable"
        Rate = 0
        Budget = 0
        Active = $true
        CreatedAt = (Get-Date).ToString("o")
    }
    
    $script:Data.Projects["SAMPLE"] = @{
        Key = "SAMPLE"
        Name = "Sample Project"
        Client = "Sample Client"
        BillingType = "Billable"
        Rate = 100
        Budget = 10000
        Active = $true
        CreatedAt = (Get-Date).ToString("o")
    }
    
    # Sample todo templates
    $script:Data.TodoTemplates["PERSONAL"] = @{
        Key = "PERSONAL"
        Name = "Personal Tasks"
        Client = ""
        BillingType = "NonBillable"
        Rate = 0
        IsTemplate = $true
    }
    
    Write-Verbose "Sample data initialized"
}

# Helper function to get week dates
function global:Get-WeekDates {
    param([DateTime]$Date)
    
    $monday = $Date.AddDays(1 - [int]$Date.DayOfWeek)
    if ($Date.DayOfWeek -eq [DayOfWeek]::Sunday) {
        $monday = $monday.AddDays(-7)
    }
    
    return @(
        @{ Name = "Monday"; Date = $monday.Date }
        @{ Name = "Tuesday"; Date = $monday.AddDays(1).Date }
        @{ Name = "Wednesday"; Date = $monday.AddDays(2).Date }
        @{ Name = "Thursday"; Date = $monday.AddDays(3).Date }
        @{ Name = "Friday"; Date = $monday.AddDays(4).Date }
    )
}

function global:Get-WeekStart {
    param([DateTime]$Date)
    
    $monday = $Date.AddDays(1 - [int]$Date.DayOfWeek)
    if ($Date.DayOfWeek -eq [DayOfWeek]::Sunday) {
        $monday = $monday.AddDays(-7)
    }
    
    return $monday.Date
}

# Export functions
Export-ModuleMember -Function @(
    'Initialize-DataManager',
    'Load-UnifiedData',
    'Save-UnifiedData',
    'Initialize-DataEventHandlers',
    'Get-ProjectOrTemplate',
    'New-Guid',
    'Get-WeekDates',
    'Get-WeekStart'
) -Variable @('Data')

# Dialog System Module - FIXED VERSION
# Uses engine's word wrap helper and respects the framework

$script:DialogState = @{
    CurrentDialog = $null
    DialogStack   = [System.Collections.Stack]::new()
}

#region --- Public API & Factory Functions ---

function global:Show-TuiDialog {
    <# .SYNOPSIS Internal function to display a dialog component. #>
    param([hashtable]$DialogComponent)
    
    if ($script:DialogState.CurrentDialog) {
        $script:DialogState.DialogStack.Push($script:DialogState.CurrentDialog)
    }
    $script:DialogState.CurrentDialog = $DialogComponent
    Request-TuiRefresh
}

function global:Close-TuiDialog {
    <# .SYNOPSIS Closes the current dialog and restores the previous one, if any. #>
    if ($script:DialogState.DialogStack.Count -gt 0) {
        $script:DialogState.CurrentDialog = $script:DialogState.DialogStack.Pop()
    } else {
        $script:DialogState.CurrentDialog = $null
    }
    Request-TuiRefresh
}

function global:Show-ConfirmDialog {
    <# .SYNOPSIS Displays a standard Yes/No confirmation dialog. #>
    param(
        [string]$Title = "Confirm",
        [string]$Message,
        [scriptblock]$OnConfirm,
        [scriptblock]$OnCancel = {}
    )
    
    $dialog = New-TuiDialog -Props @{
        Title         = $Title
        Message       = $Message
        Buttons       = @("Yes", "No")
        Width         = [Math]::Min(80, [Math]::Max(50, $Message.Length + 10))
        Height        = 10
        OnButtonClick = {
            param($Button, $Index)
            Close-TuiDialog
            if ($Index -eq 0) { & $OnConfirm } else { & $OnCancel }
        }
        OnCancel      = { Close-TuiDialog; & $OnCancel }
    }
    Show-TuiDialog -DialogComponent $dialog
}

function global:Show-AlertDialog {
    <# .SYNOPSIS Displays a simple alert with an OK button. #>
    param(
        [string]$Title = "Alert",
        [string]$Message
    )
    
    $dialog = New-TuiDialog -Props @{
        Title         = $Title
        Message       = $Message
        Buttons       = @("OK")
        Width         = [Math]::Min(80, [Math]::Max(40, $Message.Length + 10))
        Height        = 10
        OnButtonClick = { Close-TuiDialog }
        OnCancel      = { Close-TuiDialog }
    }
    Show-TuiDialog -DialogComponent $dialog
}

function global:Show-InputDialog {
    <# .SYNOPSIS Displays a dialog to get text input from the user. #>
    param(
        [string]$Title = "Input",
        [string]$Prompt,
        [string]$DefaultValue = "",
        [scriptblock]$OnSubmit,
        [scriptblock]$OnCancel = {}
    )

    # Create a screen that contains the input components
    $inputScreen = @{
        Name = "InputDialog"
        State = @{
            InputValue = $DefaultValue
            FocusedIndex = 0  # Start with textbox focused
        }
        _focusableNames = @("InputTextBox", "OKButton", "CancelButton")
        _focusedIndex = 0
        
        Render = {
            param($self)
            
            # Calculate dialog dimensions
            $dialogWidth = [Math]::Min(70, [Math]::Max(50, $Prompt.Length + 10))
            $dialogHeight = 10
            $dialogX = [Math]::Floor(($global:TuiState.BufferWidth - $dialogWidth) / 2)
            $dialogY = [Math]::Floor(($global:TuiState.BufferHeight - $dialogHeight) / 2)
            
            # Draw dialog box
            Write-BufferBox -X $dialogX -Y $dialogY -Width $dialogWidth -Height $dialogHeight `
                -Title " $Title " -BorderColor (Get-ThemeColor "Accent")
            
            # Draw prompt
            $promptX = $dialogX + 2
            $promptY = $dialogY + 2
            Write-BufferString -X $promptX -Y $promptY -Text $Prompt
            
            # Draw text input
            $inputY = $promptY + 2
            $inputWidth = $dialogWidth - 4
            $isFocused = ($self._focusedIndex -eq 0)
            $borderColor = if ($isFocused) { Get-ThemeColor "Warning" } else { Get-ThemeColor "Primary" }
            
            Write-BufferBox -X $promptX -Y $inputY -Width $inputWidth -Height 3 `
                -BorderColor $borderColor
            
            # Draw input value
            $displayText = $self.State.InputValue
            if ($displayText.Length > ($inputWidth - 3)) {
                $displayText = $displayText.Substring($displayText.Length - ($inputWidth - 3))
            }
            Write-BufferString -X ($promptX + 1) -Y ($inputY + 1) -Text $displayText
            
            # Draw cursor if textbox is focused
            if ($isFocused) {
                $cursorPos = [Math]::Min($self.State.InputValue.Length, $inputWidth - 3)
                Write-BufferString -X ($promptX + 1 + $cursorPos) -Y ($inputY + 1) `
                    -Text "_" -ForegroundColor (Get-ThemeColor "Warning")
            }
            
            # Draw buttons
            $buttonY = $dialogY + $dialogHeight - 2
            $buttonSpacing = 15
            $buttonsWidth = $buttonSpacing * 2
            $buttonX = $dialogX + [Math]::Floor(($dialogWidth - $buttonsWidth) / 2)
            
            # OK button
            $okFocused = ($self._focusedIndex -eq 1)
            $okText = if ($okFocused) { "[ OK ]" } else { "  OK  " }
            $okColor = if ($okFocused) { Get-ThemeColor "Warning" } else { Get-ThemeColor "Primary" }
            Write-BufferString -X $buttonX -Y $buttonY -Text $okText -ForegroundColor $okColor
            
            # Cancel button
            $cancelFocused = ($self._focusedIndex -eq 2)
            $cancelText = if ($cancelFocused) { "[ Cancel ]" } else { "  Cancel  " }
            $cancelColor = if ($cancelFocused) { Get-ThemeColor "Warning" } else { Get-ThemeColor "Primary" }
            Write-BufferString -X ($buttonX + $buttonSpacing) -Y $buttonY -Text $cancelText -ForegroundColor $cancelColor
        }
        
        HandleInput = {
            param($self, $Key)
            
            # Handle Tab navigation
            if ($Key.Key -eq [ConsoleKey]::Tab) {
                $direction = if ($Key.Modifiers -band [ConsoleModifiers]::Shift) { -1 } else { 1 }
                $self._focusedIndex = ($self._focusedIndex + $direction + 3) % 3
                Request-TuiRefresh
                return $true
            }
            
            # Handle Escape
            if ($Key.Key -eq [ConsoleKey]::Escape) {
                Close-TuiDialog
                & $OnCancel
                return $true
            }
            
            # Handle based on focused element
            switch ($self._focusedIndex) {
                0 {  # TextBox
                    switch ($Key.Key) {
                        ([ConsoleKey]::Enter) {
                            Close-TuiDialog
                            & $OnSubmit -Value $self.State.InputValue
                            return $true
                        }
                        ([ConsoleKey]::Backspace) {
                            if ($self.State.InputValue.Length -gt 0) {
                                $self.State.InputValue = $self.State.InputValue.Substring(0, $self.State.InputValue.Length - 1)
                                Request-TuiRefresh
                            }
                            return $true
                        }
                        default {
                            if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar)) {
                                $self.State.InputValue += $Key.KeyChar
                                Request-TuiRefresh
                                return $true
                            }
                        }
                    }
                }
                1 {  # OK Button
                    if ($Key.Key -eq [ConsoleKey]::Enter -or $Key.Key -eq [ConsoleKey]::Spacebar) {
                        Close-TuiDialog
                        & $OnSubmit -Value $self.State.InputValue
                        return $true
                    }
                }
                2 {  # Cancel Button
                    if ($Key.Key -eq [ConsoleKey]::Enter -or $Key.Key -eq [ConsoleKey]::Spacebar) {
                        Close-TuiDialog
                        & $OnCancel
                        return $true
                    }
                }
            }
            
            return $false
        }
    }
    
    $script:DialogState.CurrentDialog = $inputScreen
    Request-TuiRefresh
}

#endregion

#region --- Engine Integration & Initialization ---

function global:Initialize-DialogSystem {
    <# .SYNOPSIS Subscribes to high-level application events to show dialogs. #>
    
    Subscribe-Event -EventName "Confirm.Request" -Handler {
        param($EventData)
        $dialogParams = $EventData.Data
        Show-ConfirmDialog @dialogParams
    }
    
    Subscribe-Event -EventName "Alert.Show" -Handler {
        param($EventData)
        $dialogParams = $EventData.Data
        Show-AlertDialog @dialogParams
    }
    
    Subscribe-Event -EventName "Input.Request" -Handler {
        param($EventData)
        $dialogParams = $EventData.Data
        Show-InputDialog @dialogParams
    }
    
    Write-Verbose "Dialog System initialized and event handlers registered."
}

function global:Render-Dialogs {
    <# .SYNOPSIS Engine Hook: Renders the current dialog over the screen. #>
    if ($script:DialogState.CurrentDialog) {
        # If it's a component with its own render method
        if ($script:DialogState.CurrentDialog.Render) {
            & $script:DialogState.CurrentDialog.Render -self $script:DialogState.CurrentDialog
        }
    }
}

function global:Handle-DialogInput {
    <# .SYNOPSIS Engine Hook: Intercepts input if a dialog is active. #>
    param($Key)
    
    if ($script:DialogState.CurrentDialog) {
        if ($script:DialogState.CurrentDialog.HandleInput) {
            return & $script:DialogState.CurrentDialog.HandleInput -self $script:DialogState.CurrentDialog -Key $Key
        }
    }
    return $false
}

function global:Update-DialogSystem {
    <# .SYNOPSIS Engine Hook: Updates dialog system state. #>
    # Placeholder for any periodic updates needed
}

function global:New-TuiDialog {
    <# .SYNOPSIS Creates a simple dialog component. #>
    param([hashtable]$Props = @{})
    
    $dialog = @{
        Type = "Dialog"
        Title = if ($Props.Title) { $Props.Title } else { "Dialog" }
        Message = if ($Props.Message) { $Props.Message } else { "" }
        Buttons = if ($Props.Buttons) { $Props.Buttons } else { @("OK") }
        SelectedButton = 0
        Width = if ($Props.Width) { $Props.Width } else { 50 }
        Height = if ($Props.Height) { $Props.Height } else { 10 }
        X = 0
        Y = 0
        OnButtonClick = if ($Props.OnButtonClick) { $Props.OnButtonClick } else { {} }
        OnCancel = if ($Props.OnCancel) { $Props.OnCancel } else { {} }
        
        Render = {
            param($self)
            
            # Center the dialog
            $self.X = [Math]::Floor(($global:TuiState.BufferWidth - $self.Width) / 2)
            $self.Y = [Math]::Floor(($global:TuiState.BufferHeight - $self.Height) / 2)
            
            # Draw dialog box
            Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                -Title $self.Title -BorderColor (Get-ThemeColor "Accent")
            
            # Use engine's word wrap helper
            $messageY = $self.Y + 2
            $messageX = $self.X + 2
            $maxWidth = $self.Width - 4
            
            $wrappedLines = Get-WordWrappedLines -Text $self.Message -MaxWidth $maxWidth
            
            foreach ($line in $wrappedLines) {
                if ($messageY -ge ($self.Y + $self.Height - 3)) { break }  # Don't overwrite buttons
                Write-BufferString -X $messageX -Y $messageY -Text $line -ForegroundColor (Get-ThemeColor "Primary")
                $messageY++
            }
            
            # Buttons
            $buttonY = $self.Y + $self.Height - 3
            $totalButtonWidth = ($self.Buttons.Count * 12) + (($self.Buttons.Count - 1) * 2)
            $buttonX = $self.X + [Math]::Floor(($self.Width - $totalButtonWidth) / 2)
            
            for ($i = 0; $i -lt $self.Buttons.Count; $i++) {
                $isSelected = ($i -eq $self.SelectedButton)
                $buttonText = if ($isSelected) { "[ $($self.Buttons[$i]) ]" } else { "  $($self.Buttons[$i])  " }
                $color = if ($isSelected) { Get-ThemeColor "Warning" } else { Get-ThemeColor "Primary" }
                
                Write-BufferString -X $buttonX -Y $buttonY -Text $buttonText -ForegroundColor $color
                $buttonX += 14
            }
        }
        
        HandleInput = {
            param($self, $Key)
            
            switch ($Key.Key) {
                ([ConsoleKey]::LeftArrow) {
                    $self.SelectedButton = [Math]::Max(0, $self.SelectedButton - 1)
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::RightArrow) {
                    $self.SelectedButton = [Math]::Min($self.Buttons.Count - 1, $self.SelectedButton + 1)
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::Tab) {
                    $self.SelectedButton = ($self.SelectedButton + 1) % $self.Buttons.Count
                    Request-TuiRefresh
                    return $true
                }
                
                ([ConsoleKey]::Enter) {
                    & $self.OnButtonClick -Button $self.Buttons[$self.SelectedButton] -Index $self.SelectedButton
                    return $true
                }
                ([ConsoleKey]::Spacebar) {
                    & $self.OnButtonClick -Button $self.Buttons[$self.SelectedButton] -Index $self.SelectedButton
                    return $true
                }
                ([ConsoleKey]::Escape) {
                    & $self.OnCancel
                    return $true
                }
            }
            
            return $false
        }
    }
    
    return $dialog
}

function global:Show-ProgressDialog {
    <# .SYNOPSIS Shows a progress dialog with updating percentage. #>
    param(
        [string]$Title = "Progress",
        [string]$Message = "Processing...",
        [int]$PercentComplete = 0,
        [switch]$ShowCancel
    )
    
    $dialog = @{
        Type = "ProgressDialog"
        Title = $Title
        Message = $Message
        PercentComplete = $PercentComplete
        Width = 60
        Height = 8
        ShowCancel = $ShowCancel
        IsCancelled = $false
        
        Render = {
            param($self)
            
            # Center the dialog
            $x = [Math]::Floor(($global:TuiState.BufferWidth - $self.Width) / 2)
            $y = [Math]::Floor(($global:TuiState.BufferHeight - $self.Height) / 2)
            
            # Draw dialog box
            Write-BufferBox -X $x -Y $y -Width $self.Width -Height $self.Height `
                -Title " $($self.Title) " -BorderColor (Get-ThemeColor "Accent")
            
            # Draw message
            Write-BufferString -X ($x + 2) -Y ($y + 2) -Text $self.Message
            
            # Draw progress bar
            $barY = $y + 4
            $barWidth = $self.Width - 4
            $filledWidth = [Math]::Floor($barWidth * ($self.PercentComplete / 100))
            
            # Progress bar background
            Write-BufferString -X ($x + 2) -Y $barY `
                -Text ("─" * $barWidth) -ForegroundColor (Get-ThemeColor "Border")
            
            # Progress bar fill
            if ($filledWidth -gt 0) {
                Write-BufferString -X ($x + 2) -Y $barY `
                    -Text ("█" * $filledWidth) -ForegroundColor (Get-ThemeColor "Success")
            }
            
            # Percentage text
            $percentText = "$($self.PercentComplete)%"
            $percentX = $x + [Math]::Floor(($self.Width - $percentText.Length) / 2)
            Write-BufferString -X $percentX -Y $barY -Text $percentText
            
            # Cancel button if requested
            if ($self.ShowCancel) {
                $buttonY = $y + $self.Height - 2
                $buttonText = if ($self.IsCancelled) { "[ Cancelling... ]" } else { "[ Cancel ]" }
                $buttonX = $x + [Math]::Floor(($self.Width - $buttonText.Length) / 2)
                Write-BufferString -X $buttonX -Y $buttonY -Text $buttonText `
                    -ForegroundColor (Get-ThemeColor "Warning")
            }
        }
        
        HandleInput = {
            param($self, $Key)
            
            if ($self.ShowCancel -and -not $self.IsCancelled) {
                if ($Key.Key -eq [ConsoleKey]::Escape -or 
                    $Key.Key -eq [ConsoleKey]::Enter -or 
                    $Key.Key -eq [ConsoleKey]::Spacebar) {
                    $self.IsCancelled = $true
                    Request-TuiRefresh
                    return $true
                }
            }
            
            return $false
        }
        
        UpdateProgress = {
            param($self, [int]$PercentComplete, [string]$Message = $null)
            $self.PercentComplete = [Math]::Min(100, [Math]::Max(0, $PercentComplete))
            if ($Message) { $self.Message = $Message }
            Request-TuiRefresh
        }
    }
    
    $script:DialogState.CurrentDialog = $dialog
    Request-TuiRefresh
    return $dialog
}

function global:Show-ListDialog {
    <# .SYNOPSIS Shows a dialog with a selectable list of items. #>
    param(
        [string]$Title = "Select Item",
        [string]$Prompt = "Choose an item:",
        [array]$Items,
        [scriptblock]$OnSelect,
        [scriptblock]$OnCancel = {},
        [switch]$AllowMultiple
    )
    
    $dialog = @{
        Type = "ListDialog"
        Title = $Title
        Prompt = $Prompt
        Items = $Items
        SelectedIndex = 0
        SelectedItems = @()
        Width = 60
        Height = [Math]::Min(20, $Items.Count + 8)
        AllowMultiple = $AllowMultiple
        
        Render = {
            param($self)
            
            $x = [Math]::Floor(($global:TuiState.BufferWidth - $self.Width) / 2)
            $y = [Math]::Floor(($global:TuiState.BufferHeight - $self.Height) / 2)
            
            # Draw dialog box
            Write-BufferBox -X $x -Y $y -Width $self.Width -Height $self.Height `
                -Title " $($self.Title) " -BorderColor (Get-ThemeColor "Accent")
            
            # Draw prompt
            Write-BufferString -X ($x + 2) -Y ($y + 2) -Text $self.Prompt
            
            # Calculate list area
            $listY = $y + 4
            $listHeight = $self.Height - 7
            $listWidth = $self.Width - 4
            
            # Draw scrollable list
            $startIndex = [Math]::Max(0, $self.SelectedIndex - [Math]::Floor($listHeight / 2))
            $endIndex = [Math]::Min($self.Items.Count - 1, $startIndex + $listHeight - 1)
            
            for ($i = $startIndex; $i -le $endIndex; $i++) {
                $itemY = $listY + ($i - $startIndex)
                $item = $self.Items[$i]
                $isSelected = ($i -eq $self.SelectedIndex)
                $isChecked = $self.SelectedItems -contains $i
                
                # Selection indicator
                $prefix = ""
                if ($self.AllowMultiple) {
                    $prefix = if ($isChecked) { "[X] " } else { "[ ] " }
                }
                
                $itemText = "$prefix$item"
                if ($itemText.Length -gt $listWidth - 2) {
                    $itemText = $itemText.Substring(0, $listWidth - 5) + "..."
                }
                
                $bgColor = if ($isSelected) { Get-ThemeColor "Selection" } else { $null }
                $fgColor = if ($isSelected) { Get-ThemeColor "Background" } else { Get-ThemeColor "Primary" }
                
                Write-BufferString -X ($x + 2) -Y $itemY -Text $itemText `
                    -ForegroundColor $fgColor -BackgroundColor $bgColor
            }
            
            # Draw scrollbar if needed
            if ($self.Items.Count -gt $listHeight) {
                $scrollbarX = $x + $self.Width - 2
                $scrollbarHeight = $listHeight
                $thumbSize = [Math]::Max(1, [Math]::Floor($scrollbarHeight * $listHeight / $self.Items.Count))
                $thumbPos = [Math]::Floor($scrollbarHeight * $self.SelectedIndex / $self.Items.Count)
                
                for ($i = 0; $i -lt $scrollbarHeight; $i++) {
                    $char = if ($i -ge $thumbPos -and $i -lt ($thumbPos + $thumbSize)) { "█" } else { "│" }
                    Write-BufferString -X $scrollbarX -Y ($listY + $i) -Text $char `
                        -ForegroundColor (Get-ThemeColor "Border")
                }
            }
            
            # Draw buttons
            $buttonY = $y + $self.Height - 2
            if ($self.AllowMultiple) {
                $okText = "[ OK ]"
                $cancelText = "[ Cancel ]"
                $buttonSpacing = 15
                $totalWidth = 30
                $startX = $x + [Math]::Floor(($self.Width - $totalWidth) / 2)
                
                Write-BufferString -X $startX -Y $buttonY -Text $okText `
                    -ForegroundColor (Get-ThemeColor "Success")
                Write-BufferString -X ($startX + $buttonSpacing) -Y $buttonY -Text $cancelText `
                    -ForegroundColor (Get-ThemeColor "Primary")
            }
        }
        
        HandleInput = {
            param($self, $Key)
            
            switch ($Key.Key) {
                ([ConsoleKey]::UpArrow) {
                    $self.SelectedIndex = [Math]::Max(0, $self.SelectedIndex - 1)
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::DownArrow) {
                    $self.SelectedIndex = [Math]::Min($self.Items.Count - 1, $self.SelectedIndex + 1)
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::Spacebar) {
                    if ($self.AllowMultiple) {
                        if ($self.SelectedItems -contains $self.SelectedIndex) {
                            $self.SelectedItems = $self.SelectedItems | Where-Object { $_ -ne $self.SelectedIndex }
                        } else {
                            $self.SelectedItems += $self.SelectedIndex
                        }
                        Request-TuiRefresh
                        return $true
                    }
                }
                ([ConsoleKey]::Enter) {
                    Close-TuiDialog
                    if ($self.AllowMultiple) {
                        $selectedValues = $self.SelectedItems | ForEach-Object { $self.Items[$_] }
                        & $OnSelect -Selected $selectedValues
                    } else {
                        & $OnSelect -Selected $self.Items[$self.SelectedIndex]
                    }
                    return $true
                }
                ([ConsoleKey]::Escape) {
                    Close-TuiDialog
                    & $OnCancel
                    return $true
                }
            }
            
            return $false
        }
    }
    
    $script:DialogState.CurrentDialog = $dialog
    Request-TuiRefresh
}

#endregion

# Export all public functions
Export-ModuleMember -Function @(
    'Initialize-DialogSystem',
    'Show-TuiDialog',
    'Close-TuiDialog',
    'Show-ConfirmDialog',
    'Show-AlertDialog',
    'Show-InputDialog',
    'Show-ProgressDialog',
    'Show-ListDialog',
    'Render-Dialogs',
    'Handle-DialogInput',
    'Update-DialogSystem',
    'New-TuiDialog'
)
# Event System Module
# Provides pub/sub event functionality for decoupled communication

$script:EventHandlers = @{}
$script:EventHistory = @()
$script:MaxEventHistory = 100

function global:Initialize-EventSystem {
    <#
    .SYNOPSIS
    Initializes the event system for the application
    #>
    $script:EventHandlers = @{}
    $script:EventHistory = @()
    Write-Verbose "Event system initialized"
}

function global:Publish-Event {
    <#
    .SYNOPSIS
    Publishes an event to all registered handlers
    
    .PARAMETER EventName
    The name of the event to publish
    
    .PARAMETER Data
    Optional data to pass to event handlers
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$EventName,
        
        [Parameter()]
        [hashtable]$Data = @{}
    )
    
    # Record event in history
    $eventRecord = @{
        EventName = $EventName
        Data = $Data
        Timestamp = Get-Date
    }
    
    $script:EventHistory += $eventRecord
    if ($script:EventHistory.Count -gt $script:MaxEventHistory) {
        $script:EventHistory = $script:EventHistory[-$script:MaxEventHistory..-1]
    }
    
    # Execute handlers
    if ($script:EventHandlers.ContainsKey($EventName)) {
        foreach ($handler in $script:EventHandlers[$EventName]) {
            try {
                $eventData = @{
                    EventName = $EventName
                    Data = $Data
                    Timestamp = $eventRecord.Timestamp
                }
                
                & $handler.ScriptBlock -EventData $eventData
            } catch {
                Write-Warning "Error in event handler for '$EventName': $_"
            }
        }
    }
    
    Write-Verbose "Published event: $EventName"
}

function global:Subscribe-Event {
    <#
    .SYNOPSIS
    Subscribes to an event with a handler
    
    .PARAMETER EventName
    The name of the event to subscribe to
    
    .PARAMETER Handler
    The script block to execute when the event is published
    
    .PARAMETER HandlerId
    Optional unique identifier for the handler
    
    .PARAMETER Source
    Optional source component ID for cleanup tracking
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$EventName,
        
        [Parameter(Mandatory = $true)]
        [scriptblock]$Handler,
        
        [Parameter()]
        [string]$HandlerId = [Guid]::NewGuid().ToString(),
        
        [Parameter()]
        [string]$Source = $null
    )
    
    if (-not $script:EventHandlers.ContainsKey($EventName)) {
        $script:EventHandlers[$EventName] = @()
    }
    
    $handlerInfo = @{
        HandlerId = $HandlerId
        ScriptBlock = $Handler
        SubscribedAt = Get-Date
        Source = $Source
    }
    
    $script:EventHandlers[$EventName] += $handlerInfo
    
    Write-Verbose "Subscribed to event: $EventName (Handler: $HandlerId)"
    
    # Only return handler ID, don't print it
    return $HandlerId
}

function global:Unsubscribe-Event {
    <#
    .SYNOPSIS
    Unsubscribes from an event
    
    .PARAMETER EventName
    The name of the event to unsubscribe from (optional if HandlerId is provided)
    
    .PARAMETER HandlerId
    The unique identifier of the handler to remove
    #>
    param(
        [Parameter()]
        [string]$EventName,
        
        [Parameter(Mandatory = $true)]
        [string]$HandlerId
    )
    
    if ($EventName) {
        # Fast path when event name is known
        if ($script:EventHandlers.ContainsKey($EventName)) {
            $script:EventHandlers[$EventName] = @($script:EventHandlers[$EventName] | Where-Object { $_.HandlerId -ne $HandlerId })
            
            if ($script:EventHandlers[$EventName].Count -eq 0) {
                $script:EventHandlers.Remove($EventName)
            }
            
            Write-Verbose "Unsubscribed from event: $EventName (Handler: $HandlerId)"
        }
    } else {
        # Search all events for the handler ID
        $found = $false
        foreach ($eventKey in @($script:EventHandlers.Keys)) {
            $handlers = $script:EventHandlers[$eventKey]
            $newHandlers = @($handlers | Where-Object { $_.HandlerId -ne $HandlerId })
            
            if ($newHandlers.Count -lt $handlers.Count) {
                $found = $true
                if ($newHandlers.Count -eq 0) {
                    $script:EventHandlers.Remove($eventKey)
                } else {
                    $script:EventHandlers[$eventKey] = $newHandlers
                }
                Write-Verbose "Unsubscribed from event: $eventKey (Handler: $HandlerId)"
                break
            }
        }
        
        if (-not $found) {
            Write-Warning "Handler ID not found: $HandlerId"
        }
    }
}

function global:Get-EventHandlers {
    <#
    .SYNOPSIS
    Gets all registered event handlers
    
    .PARAMETER EventName
    Optional event name to filter by
    #>
    param(
        [Parameter()]
        [string]$EventName
    )
    
    if ($EventName) {
        if ($script:EventHandlers.ContainsKey($EventName)) {
            return $script:EventHandlers[$EventName]
        } else {
            return @()
        }
    } else {
        return $script:EventHandlers
    }
}

function global:Clear-EventHandlers {
    <#
    .SYNOPSIS
    Clears all event handlers for a specific event or all events
    
    .PARAMETER EventName
    Optional event name to clear handlers for
    #>
    param(
        [Parameter()]
        [string]$EventName
    )
    
    if ($EventName) {
        if ($script:EventHandlers.ContainsKey($EventName)) {
            $script:EventHandlers.Remove($EventName)
            Write-Verbose "Cleared handlers for event: $EventName"
        }
    } else {
        $script:EventHandlers = @{}
        Write-Verbose "Cleared all event handlers"
    }
}

function global:Get-EventHistory {
    <#
    .SYNOPSIS
    Gets the event history
    
    .PARAMETER EventName
    Optional event name to filter by
    
    .PARAMETER Last
    Number of recent events to return
    #>
    param(
        [Parameter()]
        [string]$EventName,
        
        [Parameter()]
        [int]$Last = 0
    )
    
    $history = $script:EventHistory
    
    if ($EventName) {
        $history = $history | Where-Object { $_.EventName -eq $EventName }
    }
    
    if ($Last -gt 0) {
        $history = $history | Select-Object -Last $Last
    }
    
    return $history
}

function global:Remove-ComponentEventHandlers {
    <#
    .SYNOPSIS
    Removes all event handlers associated with a specific component
    
    .PARAMETER ComponentId
    The ID of the component whose handlers should be removed
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$ComponentId
    )
    
    $removedCount = 0
    
    # Iterate through all events and remove handlers with matching component ID
    foreach ($eventName in @($script:EventHandlers.Keys)) {
        $handlers = $script:EventHandlers[$eventName]
        $newHandlers = @()
        
        foreach ($handler in $handlers) {
            # Check if handler has Source property matching ComponentId
            if ($handler.Source -ne $ComponentId) {
                $newHandlers += $handler
            } else {
                $removedCount++
            }
        }
        
        if ($newHandlers.Count -eq 0) {
            $script:EventHandlers.Remove($eventName)
        } else {
            $script:EventHandlers[$eventName] = $newHandlers
        }
    }
    
    Write-Verbose "Removed $removedCount event handlers for component: $ComponentId"
}

# Export functions
Export-ModuleMember -Function @(
    'Initialize-EventSystem',
    'Publish-Event',
    'Subscribe-Event',
    'Unsubscribe-Event',
    'Get-EventHandlers',
    'Clear-EventHandlers',
    'Get-EventHistory',
    'Remove-ComponentEventHandlers'
)
# Theme Manager Module
# Provides theming and color management for the TUI

$script:CurrentTheme = $null
$script:Themes = @{
    Modern = @{
        Name = "Modern"
        Colors = @{
            # Base colors
            Background = [ConsoleColor]::Black
            Foreground = [ConsoleColor]::White
            
            # UI elements
            Primary = [ConsoleColor]::White
            Secondary = [ConsoleColor]::Gray
            Accent = [ConsoleColor]::Cyan
            Success = [ConsoleColor]::Green
            Warning = [ConsoleColor]::Yellow
            Error = [ConsoleColor]::Red
            Info = [ConsoleColor]::Blue
            
            # Special elements
            Header = [ConsoleColor]::Cyan
            Border = [ConsoleColor]::DarkGray
            Selection = [ConsoleColor]::Yellow
            Highlight = [ConsoleColor]::Cyan
            Subtle = [ConsoleColor]::DarkGray
            
            # Syntax highlighting
            Keyword = [ConsoleColor]::Blue
            String = [ConsoleColor]::Green
            Number = [ConsoleColor]::Magenta
            Comment = [ConsoleColor]::DarkGray
        }
    }
    
    Dark = @{
        Name = "Dark"
        Colors = @{
            Background = [ConsoleColor]::Black
            Foreground = [ConsoleColor]::Gray
            Primary = [ConsoleColor]::Gray
            Secondary = [ConsoleColor]::DarkGray
            Accent = [ConsoleColor]::DarkCyan
            Success = [ConsoleColor]::DarkGreen
            Warning = [ConsoleColor]::DarkYellow
            Error = [ConsoleColor]::DarkRed
            Info = [ConsoleColor]::DarkBlue
            Header = [ConsoleColor]::DarkCyan
            Border = [ConsoleColor]::DarkGray
            Selection = [ConsoleColor]::Yellow
            Highlight = [ConsoleColor]::Cyan
            Subtle = [ConsoleColor]::DarkGray
            Keyword = [ConsoleColor]::DarkBlue
            String = [ConsoleColor]::DarkGreen
            Number = [ConsoleColor]::DarkMagenta
            Comment = [ConsoleColor]::DarkGray
        }
    }
    
    Light = @{
        Name = "Light"
        Colors = @{
            Background = [ConsoleColor]::White
            Foreground = [ConsoleColor]::Black
            Primary = [ConsoleColor]::Black
            Secondary = [ConsoleColor]::DarkGray
            Accent = [ConsoleColor]::Blue
            Success = [ConsoleColor]::Green
            Warning = [ConsoleColor]::DarkYellow
            Error = [ConsoleColor]::Red
            Info = [ConsoleColor]::Blue
            Header = [ConsoleColor]::Blue
            Border = [ConsoleColor]::Gray
            Selection = [ConsoleColor]::Cyan
            Highlight = [ConsoleColor]::Yellow
            Subtle = [ConsoleColor]::Gray
            Keyword = [ConsoleColor]::Blue
            String = [ConsoleColor]::Green
            Number = [ConsoleColor]::Magenta
            Comment = [ConsoleColor]::Gray
        }
    }
    
    Retro = @{
        Name = "Retro"
        Colors = @{
            Background = [ConsoleColor]::Black
            Foreground = [ConsoleColor]::Green
            Primary = [ConsoleColor]::Green
            Secondary = [ConsoleColor]::DarkGreen
            Accent = [ConsoleColor]::Yellow
            Success = [ConsoleColor]::Green
            Warning = [ConsoleColor]::Yellow
            Error = [ConsoleColor]::Red
            Info = [ConsoleColor]::Cyan
            Header = [ConsoleColor]::Yellow
            Border = [ConsoleColor]::DarkGreen
            Selection = [ConsoleColor]::Yellow
            Highlight = [ConsoleColor]::White
            Subtle = [ConsoleColor]::DarkGreen
            Keyword = [ConsoleColor]::Yellow
            String = [ConsoleColor]::Cyan
            Number = [ConsoleColor]::White
            Comment = [ConsoleColor]::DarkGreen
        }
    }
}

function global:Initialize-ThemeManager {
    <#
    .SYNOPSIS
    Initializes the theme manager
    #>
    
    # Set default theme
    Set-TuiTheme -ThemeName "Modern"
    
    Write-Verbose "Theme manager initialized"
}

function global:Set-TuiTheme {
    <#
    .SYNOPSIS
    Sets the current theme
    
    .PARAMETER ThemeName
    The name of the theme to set
    #>
    param(
        [Parameter(Mandatory = $true)]
        [ValidateSet("Modern", "Dark", "Light", "Retro")]
        [string]$ThemeName
    )
    
    if ($script:Themes.ContainsKey($ThemeName)) {
        $script:CurrentTheme = $script:Themes[$ThemeName]
        
        # --- FIX ---
        # Defensively check if RawUI exists. In some environments (like the VS Code
        # Integrated Console), it can be $null and cause a crash.
        if ($Host.UI.RawUI) {
            # Apply console colors
            $Host.UI.RawUI.BackgroundColor = $script:CurrentTheme.Colors.Background
            $Host.UI.RawUI.ForegroundColor = $script:CurrentTheme.Colors.Foreground
        }
        
        Write-Verbose "Theme set to: $ThemeName"
        
        # Publish theme change event
        # Check if Publish-Event exists before calling it
        if (Get-Command -Name Publish-Event -ErrorAction SilentlyContinue) {
            Publish-Event -EventName "Theme.Changed" -Data @{ 
                ThemeName = $ThemeName
                Theme = $script:CurrentTheme 
            }
        }
    } else {
        Write-Warning "Theme not found: $ThemeName"
    }
}

function global:Get-ThemeColor {
    <#
    .SYNOPSIS
    Gets a color from the current theme
    
    .PARAMETER ColorName
    The name of the color to get
    
    .PARAMETER Default
    Default color if not found
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$ColorName,
        
        [Parameter()]
        [ConsoleColor]$Default = [ConsoleColor]::Gray
    )
    
    if ($script:CurrentTheme -and $script:CurrentTheme.Colors.ContainsKey($ColorName)) {
        return $script:CurrentTheme.Colors[$ColorName]
    } else {
        return $Default
    }
}

function global:Get-TuiTheme {
    <#
    .SYNOPSIS
    Gets the current theme
    #>
    
    return $script:CurrentTheme
}

function global:Get-AvailableThemes {
    <#
    .SYNOPSIS
    Gets all available themes
    #>
    
    return $script:Themes.Keys | Sort-Object
}

function global:New-TuiTheme {
    <#
    .SYNOPSIS
    Creates a new theme
    
    .PARAMETER Name
    The name of the new theme
    
    .PARAMETER BaseTheme
    The name of the theme to base this on
    
    .PARAMETER Colors
    Hashtable of color overrides
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$Name,
        
        [Parameter()]
        [string]$BaseTheme = "Modern",
        
        [Parameter()]
        [hashtable]$Colors = @{}
    )
    
    # Clone base theme
    $newTheme = @{
        Name = $Name
        Colors = @{}
    }
    
    if ($script:Themes.ContainsKey($BaseTheme)) {
        foreach ($colorKey in $script:Themes[$BaseTheme].Colors.Keys) {
            $newTheme.Colors[$colorKey] = $script:Themes[$BaseTheme].Colors[$colorKey]
        }
    }
    
    # Apply overrides
    foreach ($colorKey in $Colors.Keys) {
        $newTheme.Colors[$colorKey] = $Colors[$colorKey]
    }
    
    # Save theme
    $script:Themes[$Name] = $newTheme
    
    Write-Verbose "Created new theme: $Name"
    
    return $newTheme
}

function global:Export-TuiTheme {
    <#
    .SYNOPSIS
    Exports a theme to JSON
    
    .PARAMETER ThemeName
    The name of the theme to export
    
    .PARAMETER Path
    The path to save the theme
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$ThemeName,
        
        [Parameter(Mandatory = $true)]
        [string]$Path
    )
    
    if ($script:Themes.ContainsKey($ThemeName)) {
        $theme = $script:Themes[$ThemeName]
        
        # Convert ConsoleColor enums to strings for JSON
        $exportTheme = @{
            Name = $theme.Name
            Colors = @{}
        }
        
        foreach ($colorKey in $theme.Colors.Keys) {
            $exportTheme.Colors[$colorKey] = $theme.Colors[$colorKey].ToString()
        }
        
        $exportTheme | ConvertTo-Json -Depth 3 | Set-Content -Path $Path
        
        Write-Verbose "Exported theme to: $Path"
    } else {
        Write-Warning "Theme not found: $ThemeName"
    }
}

function global:Import-TuiTheme {
    <#
    .SYNOPSIS
    Imports a theme from JSON
    
    .PARAMETER Path
    The path to the theme file
    #>
    param(
        [Parameter(Mandatory = $true)]
        [string]$Path
    )
    
    if (Test-Path $Path) {
        try {
            $importedTheme = Get-Content $Path -Raw | ConvertFrom-Json
            
            $theme = @{
                Name = $importedTheme.Name
                Colors = @{}
            }
            
            # Convert string color names back to ConsoleColor enums
            foreach ($colorProp in $importedTheme.Colors.PSObject.Properties) {
                $theme.Colors[$colorProp.Name] = [ConsoleColor]$colorProp.Value
            }
            
            $script:Themes[$theme.Name] = $theme
            
            Write-Verbose "Imported theme: $($theme.Name)"
            
            return $theme
        } catch {
            Write-Error "Failed to import theme: $_"
        }
    } else {
        Write-Warning "Theme file not found: $Path"
    }
}

# Export functions
Export-ModuleMember -Function @(
    'Initialize-ThemeManager',
    'Set-TuiTheme',
    'Get-ThemeColor',
    'Get-TuiTheme',
    'Get-AvailableThemes',
    'New-TuiTheme',
    'Export-TuiTheme',
    'Import-TuiTheme'
)
# Rock-Solid TUI Engine v4.0 - Performance & Reliability Edition
# Implements all critical fixes from code review



#region Core TUI State
$script:TuiState = @{
    Running         = $false
    BufferWidth     = 0
    BufferHeight    = 0
    FrontBuffer     = $null
    BackBuffer      = $null
    ScreenStack     = New-Object System.Collections.Stack
    CurrentScreen   = $null
    IsDirty         = $true
    LastActivity    = [DateTime]::Now
    LastRenderTime  = [DateTime]::MinValue
    RenderStats     = @{ LastFrameTime = 0; FrameCount = 0; TotalTime = 0; TargetFPS = 60 }
    Components      = @()
    Layouts         = @{}
    DebugOverlayEnabled = $false
    FocusedComponent = $null
    
    # Thread-safe input queue and runspace management
    InputQueue = $null
    InputRunspace = $null
    InputPowerShell = $null
    InputAsyncResult = $null
    
    # The correct, thread-safe object for signalling shutdown.
    CancellationTokenSource = $null
    
    # Event cleanup tracking
    EventHandlers = @{}
}

# Debug messages removed to prevent screen bleed-through
# Note: Width and Height params are only available inside Initialize-TuiEngine function



# Cell pool to avoid thousands of hashtable allocations
$script:CellPool = @{
    Pool = New-Object System.Collections.Queue
    MaxSize = 1000
}
#endregion

#region Cell Management & Object Pooling

function Get-PooledCell {
    param(
        [char]$Char = ' ',
        [ConsoleColor]$FG = [ConsoleColor]::White,
        [ConsoleColor]$BG = [ConsoleColor]::Black
    )
    
    if ($script:CellPool.Pool.Count -gt 0) {
        $cell = $script:CellPool.Pool.Dequeue()
        $cell.Char = $Char
        $cell.FG = $FG
        $cell.BG = $BG
        return $cell
    }
    
    # Create new cell if pool is empty
    return @{
        Char = $Char
        FG = $FG
        BG = $BG
    }
}

function Return-CellToPool {
    param($Cell)
    if ($script:CellPool.Pool.Count -lt $script:CellPool.MaxSize) {
        $script:CellPool.Pool.Enqueue($Cell)
    }
}

#endregion

#region Engine Lifecycle & Main Loop

function global:Initialize-TuiEngine {
    param(
        [int]$Width = [Console]::WindowWidth,
        [int]$Height = [Console]::WindowHeight - 1
    )

    # Patch: Always set defaults if not passed in
    if (-not $Width) { $Width = [Console]::WindowWidth }
    if (-not $Height) { $Height = [Console]::WindowHeight - 1 }
    
    if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
        Write-Log -Level Info -Message "Initializing TUI Engine: ${Width}x${Height}"
    }

   

    
    
    try {
        if ($Width -le 0 -or $Height -le 0) { throw "Invalid console dimensions: ${Width}x${Height}" }
        
        $script:TuiState.BufferWidth = $Width
        $script:TuiState.BufferHeight = $Height
        
        # Create 2D arrays for buffers
        $script:TuiState.FrontBuffer = New-Object 'object[,]' $Height, $Width
        $script:TuiState.BackBuffer = New-Object 'object[,]' $Height, $Width
        
        # Initialize buffers with empty cells
        $emptyCell = @{ Char = ' '; FG = [ConsoleColor]::White; BG = [ConsoleColor]::Black }
        for ($y = 0; $y -lt $Height; $y++) {
            for ($x = 0; $x -lt $Width; $x++) {
                $script:TuiState.FrontBuffer[$y, $x] = @{ Char = ' '; FG = [ConsoleColor]::White; BG = [ConsoleColor]::Black }
                $script:TuiState.BackBuffer[$y, $x] = @{ Char = ' '; FG = [ConsoleColor]::White; BG = [ConsoleColor]::Black }
            }
        }
        
        [Console]::CursorVisible = $false
        [Console]::Clear() # Clear console to remove initialization messages
        
        # Initialize subsystems with error handling
        try { 
            Initialize-LayoutEngines 
            if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
                Write-Log -Level Debug -Message "Layout engines initialized"
            }
        } catch { 
            Write-Warning "Layout engines init failed: $_" 
            if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
                Write-Log -Level Error -Message "Layout engines init failed" -Data $_
            }
        }
        try { 
            Initialize-ComponentSystem 
            if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
                Write-Log -Level Debug -Message "Component system initialized"
            }
        } catch { 
            Write-Warning "Component system init failed: $_" 
            if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
                Write-Log -Level Error -Message "Component system init failed" -Data $_
            }
        }
        
        # Track event handlers for cleanup (event system should already be initialized)
        $script:TuiState.EventHandlers = @{}
        
        # --- THE FIX: HOOK CTRL+C *BEFORE* STARTING THE INPUT THREAD ---
        # Temporarily disabled due to compatibility issues
        # TODO: Re-enable with proper PowerShell event handling
        try {
            [Console]::TreatControlCAsInput = $false
            # Ctrl+C handler temporarily disabled - will terminate process normally
        } catch {
            Write-Warning "Could not set console input mode: $_"
        }
        
        # Now it is safe to start the input thread.
        Initialize-InputThread
        
        # Publish initialization event
        Safe-PublishEvent -EventName "System.EngineInitialized" -Data @{ Width = $Width; Height = $Height }
        
        # Export TuiState for global access
        $global:TuiState = $script:TuiState
        
        if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
            Write-Log -Level Info -Message "TUI Engine initialized successfully"
        }
    }
    catch {
        # --- ENHANCED DIAGNOSTIC BLOCK ---
        # This will now clearly print the root cause of any initialization failure.
        Write-Host "--------------------------------------------------------" -ForegroundColor Red
        Write-Host "IMMEDIATE, ORIGINAL ERROR DETECTED DURING INITIALIZATION" -ForegroundColor Red
        Write-Host "THE *REAL* PROBLEM IS LIKELY THIS:" -ForegroundColor Yellow
        
        if ($_) {
            Write-Host "MESSAGE: $($_.Exception.Message)" -ForegroundColor White
            
            Write-Host "FULL ERROR:" -ForegroundColor Yellow
            if ($_.Exception) {
                $_.Exception | Format-List * -Force
            } else {
                Write-Host "Error details: $_" -ForegroundColor White
            }
        } else {
            Write-Host "Unknown error occurred" -ForegroundColor White
        }
        
        Write-Host "--------------------------------------------------------" -ForegroundColor Red
        
        # Re-throw the exception so the main script's finally block is triggered for cleanup.
        throw "FATAL: TUI Engine initialization failed. See original error details above."
    }
}

function Initialize-InputThread {
    try {
        # Create thread-safe input handling
        $queueType = [System.Collections.Concurrent.ConcurrentQueue[System.ConsoleKeyInfo]]
        $script:TuiState.InputQueue = New-Object $queueType
    } catch {
        Write-Warning "Failed to create ConcurrentQueue, falling back to ArrayList"
        $script:TuiState.InputQueue = [System.Collections.ArrayList]::Synchronized([System.Collections.ArrayList]::new())
    }
    
    # Create the cancellation token source for thread-safe shutdown.
    $script:TuiState.CancellationTokenSource = [System.Threading.CancellationTokenSource]::new()
    $token = $script:TuiState.CancellationTokenSource.Token

    # Create runspace for input handling (fully-qualified .NET types)
    $runspace = [System.Management.Automation.Runspaces.RunspaceFactory]::CreateRunspace()
    $runspace.Open()
    $runspace.SessionStateProxy.SetVariable('InputQueue', $script:TuiState.InputQueue)
    $runspace.SessionStateProxy.SetVariable('token', $token)
    
    # Create a PowerShell instance in that runspace
    $ps = [System.Management.Automation.PowerShell]::Create()
    $ps.Runspace = $runspace
    
    # This script block will run in the background.
    $ps.AddScript({
        try {
            while (-not $token.IsCancellationRequested) {
                if ([Console]::KeyAvailable) {
                    $keyInfo = [Console]::ReadKey($true)
                    
                    # Handle different queue types
                    if ($InputQueue -is [System.Collections.Concurrent.ConcurrentQueue[System.ConsoleKeyInfo]]) {
                        if ($InputQueue.Count -lt 100) {
                            $InputQueue.Enqueue($keyInfo)
                        }
                    } elseif ($InputQueue -is [System.Collections.ArrayList]) {
                        if ($InputQueue.Count -lt 100) {
                            $InputQueue.Add($keyInfo) | Out-Null
                        }
                    }
                }
                else {
                    Start-Sleep -Milliseconds 20
                }
            }
        }
        catch [System.Management.Automation.PipelineStoppedException] {
            return
        }
        catch {
            Write-Warning "Input thread error: $_"
        }
    }) | Out-Null
    
    # Store for cleanup
    $script:TuiState.InputRunspace   = $runspace
    $script:TuiState.InputPowerShell = $ps
    $script:TuiState.InputAsyncResult = $ps.BeginInvoke()
}

function Process-TuiInput {
    # Process all queued input events
    $processedAny = $false
    # Check if the queue exists before trying to use it.
    if (-not $script:TuiState.InputQueue) { return $false }
    
    if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
        Write-Log -Level Verbose -Message "Processing input queue"
    }

    $keyInfo = $null
    
    # Handle different queue types
    if ($script:TuiState.InputQueue -is [System.Collections.Concurrent.ConcurrentQueue[System.ConsoleKeyInfo]]) {
        $keyInfo = [System.ConsoleKeyInfo]::new([char]0, [System.ConsoleKey]::None, $false, $false, $false)
        while ($script:TuiState.InputQueue.TryDequeue([ref]$keyInfo)) {
            $processedAny = $true
            $script:TuiState.LastActivity = [DateTime]::Now
            Process-SingleKeyInput -keyInfo $keyInfo
        }
    } elseif ($script:TuiState.InputQueue -is [System.Collections.ArrayList]) {
        while ($script:TuiState.InputQueue.Count -gt 0) {
            try {
                $keyInfo = $script:TuiState.InputQueue[0]
                $script:TuiState.InputQueue.RemoveAt(0)
                $processedAny = $true
                $script:TuiState.LastActivity = [DateTime]::Now
                Process-SingleKeyInput -keyInfo $keyInfo
            } catch {
                break
            }
        }
    }
    
    return $processedAny
}

function Process-SingleKeyInput {
    param($keyInfo)
    
    try {
        # Tab navigation handled globally
        if ($keyInfo.Key -eq [ConsoleKey]::Tab) {
            Handle-TabNavigation -Reverse ($keyInfo.Modifiers -band [ConsoleModifiers]::Shift)
            return
        }
        
        # Dialog system gets first chance at input
        if ((Get-Command -Name "Handle-DialogInput" -ErrorAction SilentlyContinue) -and (Handle-DialogInput -Key $keyInfo)) {
            return
        }
        
        # Focused component gets the next chance
        $focusedComponent = $script:TuiState.FocusedComponent
        if ($focusedComponent -and $focusedComponent.HandleInput) {
            try {
                if (& $focusedComponent.HandleInput -self $focusedComponent -Key $keyInfo) {
                    return
                }
            } catch {
                Write-Warning "Component input handler error: $_"
            }
        }
        
        # Finally, the screen itself gets the key
        $currentScreen = $script:TuiState.CurrentScreen
        if ($currentScreen -and $currentScreen.HandleInput) {
            try {
                $result = & $currentScreen.HandleInput -self $currentScreen -Key $keyInfo
                switch ($result) {
                    "Back" { Pop-Screen }
                    "Quit" { 
                        $script:TuiState.Running = $false
                        if ($script:TuiState.CancellationTokenSource) {
                            $script:TuiState.CancellationTokenSource.Cancel()
                        }
                    }
                }
            } catch {
                Write-Warning "Screen input handler error: $_"
            }
        }
    } catch {
        Write-Warning "Input processing error: $_"
    }
}

function global:Start-TuiLoop {
    param([hashtable]$InitialScreen = $null)

    try {
        # Only initialize if not already initialized
        if (-not $script:TuiState.BufferWidth -or $script:TuiState.BufferWidth -eq 0) {
            Initialize-TuiEngine
        }
        
        if ($InitialScreen) {
            Push-Screen -Screen $InitialScreen
        }
        
        # If no screen is active and no initial screen provided, we can't start
        if (-not $script:TuiState.CurrentScreen -and $script:TuiState.ScreenStack.Count -eq 0) {
            throw "No screen available to display. Push a screen before calling Start-TuiLoop or provide an InitialScreen parameter."
        }

        $script:TuiState.Running = $true
        $frameTime = New-Object System.Diagnostics.Stopwatch
        $targetFrameTime = 1000.0 / $script:TuiState.RenderStats.TargetFPS
        
        while ($script:TuiState.Running) {
            $frameTime.Restart()
            
            try {
                # Process input
                $hadInput = Process-TuiInput
                
                # Update dialog system
                if (Get-Command -Name "Update-DialogSystem" -ErrorAction SilentlyContinue) { 
                    try { Update-DialogSystem } catch { Write-Warning "Dialog update error: $_" }
                }

                # Render if dirty or had input
                if ($script:TuiState.IsDirty -or $hadInput) {
                    Render-Frame
                    $script:TuiState.IsDirty = $false
                }
                
                # Adaptive frame timing
                $elapsed = $frameTime.ElapsedMilliseconds
                if ($elapsed -lt $targetFrameTime) {
                    $sleepTime = [Math]::Max(1, $targetFrameTime - $elapsed)
                    Start-Sleep -Milliseconds $sleepTime
                }
            } catch {
                Write-Warning "Main loop error: $_"
                $script:TuiState.IsDirty = $true  # Force redraw on error
            }
        }
    }
    finally {
        Cleanup-TuiEngine
    }
}

function Render-Frame {
    try {
        if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
            Write-Log -Level Verbose -Message "Starting frame render"
        }
        
        $bgColor = if (Get-Command -Name "Get-ThemeColor" -ErrorAction SilentlyContinue) {
            Get-ThemeColor "Background"
        } else {
            [ConsoleColor]::Black
        }
        
        # Always clear the back buffer completely
        Clear-BackBuffer -BackgroundColor $bgColor
        
        # Render current screen
        if ($script:TuiState.CurrentScreen -and $script:TuiState.CurrentScreen.Render) {
            try {
                & $script:TuiState.CurrentScreen.Render -self $script:TuiState.CurrentScreen
            } catch {
                $errorMessage = "Screen render error: $($_.Exception.Message)"
                if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
                    Write-Log -Level Error -Message $errorMessage -Data $_
                }
                # Draw error message on screen
                Write-BufferString -X 2 -Y 2 -Text $errorMessage -ForegroundColor Red
            }
        }
        
        # Render dialogs on top
        if (Get-Command -Name "Render-Dialogs" -ErrorAction SilentlyContinue) {
            try {
                Render-Dialogs
            } catch {
                Write-Warning "Dialog render error: $_"
            }
        }
        
        # Perform optimized render
        Render-BufferOptimized
        
        # Force cursor to bottom-right to avoid interference
        [Console]::SetCursorPosition($script:TuiState.BufferWidth - 1, $script:TuiState.BufferHeight - 1)
        
    } catch {
        Write-Warning "Frame render error: $_"
    }
}

function global:Request-TuiRefresh {
    $script:TuiState.IsDirty = $true
}

function Cleanup-TuiEngine {
    try {
        # --- ROBUST CLEANUP ROUTINE ---
        # This sequence is defensive and will not fail even if initialization was partial.
        if ($script:TuiState.CancellationTokenSource) {
            try {
                if (-not $script:TuiState.CancellationTokenSource.IsCancellationRequested) {
                    $script:TuiState.CancellationTokenSource.Cancel()
                }
            } catch { 
                # Ignore errors if CancellationTokenSource is in an invalid state
            }
        }

        if ($script:TuiState.InputPowerShell) {
            if ($script:TuiState.InputAsyncResult) {
                try { $script:TuiState.InputPowerShell.EndInvoke($script:TuiState.InputAsyncResult) } catch { }
            }
            try { $script:TuiState.InputPowerShell.Dispose() } catch { }
        }
        
        if ($script:TuiState.InputRunspace) {
            try { $script:TuiState.InputRunspace.Dispose() } catch { }
        }
        
        if ($script:TuiState.CancellationTokenSource) {
            try { $script:TuiState.CancellationTokenSource.Dispose() } catch { }
        }

        # Clean up background jobs
        if (Get-Command -Name "Stop-AllTuiAsyncJobs" -ErrorAction SilentlyContinue) {
            try { Stop-AllTuiAsyncJobs } catch { }
        }

        Cleanup-EventHandlers
        
        # Only try to reset the console if we are in an interactive session
        if (-not $env:CI -and -not $PSScriptRoot) {
            try {
                if ([System.Environment]::UserInteractive) {
                    [Console]::Write("`e[0m")
                    [Console]::CursorVisible = $true
                    [Console]::Clear()
                    [Console]::ResetColor()
                }
            } catch {
                # This can fail in non-interactive environments, ignore the error.
            }
        }
    } catch {
        Write-Warning "A secondary error occurred during TUI cleanup: $_"
    }
}

function Cleanup-EventHandlers {
    if (-not (Get-Command -Name "Unsubscribe-Event" -ErrorAction SilentlyContinue)) { return }
    if (-not $script:TuiState.EventHandlers) { return }

    foreach ($handlerId in $script:TuiState.EventHandlers.Values) {
        try { Unsubscribe-Event -HandlerId $handlerId } catch { }
    }
    $script:TuiState.EventHandlers.Clear()
    
    # Clean up any Ctrl+C event handler if it exists
    try {
        Get-EventSubscriber -SourceIdentifier "TuiCtrlC" -ErrorAction SilentlyContinue | Unregister-Event
    } catch { }
}

function Safe-PublishEvent {
    param($EventName, $Data)
    if (Get-Command -Name "Publish-Event" -ErrorAction SilentlyContinue) {
        try { Publish-Event -EventName $EventName -Data $Data } catch { }
    }
}

#endregion

#region Screen Management

function global:Push-Screen {
    param([hashtable]$Screen)
    if (-not $Screen) { return }
    
    if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
        Write-Log -Level Debug -Message "Pushing screen: $($Screen.Name)"
    }
    
    try {
        # Handle focus before switching screens
        if ($script:TuiState.FocusedComponent -and $script:TuiState.FocusedComponent.OnBlur) {
            try {
                & $script:TuiState.FocusedComponent.OnBlur -self $script:TuiState.FocusedComponent
            } catch {
                Write-Warning "Component blur error: $_"
            }
        }
        
        if ($script:TuiState.CurrentScreen) {
            if ($script:TuiState.CurrentScreen.OnExit) { 
                try {
                    & $script:TuiState.CurrentScreen.OnExit -self $script:TuiState.CurrentScreen
                } catch {
                    Write-Warning "Screen exit error: $_"
                }
            }
            $script:TuiState.ScreenStack.Push($script:TuiState.CurrentScreen)
        }
        
        $script:TuiState.CurrentScreen = $Screen
        $script:TuiState.FocusedComponent = $null  # Clear focus when changing screens
        
        if ($Screen.Init) { 
            try {
                & $Screen.Init -self $Screen 
            } catch {
                Write-Warning "Screen init error: $_"
            }
        }
        
        Request-TuiRefresh
        Safe-PublishEvent -EventName "Screen.Pushed" -Data @{ ScreenName = $Screen.Name }
        
    } catch {
        Write-Warning "Push screen error: $_"
    }
}

function global:Pop-Screen {
    if ($script:TuiState.ScreenStack.Count -eq 0) { return $false }
    
    if (Get-Command Write-Log -ErrorAction SilentlyContinue) {
        Write-Log -Level Debug -Message "Popping screen"
    }
    
    try {
        # Handle focus before switching screens
        if ($script:TuiState.FocusedComponent -and $script:TuiState.FocusedComponent.OnBlur) {
            try {
                & $script:TuiState.FocusedComponent.OnBlur -self $script:TuiState.FocusedComponent
            } catch {
                Write-Warning "Component blur error: $_"
            }
        }
        
        # Store the screen to exit before changing CurrentScreen
        $screenToExit = $script:TuiState.CurrentScreen
        
        # Pop the new screen from the stack
        $script:TuiState.CurrentScreen = $script:TuiState.ScreenStack.Pop()
        $script:TuiState.FocusedComponent = $null  # Clear focus when changing screens
        
        # Call lifecycle hooks in correct order
        if ($screenToExit -and $screenToExit.OnExit) { 
            try {
                & $screenToExit.OnExit -self $screenToExit
            } catch {
                Write-Warning "Screen exit error: $_"
            }
        }
        if ($script:TuiState.CurrentScreen -and $script:TuiState.CurrentScreen.OnResume) { 
            try {
                & $script:TuiState.CurrentScreen.OnResume -self $script:TuiState.CurrentScreen
            } catch {
                Write-Warning "Screen resume error: $_"
            }
        }
        
        # Restore focus if the screen tracks it
        if ($script:TuiState.CurrentScreen.LastFocusedComponent) {
            Set-ComponentFocus -Component $script:TuiState.CurrentScreen.LastFocusedComponent
        }
        
        Request-TuiRefresh
        Safe-PublishEvent -EventName "Screen.Popped" -Data @{ ScreenName = $script:TuiState.CurrentScreen.Name }
        
        return $true
        
    } catch {
        Write-Warning "Pop screen error: $_"
        return $false
    }
}

#endregion

#region Buffer and Rendering

# GetBufferIndex no longer needed - using 2D arrays directly

function global:Clear-BackBuffer {
    param([ConsoleColor]$BackgroundColor = [ConsoleColor]::Black)
    
    # Create a new cell for each position to ensure proper clearing
    for ($y = 0; $y -lt $script:TuiState.BufferHeight; $y++) {
        for ($x = 0; $x -lt $script:TuiState.BufferWidth; $x++) {
            $script:TuiState.BackBuffer[$y, $x] = @{ 
                Char = ' '
                FG = [ConsoleColor]::White
                BG = $BackgroundColor 
            }
        }
    }
}

function global:Write-BufferString {
    param(
        [int]$X, 
        [int]$Y, 
        [string]$Text, 
        [ConsoleColor]$ForegroundColor = [ConsoleColor]::White, 
        [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black
    )
    if ($Y -lt 0 -or $Y -ge $script:TuiState.BufferHeight) { return }
    if ([string]::IsNullOrEmpty($Text)) { return }
    
    $currentX = $X
    foreach ($char in $Text.ToCharArray()) {
        if ($currentX -ge $script:TuiState.BufferWidth) { break }

        if ($currentX -ge 0) {
            $script:TuiState.BackBuffer[$Y, $currentX] = @{ 
                Char = $char
                FG = $ForegroundColor
                BG = $BackgroundColor 
            }
        }
        
        # Pragmatic check for CJK/wide characters. A full implementation is library-dependent.
        if ($char -match '[\u1100-\u11FF\u2E80-\uA4CF\uAC00-\uD7A3\uF900-\uFAFF\uFE30-\uFE4F\uFF00-\uFFEF]') {
            $currentX += 2
            # Also fill the next cell with a space for wide characters to prevent overlap
            if ($currentX -lt $script:TuiState.BufferWidth -and $currentX -gt 0) {
                $script:TuiState.BackBuffer[$Y, $currentX - 1] = @{ 
                    Char = ' '
                    FG = $ForegroundColor
                    BG = $BackgroundColor 
                }
            }
        } else {
            $currentX++
        }
    }
}

function global:Write-BufferBox {
    param(
        [int]$X, 
        [int]$Y, 
        [int]$Width, 
        [int]$Height, 
        [string]$BorderStyle = "Single", 
        [ConsoleColor]$BorderColor = [ConsoleColor]::White, 
        [ConsoleColor]$BackgroundColor = [ConsoleColor]::Black, 
        [string]$Title = ""
    )
    $borders = Get-BorderChars -Style $BorderStyle
    
    # Top border
    Write-BufferString -X $X -Y $Y -Text "$($borders.TopLeft)$($borders.Horizontal * ($Width - 2))$($borders.TopRight)" -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    
    # Title
    if ($Title) {
        $titleText = " $Title "
        if ($titleText.Length > ($Width - 2)) {
            # FIX: Ensure the length for Substring is never negative.
            $maxLength = [Math]::Max(0, $Width - 5)
            $titleText = " $($Title.Substring(0, $maxLength))... "
        }
        $titleX = $X + [Math]::Floor(($Width - $titleText.Length) / 2)
       Write-BufferString -X $titleX -Y $Y -Text $titleText -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
    
    # Sides and Fill
    for ($i = 1; $i -lt ($Height - 1); $i++) {
        Write-BufferString -X $X -Y ($Y + $i) -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
        Write-BufferString -X ($X + 1) -Y ($Y + $i) -Text (' ' * ($Width - 2)) -BackgroundColor $BackgroundColor
        Write-BufferString -X ($X + $Width - 1) -Y ($Y + $i) -Text $borders.Vertical -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
    }
    
    # Bottom border
    Write-BufferString -X $X -Y ($Y + $Height - 1) -Text "$($borders.BottomLeft)$($borders.Horizontal * ($Width - 2))$($borders.BottomRight)" -ForegroundColor $BorderColor -BackgroundColor $BackgroundColor
}

function global:Render-BufferOptimized {
    $stopwatch = [System.Diagnostics.Stopwatch]::StartNew()
    $outputBuilder = New-Object System.Text.StringBuilder -ArgumentList 20000
    $lastFG = -1
    $lastBG = -1
    
    # Force full render on first frame or if requested
    $forceFullRender = $script:TuiState.RenderStats.FrameCount -eq 0
    
    try {
        # Build ANSI output with change detection
        for ($y = 0; $y -lt $script:TuiState.BufferHeight; $y++) {
            # Position cursor at start of line
            $outputBuilder.Append("`e[$($y + 1);1H") | Out-Null
            
            for ($x = 0; $x -lt $script:TuiState.BufferWidth; $x++) {
                $backCell = $script:TuiState.BackBuffer[$y, $x]
                $frontCell = $script:TuiState.FrontBuffer[$y, $x]
                
                # Skip if cell hasn't changed (unless forcing full render)
                if (-not $forceFullRender -and
                    $backCell.Char -eq $frontCell.Char -and 
                    $backCell.FG -eq $frontCell.FG -and 
                    $backCell.BG -eq $frontCell.BG) {
                    continue
                }
                
                # Position cursor if we skipped cells
                if ($x -gt 0 -and $outputBuilder.Length -gt 0) {
                    $outputBuilder.Append("`e[$($y + 1);$($x + 1)H") | Out-Null
                }
                
                # Update colors if changed
                if ($backCell.FG -ne $lastFG -or $backCell.BG -ne $lastBG) {
                    $fgCode = Get-AnsiColorCode $backCell.FG
                    $bgCode = Get-AnsiColorCode $backCell.BG -IsBackground $true
                    $outputBuilder.Append("`e[${fgCode};${bgCode}m") | Out-Null
                    $lastFG = $backCell.FG
                    $lastBG = $backCell.BG
                }
                
                # Append character
                $outputBuilder.Append($backCell.Char) | Out-Null
                
                # Update front buffer
                $script:TuiState.FrontBuffer[$y, $x] = @{
                    Char = $backCell.Char
                    FG = $backCell.FG
                    BG = $backCell.BG
                }
            }
        }
        
        # Reset ANSI formatting at the end
        $outputBuilder.Append("`e[0m") | Out-Null
        
        # Write to console
        if ($outputBuilder.Length -gt 0) {
            [Console]::Write($outputBuilder.ToString())
        }
        
    } catch {
        Write-Warning "Render error: $_"
    }
    
    # Update stats
    $stopwatch.Stop()
    $script:TuiState.RenderStats.LastFrameTime = $stopwatch.ElapsedMilliseconds
    $script:TuiState.RenderStats.FrameCount++
    $script:TuiState.RenderStats.TotalTime += $stopwatch.ElapsedMilliseconds
}

#endregion

#region Component System

function Initialize-ComponentSystem {
    $script:TuiState.Components = @()
    $script:TuiState.FocusedComponent = $null
}

function global:Register-Component {
    param([hashtable]$Component)
    
    # Add to component registry
    $script:TuiState.Components += $Component
    
    # Initialize component with error handling
    if ($Component.Init) {
        try {
            & $Component.Init -self $Component
        } catch {
            Write-Warning "Component init error: $_"
        }
    }
    
    return $Component
}

function global:Set-ComponentFocus {
    param([hashtable]$Component)
    
    # Don't focus disabled components
    if ($Component -and ($Component.IsEnabled -eq $false -or $Component.Disabled -eq $true)) {
        return
    }
    
    # Blur previous component with error handling
    if ($script:TuiState.FocusedComponent -and $script:TuiState.FocusedComponent.OnBlur) {
        try {
            & $script:TuiState.FocusedComponent.OnBlur -self $script:TuiState.FocusedComponent
        } catch {
            Write-Warning "Component blur error: $_"
        }
    }
    
    # Track focus on current screen
    if ($script:TuiState.CurrentScreen) {
        $script:TuiState.CurrentScreen.LastFocusedComponent = $Component
    }
    
    # Focus new component with error handling
    $script:TuiState.FocusedComponent = $Component
    if ($Component -and $Component.OnFocus) {
        try {
            & $Component.OnFocus -self $Component
        } catch {
            Write-Warning "Component focus error: $_"
        }
    }
    
    Request-TuiRefresh
}

function global:Clear-ComponentFocus {
    <#
    .SYNOPSIS
    Clears focus from the current component
    #>
    if ($script:TuiState.FocusedComponent -and $script:TuiState.FocusedComponent.OnBlur) {
        try {
            & $script:TuiState.FocusedComponent.OnBlur -self $script:TuiState.FocusedComponent
        } catch {
            Write-Warning "Component blur error: $_"
        }
    }
    
    $script:TuiState.FocusedComponent = $null
    
    # Clear tracked focus on current screen
    if ($script:TuiState.CurrentScreen) {
        $script:TuiState.CurrentScreen.LastFocusedComponent = $null
    }
    
    Request-TuiRefresh
}

function global:Get-NextFocusableComponent {
    <#
    .SYNOPSIS
    Gets the next focusable component in tab order
    #>
    param(
        [hashtable]$CurrentComponent,
        [bool]$Reverse = $false
    )
    
    if (-not $script:TuiState.CurrentScreen) { return $null }
    
    # Get all focusable components
    $focusableComponents = @()
    
    # Recursive function to find focusable components
    function Find-FocusableComponents {
        param($Component)
        
        if ($Component.CanFocus -ne $false -and 
            $Component.IsEnabled -ne $false -and 
            $Component.Disabled -ne $true -and
            $Component.IsVisible -ne $false -and
            $Component.Visible -ne $false) {
            $focusableComponents += $Component
        }
        
        if ($Component.Children) {
            foreach ($child in $Component.Children) {
                Find-FocusableComponents -Component $child
            }
        }
    }
    
    # Start from screen components
    if ($script:TuiState.CurrentScreen.Components) {
        if ($script:TuiState.CurrentScreen.Components -is [hashtable]) {
            foreach ($comp in $script:TuiState.CurrentScreen.Components.Values) {
                Find-FocusableComponents -Component $comp
            }
        } elseif ($script:TuiState.CurrentScreen.Components -is [array]) {
            foreach ($comp in $script:TuiState.CurrentScreen.Components) {
                Find-FocusableComponents -Component $comp
            }
        }
    }
    
    if ($focusableComponents.Count -eq 0) { return $null }
    
    # Sort by TabIndex or position
    $sorted = $focusableComponents | Sort-Object {
        if ($null -ne $_.TabIndex) { $_.TabIndex }
        else { $_.Y * 1000 + $_.X }
    }
    
    if ($Reverse) {
        [Array]::Reverse($sorted)
    }
    
    # Find current index
    $currentIndex = -1
    for ($i = 0; $i -lt $sorted.Count; $i++) {
        if ($sorted[$i] -eq $CurrentComponent) {
            $currentIndex = $i
            break
        }
    }
    
    # Get next component
    if ($currentIndex -ge 0) {
        $nextIndex = ($currentIndex + 1) % $sorted.Count
        return $sorted[$nextIndex]
    } else {
        return $sorted[0]
    }
}

function global:Handle-TabNavigation {
    <#
    .SYNOPSIS
    Handles Tab key navigation between components
    #>
    param([bool]$Reverse = $false)
    
    $next = Get-NextFocusableComponent -CurrentComponent $script:TuiState.FocusedComponent -Reverse $Reverse
    if ($next) {
        Set-ComponentFocus -Component $next
    }
}

function global:New-Component {
    param(
        [string]$Type = "Base",
        [int]$X = 0,
        [int]$Y = 0,
        [int]$Width = 10,
        [int]$Height = 1,
        [hashtable]$Props = @{}
    )
    
    $component = @{
        Type = $Type
        X = $X
        Y = $Y
        Width = $Width
        Height = $Height
        Visible = $true
        Focused = $false
        Parent = $null
        Children = @()
        Props = $Props
        State = @{}
        
        # Lifecycle methods
        Init = { param($self) }
        Render = { param($self) }
        HandleInput = { param($self, $Key) return $false }
        OnFocus = { param($self) $self.Focused = $true }
        OnBlur = { param($self) $self.Focused = $false }
        Dispose = { param($self) }
    }
    
    # Merge with type-specific properties
    switch ($Type) {
        "TextInput" { $component = Merge-Hashtables $component (Get-TextInputComponent) }
        "Button" { $component = Merge-Hashtables $component (Get-ButtonComponent) }
        "List" { $component = Merge-Hashtables $component (Get-ListComponent) }
        "Table" { $component = Merge-Hashtables $component (Get-TableComponent) }
    }
    
    return $component
}

function Merge-Hashtables {
    param($Base, $Override)
    $result = $Base.Clone()
    foreach ($key in $Override.Keys) {
        $result[$key] = $Override[$key]
    }
    return $result
}

#endregion

#region Layout Management

function Initialize-LayoutEngines {
    $script:TuiState.Layouts = @{
        Grid = Get-GridLayout
        Stack = Get-StackLayout
        Dock = Get-DockLayout
    }
}

function global:Apply-Layout {
    param(
        [string]$LayoutType,
        [hashtable[]]$Components,
        [hashtable]$Options = @{}
    )
    
    if ($script:TuiState.Layouts.ContainsKey($LayoutType)) {
        $layout = $script:TuiState.Layouts[$LayoutType]
        try {
            & $layout.Apply -Components $Components -Options $Options
        } catch {
            Write-Warning "Layout error: $_"
        }
    }
}

function Get-GridLayout {
    return @{
        Apply = {
            param($Components, $Options)
            $cols = if ($Options.Columns) { $Options.Columns } else { 2 }
            $rows = [Math]::Ceiling($Components.Count / $cols)
            $cellWidth = [Math]::Floor($script:TuiState.BufferWidth / $cols)
            $cellHeight = [Math]::Floor($script:TuiState.BufferHeight / $rows)
            
            for ($i = 0; $i -lt $Components.Count; $i++) {
                $col = $i % $cols
                $row = [Math]::Floor($i / $cols)
                $Components[$i].X = $col * $cellWidth
                $Components[$i].Y = $row * $cellHeight
                $Components[$i].Width = $cellWidth - 1
                $Components[$i].Height = $cellHeight - 1
            }
        }
    }
}

function Get-StackLayout {
    return @{
        Apply = {
            param($Components, $Options)
            $orientation = if ($Options.Orientation) { $Options.Orientation } else { "Vertical" }
            $spacing = if ($null -ne $Options.Spacing) { $Options.Spacing } else { 1 }
            $x = if ($null -ne $Options.X) { $Options.X } else { 0 }
            $y = if ($null -ne $Options.Y) { $Options.Y } else { 0 }
            
            foreach ($component in $Components) {
                $component.X = $x
                $component.Y = $y
                
                if ($orientation -eq "Vertical") {
                    $y += $component.Height + $spacing
                } else {
                    $x += $component.Width + $spacing
                }
            }
        }
    }
}

function Get-DockLayout {
    return @{
        Apply = {
            param($Components, $Options)
            
            # Container bounds
            $containerX = if ($null -ne $Options.X) { $Options.X } else { 0 }
            $containerY = if ($null -ne $Options.Y) { $Options.Y } else { 0 }
            $containerWidth = if ($Options.Width) { $Options.Width } else { $script:TuiState.BufferWidth }
            $containerHeight = if ($Options.Height) { $Options.Height } else { $script:TuiState.BufferHeight }
            
            # Current available area
            $availableX = $containerX
            $availableY = $containerY
            $availableWidth = $containerWidth
            $availableHeight = $containerHeight
            
            # Process components by dock position
            $topComponents = $Components | Where-Object { $_.Props.Dock -eq "Top" }
            $bottomComponents = $Components | Where-Object { $_.Props.Dock -eq "Bottom" }
            $leftComponents = $Components | Where-Object { $_.Props.Dock -eq "Left" }
            $rightComponents = $Components | Where-Object { $_.Props.Dock -eq "Right" }
            $fillComponents = $Components | Where-Object { $_.Props.Dock -eq "Fill" -or -not $_.Props.Dock }
            
            # Dock top components
            foreach ($comp in $topComponents) {
                $comp.X = $availableX
                $comp.Y = $availableY
                $comp.Width = $availableWidth
                $availableY += $comp.Height
                $availableHeight -= $comp.Height
            }
            
            # Dock bottom components
            foreach ($comp in $bottomComponents) {
                $comp.X = $availableX
                $comp.Y = $availableY + $availableHeight - $comp.Height
                $comp.Width = $availableWidth
                $availableHeight -= $comp.Height
            }
            
            # Dock left components
            foreach ($comp in $leftComponents) {
                $comp.X = $availableX
                $comp.Y = $availableY
                $comp.Height = $availableHeight
                $availableX += $comp.Width
                $availableWidth -= $comp.Width
            }
            
            # Dock right components
            foreach ($comp in $rightComponents) {
                $comp.X = $availableX + $availableWidth - $comp.Width
                $comp.Y = $availableY
                $comp.Height = $availableHeight
                $availableWidth -= $comp.Width
            }
            
            # Fill remaining space
            foreach ($comp in $fillComponents) {
                $comp.X = $availableX
                $comp.Y = $availableY
                $comp.Width = $availableWidth
                $comp.Height = $availableHeight
            }
        }
    }
}

#endregion

#region Utility Functions

function global:Get-BorderChars { 
    param([string]$Style) 
    $styles = @{ 
        Single = @{ 
            TopLeft='┌'; TopRight='┐'; BottomLeft='└'; BottomRight='┘'
            Horizontal='─'; Vertical='│' 
        }
        Double = @{ 
            TopLeft='╔'; TopRight='╗'; BottomLeft='╚'; BottomRight='╝'
            Horizontal='═'; Vertical='║' 
        }
        Rounded = @{ 
            TopLeft='╭'; TopRight='╮'; BottomLeft='╰'; BottomRight='╯'
            Horizontal='─'; Vertical='│' 
        } 
    }
    if ($styles.ContainsKey($Style)) { 
        return $styles[$Style] 
    } else { 
        return $styles.Single 
    }
}

function Get-AnsiColorCode { 
    param([ConsoleColor]$Color, [bool]$IsBackground) 
    $map = @{ 
        Black=30; DarkBlue=34; DarkGreen=32; DarkCyan=36
        DarkRed=31; DarkMagenta=35; DarkYellow=33; Gray=37
        DarkGray=90; Blue=94; Green=92; Cyan=96
        Red=91; Magenta=95; Yellow=93; White=97 
    }
    $code = $map[$Color.ToString()]
    if ($IsBackground) { 
        return $code + 10 
    } else { 
        return $code 
    } 
}

function Get-ThemeColorFallback {
    param($ColorName, $Default = [ConsoleColor]::White)
    # This is a fallback function for when theme manager isn't available
    # The theme manager will override this with its own global Get-ThemeColor
    return $Default
}

# Only define global Get-ThemeColor if it doesn't already exist
if (-not (Get-Command -Name "Get-ThemeColor" -ErrorAction SilentlyContinue)) {
    function global:Get-ThemeColor {
        param($ColorName, $Default = [ConsoleColor]::White)
        return Get-ThemeColorFallback -ColorName $ColorName -Default $Default
    }
}

function global:Write-StatusLine { 
    param(
        [string]$Text, 
        [ConsoleColor]$ForegroundColor = 'White', 
        [ConsoleColor]$BackgroundColor = 'DarkBlue'
    ) 
    try { 
        $y = $script:TuiState.BufferHeight
        [Console]::SetCursorPosition(0, $y)
        [Console]::ForegroundColor = $ForegroundColor
        [Console]::BackgroundColor = $BackgroundColor
        [Console]::Write($Text.PadRight([Console]::WindowWidth))
        [Console]::ResetColor() 
    } catch {
        Write-Warning "Status line error: $_"
    } 
}

function global:Subscribe-TuiEvent {
    param($EventName, $Handler)
    if (Get-Command -Name "Subscribe-Event" -ErrorAction SilentlyContinue) {
        $handlerId = Subscribe-Event -EventName $EventName -Handler $Handler
        # Track for cleanup
        $script:TuiState.EventHandlers[$EventName] = $handlerId
        return $handlerId
    }
}

#endregion

#region Component Definitions

function Get-TextInputComponent {
    return @{
        # State
        Value = ""
        CursorPosition = 0
        MaxLength = 50
        
        # Methods
        Render = {
            param($self)
            try {
                $borderColor = if ($self.Focused) { 
                    Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
                } else { 
                    Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
                }
                
                # Draw input box
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -BorderColor $borderColor -BackgroundColor ([ConsoleColor]::Black)
                
                # Draw focus indicator
                if ($self.Focused) {
                    # Left bracket
                    Write-BufferString -X ($self.X - 1) -Y ($self.Y + [Math]::Floor($self.Height / 2)) `
                        -Text "[" -ForegroundColor ([ConsoleColor]::Yellow)
                    # Right bracket
                    Write-BufferString -X ($self.X + $self.Width) -Y ($self.Y + [Math]::Floor($self.Height / 2)) `
                        -Text "]" -ForegroundColor ([ConsoleColor]::Yellow)
                }
                
                # Draw text
                $displayText = $self.Value
                if ($displayText.Length > ($self.Width - 3)) {
                    $displayText = $displayText.Substring($displayText.Length - ($self.Width - 3))
                }
                Write-BufferString -X ($self.X + 1) -Y ($self.Y + 1) -Text $displayText
                
                # Draw cursor if focused
                if ($self.Focused -and $self.CursorPosition -lt ($self.Width - 3)) {
                    Write-BufferString -X ($self.X + 1 + $self.CursorPosition) -Y ($self.Y + 1) `
                        -Text "_" -ForegroundColor ([ConsoleColor]::Yellow)
                }
            } catch {
                Write-Warning "TextInput render error: $_"
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                switch ($Key.Key) {
                    ([ConsoleKey]::Backspace) {
                        if ($self.Value.Length -gt 0 -and $self.CursorPosition -gt 0) {
                            $self.Value = $self.Value.Remove($self.CursorPosition - 1, 1)
                            $self.CursorPosition--
                        }
                        return $true
                    }
                    ([ConsoleKey]::Delete) {
                        if ($self.CursorPosition -lt $self.Value.Length) {
                            $self.Value = $self.Value.Remove($self.CursorPosition, 1)
                        }
                        return $true
                    }
                    ([ConsoleKey]::LeftArrow) {
                        if ($self.CursorPosition -gt 0) {
                            $self.CursorPosition--
                        }
                        return $true
                    }
                    ([ConsoleKey]::RightArrow) {
                        if ($self.CursorPosition -lt $self.Value.Length) {
                            $self.CursorPosition++
                        }
                        return $true
                    }
                    ([ConsoleKey]::Home) {
                        $self.CursorPosition = 0
                        return $true
                    }
                    ([ConsoleKey]::End) {
                        $self.CursorPosition = $self.Value.Length
                        return $true
                    }
                    default {
                        if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar) -and 
                            $self.Value.Length -lt $self.MaxLength) {
                            $self.Value = $self.Value.Insert($self.CursorPosition, $Key.KeyChar)
                            $self.CursorPosition++
                            return $true
                        }
                    }
                }
            } catch {
                Write-Warning "TextInput input error: $_"
            }
            return $false
        }
    }
}

function Get-ButtonComponent {
    return @{
        # State
        Text = "Button"
        
        # Methods
        Render = {
            param($self)
            try {
                $bgColor = if ($self.Focused) { 
                    Get-ThemeColor "Accent" -Default ([ConsoleColor]::DarkCyan)
                } else { 
                    Get-ThemeColor "Primary" -Default ([ConsoleColor]::DarkGray)
                }
                
                $text = " $($self.Text) "
                if ($text.Length > $self.Width) {
                    $text = $text.Substring(0, $self.Width)
                }
                
                $x = $self.X + [Math]::Floor(($self.Width - $text.Length) / 2)
                Write-BufferString -X $x -Y $self.Y -Text $text `
                    -ForegroundColor ([ConsoleColor]::White) -BackgroundColor $bgColor
                
                # Draw focus indicator
                if ($self.Focused) {
                    # Left bracket
                    if ($x -gt 0) {
                        Write-BufferString -X ($x - 1) -Y $self.Y `
                            -Text "[" -ForegroundColor ([ConsoleColor]::Yellow)
                    }
                    # Right bracket
                    if (($x + $text.Length) -lt $script:TuiState.BufferWidth) {
                        Write-BufferString -X ($x + $text.Length) -Y $self.Y `
                            -Text "]" -ForegroundColor ([ConsoleColor]::Yellow)
                    }
                }
            } catch {
                Write-Warning "Button render error: $_"
            }
        }
        
        HandleInput = {
            param($self, $Key)
            try {
                if ($Key.Key -eq [ConsoleKey]::Enter -or $Key.Key -eq [ConsoleKey]::Spacebar) {
                    if ($self.OnClick) {
                        & $self.OnClick -self $self
                    }
                    return $true
                }
            } catch {
                Write-Warning "Button input error: $_"
            }
            return $false
        }
    }
}

function Get-TableComponent {
    return @{
        # State
        Data = @()
        Columns = @()
        SelectedRow = 0
        ScrollOffset = 0
        
        # Methods
        Render = {
            param($self)
            try {
                # Simplified table rendering
                $y = $self.Y
                
                # Header
                $headerText = ""
                foreach ($col in $self.Columns) {
                    $headerText += $col.Name.PadRight($col.Width)
                }
                Write-BufferString -X $self.X -Y $y -Text $headerText `
                    -ForegroundColor (Get-ThemeColor "Header" -Default ([ConsoleColor]::Cyan))
                $y++
                
                # Data rows
                $visibleRows = $self.Data | Select-Object -Skip $self.ScrollOffset -First ($self.Height - 1)
                $rowIndex = $self.ScrollOffset
                foreach ($row in $visibleRows) {
                    $rowText = ""
                    foreach ($col in $self.Columns) {
                        $value = if ($row.($col.Property)) { $row.($col.Property) } else { "" }
                        $rowText += $value.ToString().PadRight($col.Width)
                    }
                    
                    $fg = if ($rowIndex -eq $self.SelectedRow) {
                        Get-ThemeColor "Selection" -Default ([ConsoleColor]::Yellow)
                    } else {
                        Get-ThemeColor "Primary" -Default ([ConsoleColor]::White)
                    }
                    
                    Write-BufferString -X $self.X -Y $y -Text $rowText -ForegroundColor $fg
                    $y++
                    $rowIndex++
                }
            } catch {
                Write-Warning "Table render error: $_"
            }
        }
    }
}

#endregion

#region Word Wrap Helper
function global:Get-WordWrappedLines {
    param(
        [string]$Text,
        [int]$MaxWidth
    )
    
    if ([string]::IsNullOrEmpty($Text) -or $MaxWidth -le 0) { return @() }
    
    $lines = @()
    $words = $Text -split '\s+'
    $sb = New-Object System.Text.StringBuilder
    
    foreach ($word in $words) {
        if ($sb.Length -eq 0) {
            [void]$sb.Append($word)
        } elseif (($sb.Length + 1 + $word.Length) -le $MaxWidth) {
            [void]$sb.Append(' ')
            [void]$sb.Append($word)
        } else {
            $lines += $sb.ToString()
            [void]$sb.Clear()
            [void]$sb.Append($word)
        }
    }
    
    if ($sb.Length -gt 0) {
        $lines += $sb.ToString()
    }
    
    return $lines
}
#endregion

# Build export list dynamically
$exportFunctions = @(
    'Start-TuiLoop', 'Request-TuiRefresh', 'Push-Screen', 'Pop-Screen',
    'Write-BufferString', 'Write-BufferBox', 'Clear-BackBuffer',
    'Write-StatusLine', 'Get-BorderChars',
    'Register-Component', 'Set-ComponentFocus', 'Clear-ComponentFocus', 
    'Get-NextFocusableComponent', 'Handle-TabNavigation', 
    'New-Component', 'Apply-Layout',
    'Get-WordWrappedLines', 'Subscribe-TuiEvent'
)

# Only export Get-ThemeColor if we defined it
if (Get-Command -Name "Get-ThemeColor" -ErrorAction SilentlyContinue | Where-Object { $_.Source -eq "tui-engine-v2" }) {
    $exportFunctions += 'Get-ThemeColor'
}

Export-ModuleMember -Function $exportFunctions -Variable @('TuiState')
# TUI Framework Integration Module - COMPLIANT VERSION
# Only contains compliant utility functions - deprecated functions removed

$script:TuiAsyncJobs = @()

function global:Invoke-TuiMethod {
    <#
    .SYNOPSIS
    Safely invokes a method on a TUI component.
    #>
    param(
        [Parameter(Mandatory=$true)]
        [hashtable]$Component,

        [Parameter(Mandatory=$true)]
        [string]$MethodName,

        [Parameter()]
        [hashtable]$Arguments = @{}
    )

    if ($null -eq $Component) { return }
    if (-not $Component.ContainsKey($MethodName)) { return }

    $method = $Component[$MethodName]
    if ($null -eq $method -or $method -isnot [scriptblock]) {
        # The method doesn't exist or is not a scriptblock, so we can't call it.
        # This prevents the "term is not recognized" error.
        return
    }

    # Add the component itself as the 'self' parameter for convenience
    $Arguments['self'] = $Component

    try {
        # Use splatting with the @ operator for robust parameter passing
        return & $method @Arguments
    
        } catch {
        $errorMessage = "Error invoking method '$MethodName' on component '$($Component.Type)': $($_.Exception.Message)"
        Write-Log -Level Error -Message $errorMessage -Data $_
        Request-TuiRefresh
    }
}

# Add 'Invoke-TuiMethod' to the Export-ModuleMember list at the end of the file.

function global:Initialize-TuiFramework {
    <#
    .SYNOPSIS
    Initializes the TUI framework
    #>
    
    # Ensure engine is initialized
    if (-not $global:TuiState) {
        throw "TUI Engine must be initialized before framework"
    }
    
    Write-Verbose "TUI Framework initialized"
}

function global:Invoke-TuiAsync {
    <#
    .SYNOPSIS
    Executes a script block asynchronously with proper job management
    
    .PARAMETER ScriptBlock
    The script block to execute asynchronously
    
    .PARAMETER OnComplete
    Handler to call when the job completes successfully
    
    .PARAMETER OnError
    Handler to call if the job encounters an error
    
    .PARAMETER ArgumentList
    Arguments to pass to the script block
    #>
    param(
        [Parameter(Mandatory = $true)]
        [scriptblock]$ScriptBlock,
        
        [Parameter()]
        [scriptblock]$OnComplete = {},
        
        [Parameter()]
        [scriptblock]$OnError = {},
        
        [Parameter()]
        [array]$ArgumentList = @()
    )
    
    try {
        # Start the job
        $job = Start-Job -ScriptBlock $ScriptBlock -ArgumentList $ArgumentList
        
        # Track the job for cleanup
        $script:TuiAsyncJobs += $job
        
        # Create a timer to check job status
        $timer = New-Object System.Timers.Timer
        $timer.Interval = 100  # Check every 100ms
        $timer.AutoReset = $true
        
        # Use Register-ObjectEvent to handle the timer tick
        $timerEvent = Register-ObjectEvent -InputObject $timer -EventName Elapsed -Action {
            $job = $Event.MessageData.Job
            $onComplete = $Event.MessageData.OnComplete
            $onError = $Event.MessageData.OnError
            $timer = $Event.MessageData.Timer
            
            if ($job.State -eq 'Completed') {
                try {
                    $result = Receive-Job -Job $job -ErrorAction Stop
                    Remove-Job -Job $job -Force
                    
                    # Remove from tracking
                    $script:TuiAsyncJobs = @($script:TuiAsyncJobs | Where-Object { $_ -ne $job })
                    
                    # Stop and dispose timer
                    $timer.Stop()
                    $timer.Dispose()
                    Unregister-Event -SourceIdentifier $Event.SourceIdentifier
                    
                    # Call completion handler on UI thread
                    if ($onComplete) {
                        & $onComplete -Data $result
                        Request-TuiRefresh
                    }
                } catch {
                    Write-Warning "Job receive error: $_"
                }
            }
            elseif ($job.State -eq 'Failed') {
                try {
                    $error = $job.ChildJobs[0].JobStateInfo.Reason
                    Remove-Job -Job $job -Force
                    
                    # Remove from tracking
                    $script:TuiAsyncJobs = @($script:TuiAsyncJobs | Where-Object { $_ -ne $job })
                    
                    # Stop and dispose timer
                    $timer.Stop()
                    $timer.Dispose()
                    Unregister-Event -SourceIdentifier $Event.SourceIdentifier
                    
                    # Call error handler
                    if ($onError) {
                        & $onError -Error $error
                        Request-TuiRefresh
                    }
                } catch {
                    Write-Warning "Job error handling failed: $_"
                }
            }
        } -MessageData @{
            Job = $job
            OnComplete = $OnComplete
            OnError = $OnError
            Timer = $timer
        }
        
        # Start the timer
        $timer.Start()
        
        # Return job info
        return @{
            Job = $job
            Timer = $timer
            EventSubscription = $timerEvent
        }
        
    } catch {
        Write-Warning "Failed to start async operation: $_"
        if ($OnError) {
            & $OnError -Error $_
        }
    }
}

function global:Stop-AllTuiAsyncJobs {
    <#
    .SYNOPSIS
    Stops and cleans up all tracked async jobs
    #>
    
    foreach ($job in $script:TuiAsyncJobs) {
        try {
            if ($job.State -eq 'Running') {
                Stop-Job -Job $job -ErrorAction SilentlyContinue
            }
            Remove-Job -Job $job -Force -ErrorAction SilentlyContinue
        } catch {
            Write-Warning "Failed to stop job: $_"
        }
    }
    
    $script:TuiAsyncJobs = @()
    
    # Clean up any orphaned timer events
    Get-EventSubscriber | Where-Object { $_.SourceObject -is [System.Timers.Timer] } | ForEach-Object {
        try {
            Unregister-Event -SourceIdentifier $_.SourceIdentifier -ErrorAction SilentlyContinue
            if ($_.SourceObject) {
                $_.SourceObject.Stop()
                $_.SourceObject.Dispose()
            }
        } catch { }
    }
}

function global:Create-TuiState {
    <#
    .SYNOPSIS
    Creates a reactive state management system with deep change detection
    
    .PARAMETER InitialState
    The initial state values
    
    .PARAMETER DeepWatch
    Enable deep property change detection (impacts performance)
    #>
    param(
        [Parameter()]
        [hashtable]$InitialState = @{},
        
        [Parameter()]
        [bool]$DeepWatch = $false
    )
    
    $stateManager = @{
        _data = $InitialState.Clone()
        _subscribers = @{}
        _deepWatch = $DeepWatch
        _changeQueue = @()
        _processing = $false
        
        GetValue = {
            param([string]$Path)
            if (-not $Path) { return $this._data }
            
            $parts = $Path -split '\.'
            $current = $this._data
            
            foreach ($part in $parts) {
                if ($null -eq $current) { return $null }
                $current = $current[$part]
            }
            
            return $current
        }
        
        SetValue = {
            param([string]$Path, $Value)
            
            $parts = $Path -split '\.'
            $current = $this._data
            
            # Navigate to parent
            for ($i = 0; $i -lt $parts.Count - 1; $i++) {
                $part = $parts[$i]
                if (-not $current.ContainsKey($part)) {
                    $current[$part] = @{}
                }
                $current = $current[$part]
            }
            
            # Get old value for comparison
            $lastPart = $parts[-1]
            $oldValue = $current[$lastPart]
            
            # Set new value
            $current[$lastPart] = $Value
            
            # Notify if changed
            if (-not (Compare-TuiValue $oldValue $Value)) {
                & $this.NotifySubscribers -Path $Path -OldValue $oldValue -NewValue $Value
                
                # Also notify parent paths
                $parentPath = ""
                for ($i = 0; $i -lt $parts.Count; $i++) {
                    if ($i -gt 0) { $parentPath += "." }
                    $parentPath += $parts[$i]
                    & $this.NotifySubscribers -Path $parentPath -OldValue $null -NewValue (& $this.GetValue $parentPath)
                }
            }
        }
        
        Update = {
            param([hashtable]$Updates)
            
            # Queue changes to batch notifications
            $this._changeQueue = @()
            
            foreach ($key in $Updates.Keys) {
                $oldValue = $this._data[$key]
                $this._data[$key] = $Updates[$key]
                
                if (-not (Compare-TuiValue $oldValue $Updates[$key])) {
                    $this._changeQueue += @{
                        Path = $key
                        OldValue = $oldValue
                        NewValue = $Updates[$key]
                    }
                }
            }
            
            # Process all notifications
            if ($this._changeQueue.Count -gt 0 -and -not $this._processing) {
                $this._processing = $true
                try {
                    foreach ($change in $this._changeQueue) {
                        & $this.NotifySubscribers @change
                    }
                } finally {
                    $this._processing = $false
                    $this._changeQueue = @()
                }
            }
        }
        
        Subscribe = {
            param(
                [string]$Path,
                [scriptblock]$Handler,
                [string]$SubscriptionId = [Guid]::NewGuid().ToString()
            )
            
            if (-not $this._subscribers.ContainsKey($Path)) {
                $this._subscribers[$Path] = @()
            }
            
            $this._subscribers[$Path] += @{
                Id = $SubscriptionId
                Handler = $Handler
            }
            
            # Call handler with current value
            $currentValue = & $this.GetValue $Path
            try {
                & $Handler -NewValue $currentValue -OldValue $null -Path $Path
            } catch {
                Write-Warning "State subscriber error: $_"
            }
            
            return $SubscriptionId
        }
        
        Unsubscribe = {
            param([string]$SubscriptionId)
            
            foreach ($path in @($this._subscribers.Keys)) {
                $this._subscribers[$path] = @($this._subscribers[$path] | Where-Object { $_.Id -ne $SubscriptionId })
                if ($this._subscribers[$path].Count -eq 0) {
                    $this._subscribers.Remove($path)
                }
            }
        }
        
        NotifySubscribers = {
            param([string]$Path, $OldValue, $NewValue)
            
            # Exact path subscribers
            if ($this._subscribers.ContainsKey($Path)) {
                foreach ($sub in $this._subscribers[$Path]) {
                    try {
                        & $sub.Handler -NewValue $NewValue -OldValue $OldValue -Path $Path
                    } catch {
                        Write-Warning "State notification error: $_"
                    }
                }
            }
            
            # Wildcard subscribers (e.g., "user.*")
            foreach ($subPath in $this._subscribers.Keys) {
                if ($subPath.EndsWith('*')) {
                    $basePath = $subPath.TrimEnd('*').TrimEnd('.')
                    if ($Path.StartsWith($basePath)) {
                        foreach ($sub in $this._subscribers[$subPath]) {
                            try {
                                & $sub.Handler -NewValue $NewValue -OldValue $OldValue -Path $Path
                            } catch {
                                Write-Warning "State wildcard notification error: $_"
                            }
                        }
                    }
                }
            }
        }
        
        Reset = {
            param([hashtable]$NewState = @{})
            $oldData = $this._data
            $this._data = $NewState.Clone()
            
            # Notify all subscribers of reset
            foreach ($path in $this._subscribers.Keys) {
                $oldValue = Get-NestedProperty -Object $oldData -Path $path
                $newValue = & $this.GetValue $path
                
                if (-not (Compare-TuiValue $oldValue $newValue)) {
                    & $this.NotifySubscribers -Path $path -OldValue $oldValue -NewValue $newValue
                }
            }
        }
    }
    
    return $stateManager
}

function Compare-TuiValue {
    <#
    .SYNOPSIS
    Compares two values for equality, handling nulls and complex types
    #>
    param($Value1, $Value2)
    
    if ($null -eq $Value1 -and $null -eq $Value2) { return $true }
    if ($null -eq $Value1 -or $null -eq $Value2) { return $false }
    
    if ($Value1 -is [hashtable] -and $Value2 -is [hashtable]) {
        if ($Value1.Count -ne $Value2.Count) { return $false }
        foreach ($key in $Value1.Keys) {
            if (-not $Value2.ContainsKey($key)) { return $false }
            if (-not (Compare-TuiValue $Value1[$key] $Value2[$key])) { return $false }
        }
        return $true
    }
    
    if ($Value1 -is [array] -and $Value2 -is [array]) {
        if ($Value1.Count -ne $Value2.Count) { return $false }
        for ($i = 0; $i -lt $Value1.Count; $i++) {
            if (-not (Compare-TuiValue $Value1[$i] $Value2[$i])) { return $false }
        }
        return $true
    }
    
    return $Value1 -eq $Value2
}

function Get-NestedProperty {
    param($Object, $Path)
    
    $parts = $Path -split '\.'
    $current = $Object
    
    foreach ($part in $parts) {
        if ($null -eq $current) { return $null }
        $current = $current[$part]
    }
    
    return $current
}

function global:Remove-TuiComponent {
    <#
    .SYNOPSIS
    Properly removes a component and cleans up references to prevent memory leaks
    
    .PARAMETER Component
    The component to remove
    #>
    param(
        [Parameter(Mandatory = $true)]
        [hashtable]$Component
    )
    
    try {
        # Remove event handlers if the component has an ID or Name
        $componentId = if ($Component.Id) { $Component.Id } elseif ($Component.Name) { $Component.Name } else { $null }
        
        if ($componentId -and (Get-Command -Name "Remove-ComponentEventHandlers" -ErrorAction SilentlyContinue)) {
            Remove-ComponentEventHandlers -ComponentId $componentId
        }
        
        # Clear focus if this component is focused
        if ($global:TuiState -and $global:TuiState.FocusedComponent -eq $Component) {
            if (Get-Command -Name "Clear-ComponentFocus" -ErrorAction SilentlyContinue) {
                Clear-ComponentFocus
            } else {
                $global:TuiState.FocusedComponent = $null
            }
        }
        
        # Break circular references
        if ($Component.Parent) {
            # Remove from parent's children collection
            if ($Component.Parent._children -and $Component.Name) {
                $Component.Parent._children.Remove($Component.Name)
            }
            if ($Component.Parent.Children) {
                $Component.Parent.Children = @($Component.Parent.Children | Where-Object { $_ -ne $Component })
            }
            $Component.Parent = $null
        }
        
        if ($Component.ParentScreen) {
            # Remove from parent screen's children
            if ($Component.ParentScreen._children -and $Component.Name) {
                $Component.ParentScreen._children.Remove($Component.Name)
            }
            # Remove from focusable names
            if ($Component.ParentScreen._focusableNames) {
                $Component.ParentScreen._focusableNames = @($Component.ParentScreen._focusableNames | Where-Object { $_ -ne $Component.Name })
            }
            $Component.ParentScreen = $null
        }
        
        # Clear children references
        if ($Component.Children) {
            foreach ($child in $Component.Children) {
                if ($child -is [hashtable]) {
                    $child.Parent = $null
                    $child.ParentScreen = $null
                }
            }
            $Component.Children = @()
        }
        
        if ($Component._children) {
            foreach ($childName in @($Component._children.Keys)) {
                $child = $Component._children[$childName]
                if ($child -is [hashtable]) {
                    $child.Parent = $null
                    $child.ParentScreen = $null
                }
            }
            $Component._children.Clear()
        }
        
        # Call component's dispose method if it exists
        if ($Component.Dispose) {
            try {
                & $Component.Dispose -self $Component
            } catch {
                Write-Warning "Component dispose error: $_"
            }
        }
        
        # Clear any async operations or timers
        if ($Component._timers) {
            foreach ($timer in $Component._timers) {
                if ($timer -and $timer.Enabled) {
                    $timer.Stop()
                    $timer.Dispose()
                }
            }
            $Component._timers = @()
        }
        
        # Clear state subscriptions
        if ($Component._stateSubscriptions) {
            foreach ($sub in $Component._stateSubscriptions) {
                if ($sub -and (Get-Command -Name "Unsubscribe-Event" -ErrorAction SilentlyContinue)) {
                    try {
                        Unsubscribe-Event -HandlerId $sub
                    } catch { }
                }
            }
            $Component._stateSubscriptions = @()
        }
        
        # Remove from global component registry if registered
        if ($global:TuiState -and $global:TuiState.Components) {
            $global:TuiState.Components = @($global:TuiState.Components | Where-Object { $_ -ne $Component })
        }
        
        Write-Verbose "Component removed: $componentId"
        
    } catch {
        Write-Warning "Error removing component: $_"
    }
}

# Export all functions
Export-ModuleMember -Function @(
    'Initialize-TuiFramework',
    'Invoke-TuiAsync',
    'Stop-AllTuiAsyncJobs',
    'Create-TuiState',
    'Compare-TuiValue',
    'Remove-TuiComponent',
    'Invoke-TuiMethod'
)
# TUI Component Library - COMPLIANT VERSION
# Stateful component factories following the canonical architecture

#region Basic Components

function global:New-TuiLabel {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "Label"
        IsFocusable = $false
        
        # Properties (from Props)
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 10
        Height = $Props.Height ?? 1
        Visible = $Props.Visible ?? $true
        Text = $Props.Text ?? ""
        ForegroundColor = $Props.ForegroundColor
        
        # Methods
        Render = {
            param($self)
            if (-not $self.Visible) { return }
            
            $fg = if ($self.ForegroundColor) { $self.ForegroundColor } else { Get-ThemeColor "Primary" }
            Write-BufferString -X $self.X -Y $self.Y -Text $self.Text -ForegroundColor $fg
        }
        
        HandleInput = {
            param($self, $Key)
            return $false
        }
    }
    
    return $component
}

function global:New-TuiButton {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "Button"
        IsFocusable = $true
        
        # Properties (from Props)
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 10
        Height = $Props.Height ?? 3
        Visible = $Props.Visible ?? $true
        Text = $Props.Text ?? "Button"
        
        # Internal State
        IsPressed = $false
        
        # Event Handlers (from Props)
        OnClick = $Props.OnClick
        
        # Methods
        Render = {
            param($self)
            if (-not $self.Visible) { return }
            
            $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Primary" }
            $bgColor = if ($self.IsPressed) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Background" }
            $fgColor = if ($self.IsPressed) { Get-ThemeColor "Background" } else { $borderColor }
            
            Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                -BorderColor $borderColor -BackgroundColor $bgColor
                
            $textX = $self.X + [Math]::Floor(($self.Width - $self.Text.Length) / 2)
            Write-BufferString -X $textX -Y ($self.Y + 1) -Text $self.Text `
                -ForegroundColor $fgColor -BackgroundColor $bgColor
        }
        
        HandleInput = {
            param($self, $Key)
            if ($Key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                if ($self.OnClick) {
                    & $self.OnClick
                }
                Request-TuiRefresh
                return $true
            }
            return $false
        }
    }
    
    return $component
}

function global:New-TuiTextBox {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "TextBox"
        IsFocusable = $true
        
        # Properties (from Props)
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 20
        Height = $Props.Height ?? 3
        Visible = $Props.Visible ?? $true
        Text = $Props.Text ?? ""
        Placeholder = $Props.Placeholder ?? ""
        MaxLength = $Props.MaxLength ?? 100
        
        # Internal State
        CursorPosition = $Props.CursorPosition ?? 0
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
        
        # Methods
        Render = {
            param($self)
            if (-not $self.Visible) { return }
            
            $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
            Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height 3 -BorderColor $borderColor
            
            $displayText = if ($self.Text) { $self.Text } else { "" }
            if ([string]::IsNullOrEmpty($displayText) -and -not $self.IsFocused) { 
                $displayText = if ($self.Placeholder) { $self.Placeholder } else { "" }
            }
            
            $maxDisplayLength = $self.Width - 4
            if ($displayText.Length -gt $maxDisplayLength) {
                $displayText = $displayText.Substring(0, $maxDisplayLength)
            }
            
            Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $displayText
            
            if ($self.IsFocused -and $self.CursorPosition -le $displayText.Length) {
                $cursorX = $self.X + 2 + $self.CursorPosition
                Write-BufferString -X $cursorX -Y ($self.Y + 1) -Text "_" `
                    -BackgroundColor (Get-ThemeColor "Accent")
            }
        }
        
        HandleInput = {
            param($self, $Key)
            $text = if ($self.Text) { $self.Text } else { "" }
            $cursorPos = if ($null -ne $self.CursorPosition) { $self.CursorPosition } else { 0 }
            $oldText = $text
            
            switch ($Key.Key) {
                ([ConsoleKey]::Backspace) { 
                    if ($cursorPos -gt 0) { 
                        $text = $text.Remove($cursorPos - 1, 1)
                        $cursorPos-- 
                    }
                }
                ([ConsoleKey]::Delete) { 
                    if ($cursorPos -lt $text.Length) { 
                        $text = $text.Remove($cursorPos, 1) 
                    }
                }
                ([ConsoleKey]::LeftArrow) { 
                    if ($cursorPos -gt 0) { $cursorPos-- }
                }
                ([ConsoleKey]::RightArrow) { 
                    if ($cursorPos -lt $text.Length) { $cursorPos++ }
                }
                ([ConsoleKey]::Home) { $cursorPos = 0 }
                ([ConsoleKey]::End) { $cursorPos = $text.Length }
                ([ConsoleKey]::V) {
                    # Handle Ctrl+V (paste)
                    if ($Key.Modifiers -band [ConsoleModifiers]::Control) {
                        try {
                            # Get clipboard text (Windows only)
                            $clipboardText = if (Get-Command Get-Clipboard -ErrorAction SilentlyContinue) {
                                Get-Clipboard -Format Text -ErrorAction SilentlyContinue
                            } else {
                                $null
                            }
                            
                            if ($clipboardText) {
                                # Remove newlines for single-line textbox
                                $clipboardText = $clipboardText -replace '[\r\n]+', ' '
                                
                                # Insert as much as will fit
                                $remainingSpace = $self.MaxLength - $text.Length
                                if ($remainingSpace -gt 0) {
                                    $toInsert = if ($clipboardText.Length -gt $remainingSpace) {
                                        $clipboardText.Substring(0, $remainingSpace)
                                    } else {
                                        $clipboardText
                                    }
                                    
                                    $text = $text.Insert($cursorPos, $toInsert)
                                    $cursorPos += $toInsert.Length
                                }
                            }
                        } catch {
                            # Silently ignore clipboard errors
                        }
                    } else {
                        # Regular 'V' key
                        if (-not [char]::IsControl($Key.KeyChar) -and $text.Length -lt $self.MaxLength) {
                            $text = $text.Insert($cursorPos, $Key.KeyChar)
                            $cursorPos++
                        } else {
                            return $false
                        }
                    }
                }
                default {
                    if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar) -and $text.Length -lt $self.MaxLength) {
                        $text = $text.Insert($cursorPos, $Key.KeyChar)
                        $cursorPos++
                    } else { 
                        return $false 
                    }
                }
            }
            
            if ($text -ne $oldText -or $cursorPos -ne $self.CursorPosition) {
                $self.Text = $text
                $self.CursorPosition = $cursorPos
                
                if ($self.OnChange) { 
                    & $self.OnChange -NewValue $text
                }
                Request-TuiRefresh
            }
            return $true
        }
    }
    
    return $component
}

function global:New-TuiCheckBox {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "CheckBox"
        IsFocusable = $true
        
        # Properties (from Props)
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 20
        Height = $Props.Height ?? 1
        Visible = $Props.Visible ?? $true
        Text = $Props.Text ?? "Checkbox"
        Checked = $Props.Checked ?? $false
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
        
        # Methods
        Render = {
            param($self)
            if (-not $self.Visible) { return }
            
            $fg = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Primary" }
            $checkbox = if ($self.Checked) { "[X]" } else { "[ ]" }
            Write-BufferString -X $self.X -Y $self.Y -Text "$checkbox $($self.Text)" -ForegroundColor $fg
        }
        
        HandleInput = {
            param($self, $Key)
            if ($Key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar)) {
                $self.Checked = -not $self.Checked
                
                if ($self.OnChange) { 
                    & $self.OnChange -NewValue $self.Checked 
                }
                Request-TuiRefresh
                return $true
            }
            return $false
        }
    }
    
    return $component
}

function global:New-TuiDropdown {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "Dropdown"
        IsFocusable = $true
        
        # Properties (from Props)
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 20
        Height = $Props.Height ?? 3
        Visible = $Props.Visible ?? $true
        Options = $Props.Options ?? @()
        Value = $Props.Value
        Placeholder = $Props.Placeholder ?? "Select..."
        
        # Internal State
        IsOpen = $false
        SelectedIndex = 0
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
        
        # Methods
        Render = {
            param($self)
            if (-not $self.Visible) { return }
            
            $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
            Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height 3 -BorderColor $borderColor
            
            $displayText = $self.Placeholder
            if ($self.Value -and $self.Options) {
                $selected = $self.Options | Where-Object { $_.Value -eq $self.Value } | Select-Object -First 1
                if ($selected) { $displayText = $selected.Display }
            }
            
            Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $displayText
            $indicator = if ($self.IsOpen) { "▲" } else { "▼" }
            Write-BufferString -X ($self.X + $self.Width - 3) -Y ($self.Y + 1) -Text $indicator
            
            if ($self.IsOpen -and $self.Options.Count -gt 0) {
                $listHeight = [Math]::Min($self.Options.Count + 2, 8)
                Write-BufferBox -X $self.X -Y ($self.Y + 3) -Width $self.Width -Height $listHeight `
                    -BorderColor $borderColor -BackgroundColor (Get-ThemeColor "Background")
                
                $displayCount = [Math]::Min($self.Options.Count, 6)
                for ($i = 0; $i -lt $displayCount; $i++) {
                    $option = $self.Options[$i]
                    $y = $self.Y + 4 + $i
                    $fg = if ($i -eq $self.SelectedIndex) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Primary" }
                    $bg = if ($i -eq $self.SelectedIndex) { Get-ThemeColor "Secondary" } else { Get-ThemeColor "Background" }
                    $text = $option.Display
                    if ($text.Length -gt ($self.Width - 4)) { 
                        $text = $text.Substring(0, $self.Width - 7) + "..." 
                    }
                    Write-BufferString -X ($self.X + 2) -Y $y -Text $text -ForegroundColor $fg -BackgroundColor $bg
                }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            if (-not $self.IsOpen) {
                if ($Key.Key -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar, [ConsoleKey]::DownArrow)) {
                    $self.IsOpen = $true
                    Request-TuiRefresh
                    return $true
                }
            } else {
                switch ($Key.Key) {
                    ([ConsoleKey]::UpArrow) { 
                        if ($self.SelectedIndex -gt 0) { 
                            $self.SelectedIndex--
                            Request-TuiRefresh 
                        }
                        return $true 
                    }
                    ([ConsoleKey]::DownArrow) { 
                        if ($self.SelectedIndex -lt ($self.Options.Count - 1)) { 
                            $self.SelectedIndex++
                            Request-TuiRefresh 
                        }
                        return $true 
                    }
                    ([ConsoleKey]::Enter) {
                        if ($self.Options.Count -gt 0) {
                            $selected = $self.Options[$self.SelectedIndex]
                            $self.Value = $selected.Value
                            
                            if ($self.OnChange) { 
                                & $self.OnChange -NewValue $selected.Value 
                            }
                        }
                        $self.IsOpen = $false
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::Escape) { 
                        $self.IsOpen = $false
                        Request-TuiRefresh
                        return $true 
                    }
                }
            }
            return $false
        }
    }
    
    return $component
}

function global:New-TuiProgressBar {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "ProgressBar"
        IsFocusable = $false
        
        # Properties (from Props)
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 20
        Height = $Props.Height ?? 1
        Visible = $Props.Visible ?? $true
        Value = $Props.Value ?? 0
        Max = $Props.Max ?? 100
        ShowPercent = $Props.ShowPercent ?? $false
        
        # Methods
        Render = {
            param($self)
            if (-not $self.Visible) { return }
            
            $percent = [Math]::Min(100, [Math]::Max(0, ($self.Value / $self.Max) * 100))
            $filled = [Math]::Floor(($self.Width - 2) * ($percent / 100))
            $empty = ($self.Width - 2) - $filled
            
            $bar = "█" * $filled + "░" * $empty
            Write-BufferString -X $self.X -Y $self.Y -Text "[$bar]" -ForegroundColor (Get-ThemeColor "Accent")
            
            if ($self.ShowPercent) {
                $percentText = "$([Math]::Round($percent))%"
                $textX = $self.X + [Math]::Floor(($self.Width - $percentText.Length) / 2)
                Write-BufferString -X $textX -Y $self.Y -Text $percentText -ForegroundColor (Get-ThemeColor "Primary")
            }
        }
        
        HandleInput = {
            param($self, $Key)
            return $false
        }
    }
    
    return $component
}

function global:New-TuiTextArea {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "TextArea"
        IsFocusable = $true
        
        # Properties (from Props)
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 40
        Height = $Props.Height ?? 6
        Visible = $Props.Visible ?? $true
        Text = $Props.Text ?? ""
        Placeholder = $Props.Placeholder ?? "Enter text..."
        WrapText = $Props.WrapText ?? $true
        
        # Internal State
        Lines = @($Props.Text -split "`n")
        CursorX = 0
        CursorY = 0
        ScrollOffset = 0
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
        
        # Methods
        Render = {
            param($self)
            if (-not $self.Visible) { return }
            
            $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
            Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height -BorderColor $borderColor
            
            $innerWidth = $self.Width - 4
            $innerHeight = $self.Height - 2
            $displayLines = @()
            if ($self.Lines.Count -eq 0) { $self.Lines = @("") }
            
            foreach ($line in $self.Lines) {
                if ($self.WrapText -and $line.Length -gt $innerWidth) {
                    for ($i = 0; $i -lt $line.Length; $i += $innerWidth) {
                        $displayLines += $line.Substring($i, [Math]::Min($innerWidth, $line.Length - $i))
                    }
                } else { 
                    $displayLines += $line 
                }
            }
            
            if ($displayLines.Count -eq 1 -and $displayLines[0] -eq "" -and -not $self.IsFocused) {
                Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $self.Placeholder
                return
            }
            
            $startLine = $self.ScrollOffset
            $endLine = [Math]::Min($displayLines.Count - 1, $startLine + $innerHeight - 1)
            
            for ($i = $startLine; $i -le $endLine; $i++) {
                $y = $self.Y + 1 + ($i - $startLine)
                $line = $displayLines[$i]
                Write-BufferString -X ($self.X + 2) -Y $y -Text $line
            }
            
            if ($self.IsFocused -and $self.CursorY -ge $startLine -and $self.CursorY -le $endLine) {
                $cursorScreenY = $self.Y + 1 + ($self.CursorY - $startLine)
                $cursorX = [Math]::Min($self.CursorX, $displayLines[$self.CursorY].Length)
                Write-BufferString -X ($self.X + 2 + $cursorX) -Y $cursorScreenY -Text "_" `
                    -BackgroundColor (Get-ThemeColor "Accent")
            }
            
            if ($displayLines.Count -gt $innerHeight) {
                $scrollbarHeight = $innerHeight
                $scrollPosition = [Math]::Floor(($self.ScrollOffset / ($displayLines.Count - $innerHeight)) * ($scrollbarHeight - 1))
                for ($i = 0; $i -lt $scrollbarHeight; $i++) {
                    $char = if ($i -eq $scrollPosition) { "█" } else { "│" }
                    $color = if ($i -eq $scrollPosition) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Subtle" }
                    Write-BufferString -X ($self.X + $self.Width - 2) -Y ($self.Y + 1 + $i) -Text $char -ForegroundColor $color
                }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            $lines = $self.Lines
            $cursorY = $self.CursorY
            $cursorX = $self.CursorX
            $innerHeight = $self.Height - 2
            
            switch ($Key.Key) {
                ([ConsoleKey]::UpArrow) {
                    if ($cursorY -gt 0) {
                        $cursorY--
                        $cursorX = [Math]::Min($cursorX, $lines[$cursorY].Length)
                        if ($cursorY -lt $self.ScrollOffset) { 
                            $self.ScrollOffset = $cursorY 
                        }
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    if ($cursorY -lt $lines.Count - 1) {
                        $cursorY++
                        $cursorX = [Math]::Min($cursorX, $lines[$cursorY].Length)
                        if ($cursorY -ge $self.ScrollOffset + $innerHeight) { 
                            $self.ScrollOffset = $cursorY - $innerHeight + 1 
                        }
                    }
                }
                ([ConsoleKey]::LeftArrow) {
                    if ($cursorX -gt 0) { 
                        $cursorX-- 
                    } elseif ($cursorY -gt 0) { 
                        $cursorY--
                        $cursorX = $lines[$cursorY].Length 
                    }
                }
                ([ConsoleKey]::RightArrow) {
                    if ($cursorX -lt $lines[$cursorY].Length) { 
                        $cursorX++ 
                    } elseif ($cursorY -lt $lines.Count - 1) { 
                        $cursorY++
                        $cursorX = 0 
                    }
                }
                ([ConsoleKey]::Home) { $cursorX = 0 }
                ([ConsoleKey]::End) { $cursorX = $lines[$cursorY].Length }
                ([ConsoleKey]::Enter) {
                    $currentLine = $lines[$cursorY]
                    $beforeCursor = $currentLine.Substring(0, $cursorX)
                    $afterCursor = $currentLine.Substring($cursorX)
                    $lines[$cursorY] = $beforeCursor
                    $lines = @($lines[0..$cursorY]) + @($afterCursor) + @($lines[($cursorY + 1)..($lines.Count - 1)])
                    $cursorY++
                    $cursorX = 0
                    if ($cursorY -ge $self.ScrollOffset + $innerHeight) { 
                        $self.ScrollOffset = $cursorY - $innerHeight + 1 
                    }
                }
                ([ConsoleKey]::Backspace) {
                    if ($cursorX -gt 0) { 
                        $lines[$cursorY] = $lines[$cursorY].Remove($cursorX - 1, 1)
                        $cursorX-- 
                    } elseif ($cursorY -gt 0) {
                        $prevLineLength = $lines[$cursorY - 1].Length
                        $lines[$cursorY - 1] += $lines[$cursorY]
                        $newLines = @()
                        for ($i = 0; $i -lt $lines.Count; $i++) { 
                            if ($i -ne $cursorY) { $newLines += $lines[$i] } 
                        }
                        $lines = $newLines
                        $cursorY--
                        $cursorX = $prevLineLength
                    }
                }
                ([ConsoleKey]::Delete) {
                    if ($cursorX -lt $lines[$cursorY].Length) { 
                        $lines[$cursorY] = $lines[$cursorY].Remove($cursorX, 1) 
                    } elseif ($cursorY -lt $lines.Count - 1) {
                        $lines[$cursorY] += $lines[$cursorY + 1]
                        $newLines = @()
                        for ($i = 0; $i -lt $lines.Count; $i++) { 
                            if ($i -ne ($cursorY + 1)) { $newLines += $lines[$i] } 
                        }
                        $lines = $newLines
                    }
                }
                ([ConsoleKey]::V) {
                    # Handle Ctrl+V (paste)
                    if ($Key.Modifiers -band [ConsoleModifiers]::Control) {
                        try {
                            # Get clipboard text (Windows only)
                            $clipboardText = if (Get-Command Get-Clipboard -ErrorAction SilentlyContinue) {
                                Get-Clipboard -Format Text -ErrorAction SilentlyContinue
                            } else {
                                $null
                            }
                            
                            if ($clipboardText) {
                                # Split clipboard text into lines
                                $clipboardLines = $clipboardText -split '[\r\n]+'
                                
                                if ($clipboardLines.Count -eq 1) {
                                    # Single line paste - insert at cursor
                                    $lines[$cursorY] = $lines[$cursorY].Insert($cursorX, $clipboardLines[0])
                                    $cursorX += $clipboardLines[0].Length
                                } else {
                                    # Multi-line paste
                                    $currentLine = $lines[$cursorY]
                                    $beforeCursor = $currentLine.Substring(0, $cursorX)
                                    $afterCursor = $currentLine.Substring($cursorX)
                                    
                                    # First line
                                    $lines[$cursorY] = $beforeCursor + $clipboardLines[0]
                                    
                                    # Insert middle lines
                                    $insertLines = @()
                                    for ($i = 1; $i -lt $clipboardLines.Count - 1; $i++) {
                                        $insertLines += $clipboardLines[$i]
                                    }
                                    
                                    # Last line
                                    $lastLine = $clipboardLines[-1] + $afterCursor
                                    $insertLines += $lastLine
                                    
                                    # Insert all new lines
                                    $newLines = @()
                                    for ($i = 0; $i -le $cursorY; $i++) {
                                        $newLines += $lines[$i]
                                    }
                                    $newLines += $insertLines
                                    for ($i = $cursorY + 1; $i -lt $lines.Count; $i++) {
                                        $newLines += $lines[$i]
                                    }
                                    
                                    $lines = $newLines
                                    $cursorY += $clipboardLines.Count - 1
                                    $cursorX = $clipboardLines[-1].Length
                                }
                                
                                # Adjust scroll if needed
                                $innerHeight = $self.Height - 2
                                if ($cursorY -ge $self.ScrollOffset + $innerHeight) { 
                                    $self.ScrollOffset = $cursorY - $innerHeight + 1 
                                }
                            }
                        } catch {
                            # Silently ignore clipboard errors
                        }
                    } else {
                        # Regular 'V' key
                        if (-not [char]::IsControl($Key.KeyChar)) {
                            $lines[$cursorY] = $lines[$cursorY].Insert($cursorX, $Key.KeyChar)
                            $cursorX++
                        } else {
                            return $false
                        }
                    }
                }
                default {
                    if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar)) {
                        $lines[$cursorY] = $lines[$cursorY].Insert($cursorX, $Key.KeyChar)
                        $cursorX++
                    } else { 
                        return $false 
                    }
                }
            }
            
            $self.Lines = $lines
            $self.CursorX = $cursorX
            $self.CursorY = $cursorY
            $self.Text = $lines -join "`n"
            
            if ($self.OnChange) { 
                & $self.OnChange -NewValue $self.Text 
            }
            Request-TuiRefresh
            return $true
        }
    }
    
    return $component
}

#endregion

#region DateTime Components

function global:New-TuiDatePicker {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "DatePicker"
        IsFocusable = $true
        
        # Properties (from Props)
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 20
        Height = $Props.Height ?? 3
        Visible = $Props.Visible ?? $true
        Value = $Props.Value ?? (Get-Date)
        Format = $Props.Format ?? "yyyy-MM-dd"
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
        
        # Methods
        Render = {
            param($self)
            if (-not $self.Visible) { return }
            
            $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
            Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height 3 -BorderColor $borderColor
            $dateStr = $self.Value.ToString($self.Format)
            
            # Truncate date string if too long
            $maxLength = $self.Width - 6
            if ($dateStr.Length -gt $maxLength) {
                $dateStr = $dateStr.Substring(0, $maxLength)
            }
            
            Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $dateStr
            if ($self.IsFocused -and $self.Width -ge 6) { 
                Write-BufferString -X ($self.X + $self.Width - 4) -Y ($self.Y + 1) -Text "📅" -ForegroundColor $borderColor 
            }
        }
        
        HandleInput = {
            param($self, $Key)
            $date = $self.Value
            $handled = $true
            
            switch ($Key.Key) {
                ([ConsoleKey]::UpArrow)   { $date = $date.AddDays(1) }
                ([ConsoleKey]::DownArrow) { $date = $date.AddDays(-1) }
                ([ConsoleKey]::PageUp)    { $date = $date.AddMonths(1) }
                ([ConsoleKey]::PageDown)  { $date = $date.AddMonths(-1) }
                ([ConsoleKey]::Home)      { $date = Get-Date }
                ([ConsoleKey]::T) { 
                    if ($Key.Modifiers -band [ConsoleModifiers]::Control) { 
                        $date = Get-Date 
                    } else { 
                        $handled = $false 
                    } 
                }
                default { $handled = $false }
            }
            
            if ($handled) {
                $self.Value = $date
                if ($self.OnChange) { 
                    & $self.OnChange -NewValue $date 
                }
                Request-TuiRefresh
            }
            return $handled
        }
    }
    
    return $component
}

function global:New-TuiTimePicker {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "TimePicker"
        IsFocusable = $true
        
        # Properties (from Props)
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 15
        Height = $Props.Height ?? 3
        Visible = $Props.Visible ?? $true
        Hour = $Props.Hour ?? 0
        Minute = $Props.Minute ?? 0
        Format24H = $Props.Format24H ?? $true
        
        # Event Handlers (from Props)
        OnChange = $Props.OnChange
        
        # Methods
        Render = {
            param($self)
            if (-not $self.Visible) { return }
            
            $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
            Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height 3 -BorderColor $borderColor
            
            if ($self.Format24H) { 
                $timeStr = "{0:D2}:{1:D2}" -f $self.Hour, $self.Minute 
            } else {
                $displayHour = if ($self.Hour -eq 0) { 12 } elseif ($self.Hour -gt 12) { $self.Hour - 12 } else { $self.Hour }
                $ampm = if ($self.Hour -lt 12) { "AM" } else { "PM" }
                $timeStr = "{0:D2}:{1:D2} {2}" -f $displayHour, $self.Minute, $ampm
            }
            
            # Truncate time string if too long
            $maxLength = $self.Width - 6
            if ($timeStr.Length -gt $maxLength) {
                $timeStr = $timeStr.Substring(0, $maxLength)
            }
            
            Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $timeStr
            if ($self.IsFocused -and $self.Width -ge 6) { 
                Write-BufferString -X ($self.X + $self.Width - 4) -Y ($self.Y + 1) -Text "⏰" -ForegroundColor $borderColor 
            }
        }
        
        HandleInput = {
            param($self, $Key)
            $handled = $true
            $hour = $self.Hour
            $minute = $self.Minute
            
            switch ($Key.Key) {
                ([ConsoleKey]::UpArrow) { 
                    $minute = ($minute + 15) % 60
                    if ($minute -eq 0) { $hour = ($hour + 1) % 24 } 
                }
                ([ConsoleKey]::DownArrow) { 
                    $minute = ($minute - 15 + 60) % 60
                    if ($minute -eq 45) { $hour = ($hour - 1 + 24) % 24 } 
                }
                ([ConsoleKey]::LeftArrow)  { $hour = ($hour - 1 + 24) % 24 }
                ([ConsoleKey]::RightArrow) { $hour = ($hour + 1) % 24 }
                default { $handled = $false }
            }
            
            if ($handled) {
                $self.Hour = $hour
                $self.Minute = $minute
                
                if ($self.OnChange) { 
                    & $self.OnChange -NewHour $hour -NewMinute $minute 
                }
                Request-TuiRefresh
            }
            return $handled
        }
    }
    
    return $component
}

#endregion

#region Data Display Components

function global:New-TuiTable {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "Table"
        IsFocusable = $true
        
        # Properties (from Props)
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 60
        Height = $Props.Height ?? 15
        Visible = $Props.Visible ?? $true
        Columns = $Props.Columns ?? @()
        Rows = $Props.Rows ?? @()
        
        # Internal State
        SelectedRow = 0
        ScrollOffset = 0
        SortColumn = $null
        SortAscending = $true
        
        # Event Handlers (from Props)
        OnRowSelect = $Props.OnRowSelect
        
        # Methods
        Render = {
            param($self)
            if (-not $self.Visible -or $self.Columns.Count -eq 0) { return }
            
            $borderColor = if ($self.IsFocused) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
            Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height -BorderColor $borderColor
            
            $totalWidth = $self.Width - 4
            $colWidth = [Math]::Floor($totalWidth / $self.Columns.Count)
            $headerY = $self.Y + 1
            $currentX = $self.X + 2
            
            # Draw headers
            foreach ($col in $self.Columns) {
                $header = $col.Header
                if ($col.Name -eq $self.SortColumn) { 
                    $arrow = if ($self.SortAscending) { "▲" } else { "▼" }
                    $header = "$header $arrow" 
                }
                if ($header.Length -gt $colWidth - 1) { 
                    $header = $header.Substring(0, $colWidth - 4) + "..." 
                }
                Write-BufferString -X $currentX -Y $headerY -Text $header -ForegroundColor (Get-ThemeColor "Header")
                $currentX += $colWidth
            }
            
            # Header separator
            Write-BufferString -X ($self.X + 1) -Y ($headerY + 1) -Text ("─" * ($self.Width - 2)) -ForegroundColor $borderColor
            
            # Draw rows
            $visibleRows = $self.Height - 5
            $startIdx = $self.ScrollOffset
            $endIdx = [Math]::Min($self.Rows.Count - 1, $startIdx + $visibleRows - 1)
            
            for ($i = $startIdx; $i -le $endIdx; $i++) {
                $row = $self.Rows[$i]
                $rowY = ($headerY + 2) + ($i - $startIdx)
                $currentX = $self.X + 2
                $isSelected = ($i -eq $self.SelectedRow -and $self.IsFocused)
                $bgColor = if ($isSelected) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Background" }
                $fgColor = if ($isSelected) { Get-ThemeColor "Background" } else { Get-ThemeColor "Primary" }
                
                if ($isSelected) { 
                    Write-BufferString -X ($self.X + 1) -Y $rowY -Text (" " * ($self.Width - 2)) -BackgroundColor $bgColor 
                }
                
                foreach ($col in $self.Columns) {
                    $value = $row.($col.Name)
                    if ($null -eq $value) { $value = "" }
                    $text = $value.ToString()
                    if ($text.Length -gt $colWidth - 1) { 
                        $text = $text.Substring(0, $colWidth - 4) + "..." 
                    }
                    Write-BufferString -X $currentX -Y $rowY -Text $text -ForegroundColor $fgColor -BackgroundColor $bgColor
                    $currentX += $colWidth
                }
            }
            
            # Scrollbar
            if ($self.Rows.Count -gt $visibleRows) {
                $scrollbarHeight = $visibleRows
                $scrollPosition = [Math]::Floor(($self.ScrollOffset / ($self.Rows.Count - $visibleRows)) * ($scrollbarHeight - 1))
                for ($i = 0; $i -lt $scrollbarHeight; $i++) {
                    $char = if ($i -eq $scrollPosition) { "█" } else { "│" }
                    $color = if ($i -eq $scrollPosition) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Subtle" }
                    Write-BufferString -X ($self.X + $self.Width - 2) -Y ($headerY + 2 + $i) -Text $char -ForegroundColor $color
                }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            if ($self.Rows.Count -eq 0) { return $false }
            
            $visibleRows = $self.Height - 5
            $handled = $true
            
            switch ($Key.Key) {
                ([ConsoleKey]::UpArrow) { 
                    if ($self.SelectedRow -gt 0) { 
                        $self.SelectedRow--
                        if ($self.SelectedRow -lt $self.ScrollOffset) { 
                            $self.ScrollOffset = $self.SelectedRow 
                        }
                        Request-TuiRefresh 
                    } 
                }
                ([ConsoleKey]::DownArrow) { 
                    if ($self.SelectedRow -lt $self.Rows.Count - 1) { 
                        $self.SelectedRow++
                        if ($self.SelectedRow -ge $self.ScrollOffset + $visibleRows) { 
                            $self.ScrollOffset = $self.SelectedRow - $visibleRows + 1 
                        }
                        Request-TuiRefresh 
                    } 
                }
                ([ConsoleKey]::PageUp) { 
                    $self.SelectedRow = [Math]::Max(0, $self.SelectedRow - $visibleRows)
                    $self.ScrollOffset = [Math]::Max(0, $self.ScrollOffset - $visibleRows)
                    Request-TuiRefresh 
                }
                ([ConsoleKey]::PageDown) { 
                    $self.SelectedRow = [Math]::Min($self.Rows.Count - 1, $self.SelectedRow + $visibleRows)
                    $maxScroll = [Math]::Max(0, $self.Rows.Count - $visibleRows)
                    $self.ScrollOffset = [Math]::Min($maxScroll, $self.ScrollOffset + $visibleRows)
                    Request-TuiRefresh 
                }
                ([ConsoleKey]::Home) { 
                    $self.SelectedRow = 0
                    $self.ScrollOffset = 0
                    Request-TuiRefresh 
                }
                ([ConsoleKey]::End) { 
                    $self.SelectedRow = $self.Rows.Count - 1
                    $self.ScrollOffset = [Math]::Max(0, $self.Rows.Count - $visibleRows)
                    Request-TuiRefresh 
                }
                ([ConsoleKey]::Enter) { 
                    if ($self.OnRowSelect) { 
                        & $self.OnRowSelect -Row $self.Rows[$self.SelectedRow] -Index $self.SelectedRow 
                    } 
                }
                default {
                    if ($Key.KeyChar -match '\d') {
                        $colIndex = [int]$Key.KeyChar.ToString() - 1
                        if ($colIndex -ge 0 -and $colIndex -lt $self.Columns.Count) {
                            $colName = $self.Columns[$colIndex].Name
                            if ($self.SortColumn -eq $colName) { 
                                $self.SortAscending = -not $self.SortAscending 
                            } else { 
                                $self.SortColumn = $colName
                                $self.SortAscending = $true 
                            }
                            $self.Rows = $self.Rows | Sort-Object -Property $colName -Descending:(-not $self.SortAscending)
                            Request-TuiRefresh
                        }
                    } else { 
                        $handled = $false 
                    }
                }
            }
            return $handled
        }
    }
    
    return $component
}

function global:New-TuiChart {
    param([hashtable]$Props = @{})
    
    $component = @{
        # Metadata
        Type = "Chart"
        IsFocusable = $false
        
        # Properties (from Props)
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 40
        Height = $Props.Height ?? 10
        Visible = $Props.Visible ?? $true
        ChartType = $Props.ChartType ?? "Bar"
        Data = $Props.Data ?? @()
        ShowValues = $Props.ShowValues ?? $true
        
        # Methods
        Render = {
            param($self)
            if (-not $self.Visible -or $self.Data.Count -eq 0) { return }
            
            switch ($self.ChartType) {
                "Bar" {
                    $maxValue = ($self.Data | Measure-Object -Property Value -Maximum).Maximum
                    if ($maxValue -eq 0) { $maxValue = 1 }
                    $chartHeight = $self.Height - 2
                    $barWidth = [Math]::Floor(($self.Width - 4) / $self.Data.Count)
                    
                    for ($i = 0; $i -lt $self.Data.Count; $i++) {
                        $item = $self.Data[$i]
                        $barHeight = [Math]::Floor(($item.Value / $maxValue) * $chartHeight)
                        $barX = $self.X + 2 + ($i * $barWidth)
                        
                        for ($y = 0; $y -lt $barHeight; $y++) { 
                            $barY = $self.Y + $self.Height - 2 - $y
                            Write-BufferString -X $barX -Y $barY -Text ("█" * ($barWidth - 1)) -ForegroundColor (Get-ThemeColor "Accent") 
                        }
                        
                        if ($item.Label -and $barWidth -gt 3) { 
                            $label = $item.Label
                            if ($label.Length -gt $barWidth - 1) { 
                                $label = $label.Substring(0, $barWidth - 2) 
                            }
                            Write-BufferString -X $barX -Y ($self.Y + $self.Height - 1) -Text $label -ForegroundColor (Get-ThemeColor "Subtle") 
                        }
                        
                        if ($self.ShowValues -and $barHeight -gt 0) { 
                            $valueText = $item.Value.ToString()
                            Write-BufferString -X $barX -Y ($self.Y + $self.Height - 3 - $barHeight) -Text $valueText -ForegroundColor (Get-ThemeColor "Primary") 
                        }
                    }
                }
                "Sparkline" {
                    $width = $self.Width - 2
                    $height = $self.Height - 1
                    $maxValue = ($self.Data | Measure-Object -Maximum).Maximum
                    if ($maxValue -eq 0) { $maxValue = 1 }
                    
                    $sparkChars = @(" ", " ", "▂", "▃", "▄", "▅", "▆", "▇", "█")
                    $sparkline = ""
                    
                    foreach ($value in $self.Data) { 
                        $normalized = ($value / $maxValue)
                        $charIndex = [Math]::Floor($normalized * ($sparkChars.Count - 1))
                        $sparkline += $sparkChars[$charIndex] 
                    }
                    
                    if ($sparkline.Length -gt $width) { 
                        $sparkline = $sparkline.Substring($sparkline.Length - $width) 
                    } else { 
                        $sparkline = $sparkline.PadLeft($width) 
                    }
                    
                    Write-BufferString -X ($self.X + 1) -Y ($self.Y + [Math]::Floor($height / 2)) -Text $sparkline -ForegroundColor (Get-ThemeColor "Accent")
                }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            return $false
        }
    }
    
    return $component
}

#endregion

#region Container Components

function global:New-TuiPanel {
    <#
    .SYNOPSIS
    Creates a container component that manages child layout automatically
    
    .PARAMETER Props
    Hashtable of properties including:
    - Layout: 'Stack' (default) or 'Grid'
    - Orientation: 'Vertical' (default) or 'Horizontal' (for Stack layout)
    - Spacing: Space between children (default 1)
    - Padding: Internal padding (default 1)
    - ShowBorder: Whether to draw a border (default false)
    #>
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "Panel"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 40
        Height = $Props.Height ?? 20
        Visible = $Props.Visible ?? $true
        IsFocusable = $Props.IsFocusable ?? $false
        Children = @()
        
        # Layout properties
        Layout = $Props.Layout ?? 'Stack'
        Orientation = $Props.Orientation ?? 'Vertical'
        Spacing = $Props.Spacing ?? 1
        Padding = $Props.Padding ?? 1
        ShowBorder = $Props.ShowBorder ?? $false
        Title = $Props.Title
        
        # Methods
        AddChild = {
            param($self, $Child)
            $self.Children += $Child
            # Immediately recalculate layout
            & $self._RecalculateLayout -self $self
        }
        
        RemoveChild = {
            param($self, $Child)
            $self.Children = @($self.Children | Where-Object { $_ -ne $Child })
            & $self._RecalculateLayout -self $self
        }
        
        _RecalculateLayout = {
            param($self)
            
            # Calculate content area
            $contentX = $self.X + $self.Padding
            $contentY = $self.Y + $self.Padding
            $contentWidth = $self.Width - ($self.Padding * 2)
            $contentHeight = $self.Height - ($self.Padding * 2)
            
            if ($self.ShowBorder) {
                $contentX++
                $contentY++
                $contentWidth -= 2
                $contentHeight -= 2
            }
            
            # Apply layout
            switch ($self.Layout) {
                'Stack' {
                    $currentX = $contentX
                    $currentY = $contentY
                    
                    foreach ($child in $self.Children) {
                        if (-not $child.Visible) { continue }
                        
                        $child.X = $currentX
                        $child.Y = $currentY
                        
                        # Constrain child size to panel
                        if ($self.Orientation -eq 'Vertical') {
                            $child.Width = [Math]::Min($child.Width, $contentWidth)
                            $currentY += $child.Height + $self.Spacing
                        } else {
                            $child.Height = [Math]::Min($child.Height, $contentHeight)
                            $currentX += $child.Width + $self.Spacing
                        }
                    }
                }
                
                'Grid' {
                    # Simple grid - auto columns based on width
                    if ($self.Children.Count -eq 0) { return }
                    
                    # Estimate columns based on average child width
                    $avgWidth = 20
                    if ($self.Children[0].Width) {
                        $avgWidth = $self.Children[0].Width
                    }
                    
                    $cols = [Math]::Max(1, [Math]::Floor($contentWidth / ($avgWidth + $self.Spacing)))
                    $cellWidth = [Math]::Floor(($contentWidth - ($cols - 1) * $self.Spacing) / $cols)
                    
                    $row = 0
                    $col = 0
                    
                    foreach ($child in $self.Children) {
                        if (-not $child.Visible) { continue }
                        
                        $child.X = $contentX + ($col * ($cellWidth + $self.Spacing))
                        $child.Y = $contentY + ($row * ($child.Height + $self.Spacing))
                        $child.Width = [Math]::Min($child.Width, $cellWidth)
                        
                        $col++
                        if ($col -ge $cols) {
                            $col = 0
                            $row++
                        }
                    }
                }
            }
        }
        
        Render = {
            param($self)
            if (-not $self.Visible) { return }
            
            # Draw border if requested
            if ($self.ShowBorder) {
                $borderColor = if ($self.IsFocused) {
                    Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
                } else {
                    Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
                }
                
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -BorderColor $borderColor -Title $self.Title
            }
            
            # Render children
            foreach ($child in $self.Children) {
                if ($child.Visible -and $child.Render) {
                    & $child.Render -self $child
                }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            # Panels don't handle input directly, but could implement focus management
            return $false
        }
    }
    
    # Initial layout calculation
    & $component._RecalculateLayout -self $component
    
    return $component
}

#endregion

Export-ModuleMember -Function @(
    # Basic Components
    'New-TuiLabel',
    'New-TuiButton',
    'New-TuiTextBox',
    'New-TuiCheckBox',
    'New-TuiDropdown',
    'New-TuiProgressBar',
    'New-TuiTextArea',
    # DateTime Components
    'New-TuiDatePicker',
    'New-TuiTimePicker',
    # Data Display Components
    'New-TuiTable',
    'New-TuiChart',
    # Container Components
    'New-TuiPanel'
)
# Advanced Data Components Module
# Enhanced data display components with sorting, filtering, and pagination

#region Advanced Table Component

function global:New-TuiDataTable {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "DataTable"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 80
        Height = $Props.Height ?? 20
        Title = $Props.Title
        ShowBorder = $Props.ShowBorder ?? $true  # <-- NEW: Controls whether component draws its own border
        Data = $Props.Data ?? @()
        Columns = $Props.Columns ?? @()
        SelectedRow = 0
        ScrollOffset = 0
        SortColumn = $null
        SortDirection = "Ascending"
        FilterText = ""
        FilterColumn = $null
        PageSize = 0  # 0 = auto-calculate
        CurrentPage = 0
        ShowHeader = $Props.ShowHeader ?? $true
        ShowFooter = $Props.ShowFooter ?? $true
        ShowRowNumbers = $Props.ShowRowNumbers ?? $false
        AllowSort = $Props.AllowSort ?? $true
        AllowFilter = $Props.AllowFilter ?? $true
        AllowSelection = $Props.AllowSelection ?? $true
        MultiSelect = $Props.MultiSelect ?? $false
        SelectedRows = @()
        IsFocusable = $Props.IsFocusable ?? $true
        FilteredData = @()
        ProcessedData = @()
        
        # Event handlers from Props
        OnRowSelect = $Props.OnRowSelect
        OnSelectionChange = $Props.OnSelectionChange
        
        # Column configuration example:
        # @{
        #     Name = "PropertyName"
        #     Header = "Display Header"
        #     Width = 20
        #     Align = "Left"  # Left, Right, Center
        #     Format = { param($value) $value.ToString("N2") }
        #     Sortable = $true
        #     Filterable = $true
        #     Color = { param($value, $row) if ($value -lt 0) { "Red" } else { "Green" } }
        # }
        
        ProcessData = {
            param($self)
            # Filter data
            if ([string]::IsNullOrWhiteSpace($self.FilterText)) {
                $self.FilteredData = $self.Data
            } else {
                if ($self.FilterColumn) {
                    # Filter specific column
                    $self.FilteredData = @($self.Data | Where-Object {
                        $value = $_."$($self.FilterColumn)"
                        $value -and $value.ToString() -like "*$($self.FilterText)*"
                    })
                } else {
                    # Filter all columns
                    $self.FilteredData = @($self.Data | Where-Object {
                        $row = $_
                        $matched = $false
                        foreach ($col in $self.Columns) {
                            if ($col.Filterable -ne $false) {
                                $value = $row."$($col.Name)"
                                if ($value -and $value.ToString() -like "*$($self.FilterText)*") {
                                    $matched = $true
                                    break
                                }
                            }
                        }
                        $matched
                    })
                }
            }
            
            # Sort data
            if ($self.SortColumn -and $self.AllowSort) {
                $self.ProcessedData = $self.FilteredData | Sort-Object -Property $self.SortColumn -Descending:($self.SortDirection -eq "Descending")
            } else {
                $self.ProcessedData = $self.FilteredData
            }
            
            # Reset selection if needed
            if ($self.SelectedRow -ge $self.ProcessedData.Count) {
                $self.SelectedRow = [Math]::Max(0, $self.ProcessedData.Count - 1)
            }
            
            # Calculate page size if auto
            if ($self.PageSize -eq 0) {
                $headerLines = if ($self.ShowHeader) { 3 } else { 0 }
                $footerLines = if ($self.ShowFooter) { 2 } else { 0 }
                $filterLines = if ($self.AllowFilter) { 2 } else { 0 }
                $borderAdjust = if ($self.ShowBorder) { 2 } else { 0 }
                $self.PageSize = $self.Height - $headerLines - $footerLines - $filterLines - $borderAdjust
            }
            
            # Adjust current page
            $totalPages = [Math]::Ceiling($self.ProcessedData.Count / [Math]::Max(1, $self.PageSize))
            if ($self.CurrentPage -ge $totalPages) {
                $self.CurrentPage = [Math]::Max(0, $totalPages - 1)
            }
        }
        
        Render = {
            param($self)
            
            # Debug: Check data state for Quick Actions
            if ($self.Title -eq "Quick Actions") {
                Write-Log -Level Debug -Message "Rendering Quick Actions DataTable:"
                Write-Log -Level Debug -Message "  Data count: $($self.Data.Count)"
                Write-Log -Level Debug -Message "  ProcessedData count: $($self.ProcessedData.Count)"
                if ($self.ProcessedData.Count -gt 0) {
                    Write-Log -Level Debug -Message "  First row: $($self.ProcessedData[0] | ConvertTo-Json -Compress)"
                }
                $colInfo = $self.Columns | ForEach-Object { "$($_.Name):$($_.CalculatedWidth)" }
                Write-Log -Level Debug -Message "  Columns: $($colInfo -join ', ')"
            }
            
            # Process data first
            & $self.ProcessData -self $self
            
            # Only draw border if ShowBorder is true
            $contentX = $self.X
            $contentY = $self.Y
            $contentWidth = $self.Width
            $contentHeight = $self.Height
            
            if ($self.ShowBorder) {
                $borderColor = if ($self.IsFocusable -and $self.IsFocused) { 
                    Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
                } else { 
                    Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
                }
                
                Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                    -BorderColor $borderColor -Title " $($self.Title ?? 'Data Table') "
                
                # Adjust content area for border
                $contentX = $self.X + 1
                $contentY = $self.Y + 1
                $contentWidth = $self.Width - 2
                $contentHeight = $self.Height - 2
            }
            
            $currentY = $contentY
            $innerWidth = $contentWidth
            
            # Filter bar
            if ($self.AllowFilter) {
                $filterBg = if ($self.FilterText) { Get-ThemeColor "Warning" -Default ([ConsoleColor]::Yellow) } else { Get-ThemeColor "Background" -Default ([ConsoleColor]::Black) }
                $filterFg = if ($self.FilterText) { Get-ThemeColor "Background" -Default ([ConsoleColor]::Black) } else { Get-ThemeColor "Subtle" -Default ([ConsoleColor]::DarkGray) }
                
                Write-BufferString -X ($contentX + 1) -Y $currentY -Text "Filter: " -ForegroundColor (Get-ThemeColor "Primary" -Default ([ConsoleColor]::White))
                
                $filterDisplayText = if ($self.FilterText) { $self.FilterText } else { "Type to filter..." }
                Write-BufferString -X ($contentX + 9) -Y $currentY -Text $filterDisplayText `
                    -ForegroundColor $filterFg -BackgroundColor $filterBg
                
                if ($self.FilterColumn) {
                    $colName = ($self.Columns | Where-Object { $_.Name -eq $self.FilterColumn }).Header ?? $self.FilterColumn
                    Write-BufferString -X ($contentX + $contentWidth - 19) -Y $currentY `
                        -Text "Column: $colName" -ForegroundColor (Get-ThemeColor "Info" -Default ([ConsoleColor]::Blue))
                }
                
                $currentY += 2
            }
            
            # Calculate column widths
            $totalDefinedWidth = ($self.Columns | Where-Object { $_.Width } | Measure-Object -Property Width -Sum).Sum ?? 0
            $flexColumns = @($self.Columns | Where-Object { -not $_.Width })
            $columnSeparators = [Math]::Max(0, $self.Columns.Count - 1)  # Space between columns
            $remainingWidth = $innerWidth - $totalDefinedWidth - ($self.ShowRowNumbers ? 5 : 0) - $columnSeparators
            $flexWidth = if ($flexColumns.Count -gt 0) { [Math]::Floor($remainingWidth / $flexColumns.Count) } else { 0 }
            
            foreach ($col in $flexColumns) {
                $col.CalculatedWidth = [Math]::Max(5, $flexWidth)
            }
            foreach ($col in $self.Columns | Where-Object { $_.Width }) {
                $col.CalculatedWidth = $_.Width
            }
            
            # Header
            if ($self.ShowHeader) {
                $headerX = $contentX
                
                # Row number header
                if ($self.ShowRowNumbers) {
                    Write-BufferString -X $headerX -Y $currentY -Text "#".PadRight(4) `
                        -ForegroundColor (Get-ThemeColor "Header" -Default ([ConsoleColor]::Cyan))
                    $headerX += 5
                }
                
                # Column headers
                foreach ($col in $self.Columns) {
                    $headerText = $col.Header ?? $col.Name
                    $width = $col.CalculatedWidth
                    
                    # Add sort indicator
                    if ($self.AllowSort -and $col.Sortable -ne $false -and $col.Name -eq $self.SortColumn) {
                        $sortIndicator = if ($self.SortDirection -eq "Ascending") { "▲" } else { "▼" }
                        $headerText = "$headerText $sortIndicator"
                    }
                    
                    # Truncate if needed
                    if ($headerText.Length -gt $width) {
                        # FIX: Robust substring
                        $maxLength = [Math]::Max(0, $width - 3)
                        $headerText = $headerText.Substring(0, $maxLength) + "..."
                    }
                    
                    # Align header
                    $alignedText = switch ($col.Align) {
                        "Right" { $headerText.PadLeft($width) }
                        "Center" { 
                            $padding = $width - $headerText.Length
                            $leftPad = [Math]::Floor($padding / 2)
                            $rightPad = $padding - $leftPad
                            " " * $leftPad + $headerText + " " * $rightPad
                        }
                        default { $headerText.PadRight($width) }
                    }
                    
                    Write-BufferString -X $headerX -Y $currentY -Text $alignedText `
                        -ForegroundColor (Get-ThemeColor "Header" -Default ([ConsoleColor]::Cyan))
                    
                    $headerX += $width + 1
                }
                
                $currentY++
                
                # Header separator
                $separatorColor = Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
                Write-BufferString -X $contentX -Y $currentY `
                    -Text ("─" * $contentWidth) -ForegroundColor $separatorColor
                $currentY++
            }
            
            # Data rows
            $startIdx = $self.CurrentPage * $self.PageSize
            $endIdx = [Math]::Min($startIdx + $self.PageSize - 1, $self.ProcessedData.Count - 1)
            
            for ($i = $startIdx; $i -le $endIdx; $i++) {
                $row = $self.ProcessedData[$i]
                $rowX = $contentX
                
                # Selection highlighting
                $isSelected = if ($self.MultiSelect) {
                    $self.SelectedRows -contains $i
                } else {
                    $i -eq $self.SelectedRow
                }
                
                $rowBg = if ($isSelected) { Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan) } else { Get-ThemeColor "Background" -Default ([ConsoleColor]::Black) }
                $rowFg = if ($isSelected) { Get-ThemeColor "Background" -Default ([ConsoleColor]::Black) } else { Get-ThemeColor "Primary" -Default ([ConsoleColor]::White) }
                
                # Clear row background if selected
                if ($isSelected) {
                    Write-BufferString -X $rowX -Y $currentY -Text (" " * $contentWidth) `
                        -BackgroundColor $rowBg
                }
                
                # Row number
                if ($self.ShowRowNumbers) {
                    Write-BufferString -X $rowX -Y $currentY -Text ($i + 1).ToString().PadRight(4) `
                        -ForegroundColor (Get-ThemeColor "Subtle" -Default ([ConsoleColor]::DarkGray)) -BackgroundColor $rowBg
                    $rowX += 5
                }
                
                # Cell data
                foreach ($col in $self.Columns) {
                    $value = $row."$($col.Name)"
                    $width = $col.CalculatedWidth
                    
                    # Format value
                    $displayValue = if ($col.Format -and $value -ne $null) {
                        & $col.Format $value
                    } elseif ($value -ne $null) {
                        $value.ToString()
                    } else {
                        ""
                    }
                    
                    # Truncate if needed
                    if ($displayValue.Length -gt $width) {
                        # FIX: Robust substring
                        $maxLength = [Math]::Max(0, $width - 3)
                        if ($maxLength -le 0) {
                            Write-Log -Level Warning -Message "DataTable '$($self.Title)' column '$($col.Name)' width too small: $width (max length: $maxLength)"
                            $displayValue = "..."
                        } else {
                            $displayValue = $displayValue.Substring(0, $maxLength) + "..."
                        }
                    }
                    }
                    
                    # Align value
                    $alignedValue = switch ($col.Align) {
                        "Right" { $displayValue.PadLeft($width) }
                        "Center" { 
                            $padding = $width - $displayValue.Length
                            $leftPad = [Math]::Floor($padding / 2)
                            $rightPad = $padding - $leftPad
                            " " * $leftPad + $displayValue + " " * $rightPad
                        }
                        default { $displayValue.PadRight($width) }
                    }
                    
                    # Determine color
                    $cellFg = if ($col.Color -and -not $isSelected) {
                        $colorName = & $col.Color $value $row
                        Get-ThemeColor $colorName -Default ([ConsoleColor]::White)
                    } else {
                        $rowFg
                    }
                    
                    Write-BufferString -X $rowX -Y $currentY -Text $alignedValue `
                        -ForegroundColor $cellFg -BackgroundColor $rowBg
                    
                    $rowX += $width + 1
                }
                
                $currentY++
            }
            
            # Empty state
            if ($self.ProcessedData.Count -eq 0) {
                $emptyMessage = if ($self.FilterText) {
                    "No results match the filter"
                } else {
                    "No data to display"
                }
                $msgX = $contentX + [Math]::Floor(($contentWidth - $emptyMessage.Length) / 2)
                $msgY = $contentY + [Math]::Floor($contentHeight / 2)
                Write-BufferString -X $msgX -Y $msgY -Text $emptyMessage `
                    -ForegroundColor (Get-ThemeColor "Subtle" -Default ([ConsoleColor]::DarkGray))
            }
            
            # Footer
            if ($self.ShowFooter) {
                $footerY = $contentY + $contentHeight - 1
                
                # Status
                $statusText = "$($self.ProcessedData.Count) rows"
                if ($self.FilterText) {
                    $statusText += " (filtered from $($self.Data.Count))"
                }
                if ($self.MultiSelect) {
                    $statusText += " | $($self.SelectedRows.Count) selected"
                }
                Write-BufferString -X ($contentX + 1) -Y $footerY -Text $statusText `
                    -ForegroundColor (Get-ThemeColor "Subtle" -Default ([ConsoleColor]::DarkGray))
                
                # Pagination
                if ($self.ProcessedData.Count -gt $self.PageSize) {
                    $totalPages = [Math]::Ceiling($self.ProcessedData.Count / [Math]::Max(1, $self.PageSize))
                    $pageText = "Page $($self.CurrentPage + 1)/$totalPages"
                    Write-BufferString -X ($contentX + $contentWidth - $pageText.Length - 1) -Y $footerY `
                        -Text $pageText -ForegroundColor (Get-ThemeColor "Info" -Default ([ConsoleColor]::Blue))
                }
                
                # Scrollbar
                if ($self.ProcessedData.Count -gt $self.PageSize) {
                    $scrollHeight = $contentHeight - 4 - (if ($self.ShowHeader) { 2 } else { 0 }) - (if ($self.AllowFilter) { 2 } else { 0 })
                    $scrollPos = [Math]::Floor(($self.SelectedRow / ($self.ProcessedData.Count - 1)) * ($scrollHeight - 1))
                    $scrollX = $contentX + $contentWidth - 1
                    
                    for ($i = 0; $i -lt $scrollHeight; $i++) {
                        $scrollY = $currentY - $scrollHeight + $i
                        $char = if ($i -eq $scrollPos) { "█" } else { "│" }
                        $color = if ($i -eq $scrollPos) { Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan) } else { Get-ThemeColor "Subtle" -Default ([ConsoleColor]::DarkGray) }
                        Write-BufferString -X $scrollX -Y $scrollY -Text $char -ForegroundColor $color
                    }
                }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            
            # Filter mode
            if ($Key.Modifiers -band [ConsoleModifiers]::Control) {
                switch ($Key.Key) {
                    ([ConsoleKey]::F) {
                        # Toggle filter focus
                        $self.FilterMode = -not $self.FilterMode
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::S) {
                        # Cycle sort column
                        if ($self.AllowSort) {
                            $sortableCols = @($self.Columns | Where-Object { $_.Sortable -ne $false })
                            if ($sortableCols.Count -gt 0) {
                                $currentIdx = [array]::IndexOf($sortableCols.Name, $self.SortColumn)
                                $nextIdx = ($currentIdx + 1) % $sortableCols.Count
                                $self.SortColumn = $sortableCols[$nextIdx].Name
                                & $self.ProcessData -self $self
                                Request-TuiRefresh
                            }
                        }
                        return $true
                    }
                    ([ConsoleKey]::A) {
                        # Select all (if multi-select)
                        if ($self.MultiSelect) {
                            if ($self.SelectedRows.Count -eq $self.ProcessedData.Count) {
                                $self.SelectedRows = @()
                            } else {
                                $self.SelectedRows = @(0..($self.ProcessedData.Count - 1))
                            }
                            if ($self.OnSelectionChange) {
                                & $self.OnSelectionChange -SelectedRows $self.SelectedRows
                            }
                            Request-TuiRefresh
                        }
                        return $true
                    }
                }
            }
            
            # Filter text input
            if ($self.FilterMode) {
                switch ($Key.Key) {
                    ([ConsoleKey]::Escape) {
                        $self.FilterMode = $false
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::Enter) {
                        $self.FilterMode = $false
                        & $self.ProcessData -self $self
                        Request-TuiRefresh
                        return $true
                    }
                    ([ConsoleKey]::Backspace) {
                        if ($self.FilterText.Length -gt 0) {
                            $self.FilterText = $self.FilterText.Substring(0, $self.FilterText.Length - 1)
                            & $self.ProcessData -self $self
                            Request-TuiRefresh
                        }
                        return $true
                    }
                    default {
                        if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar)) {
                            $self.FilterText += $Key.KeyChar
                            & $self.ProcessData -self $self
                            Request-TuiRefresh
                            return $true
                        }
                    }
                }
                return $false
            }
            
            # Normal navigation
            switch ($Key.Key) {
                ([ConsoleKey]::UpArrow) {
                    if ($self.SelectedRow -gt 0) {
                        $self.SelectedRow--
                        
                        # Adjust page if needed
                        if ($self.SelectedRow -lt ($self.CurrentPage * $self.PageSize)) {
                            $self.CurrentPage--
                        }
                        
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::DownArrow) {
                    if ($self.SelectedRow -lt ($self.ProcessedData.Count - 1)) {
                        $self.SelectedRow++
                        
                        # Adjust page if needed
                        if ($self.SelectedRow -ge (($self.CurrentPage + 1) * $self.PageSize)) {
                            $self.CurrentPage++
                        }
                        
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::PageUp) {
                    if ($self.CurrentPage -gt 0) {
                        $self.CurrentPage--
                        $self.SelectedRow = $self.CurrentPage * $self.PageSize
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::PageDown) {
                    $totalPages = [Math]::Ceiling($self.ProcessedData.Count / [Math]::Max(1, $self.PageSize))
                    if ($self.CurrentPage -lt ($totalPages - 1)) {
                        $self.CurrentPage++
                        $self.SelectedRow = $self.CurrentPage * $self.PageSize
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::Home) {
                    $self.SelectedRow = 0
                    $self.CurrentPage = 0
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::End) {
                    $self.SelectedRow = $self.ProcessedData.Count - 1
                    $self.CurrentPage = [Math]::Floor($self.SelectedRow / [Math]::Max(1, $self.PageSize))
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::Spacebar) {
                    if ($self.MultiSelect) {
                        if ($self.SelectedRows -contains $self.SelectedRow) {
                            $self.SelectedRows = @($self.SelectedRows | Where-Object { $_ -ne $self.SelectedRow })
                        } else {
                            $self.SelectedRows += $self.SelectedRow
                        }
                        if ($self.OnSelectionChange) {
                            & $self.OnSelectionChange -SelectedRows $self.SelectedRows
                        }
                        Request-TuiRefresh
                    } elseif ($self.AllowSort) {
                        # Toggle sort direction
                        if ($self.SortDirection -eq "Ascending") {
                            $self.SortDirection = "Descending"
                        } else {
                            $self.SortDirection = "Ascending"
                        }
                        & $self.ProcessData -self $self
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::Enter) {
                    if ($self.OnRowSelect -and $self.ProcessedData.Count -gt 0) {
                        $selectedData = if ($self.MultiSelect) {
                            @($self.SelectedRows | ForEach-Object { $self.ProcessedData[$_] })
                        } else {
                            $self.ProcessedData[$self.SelectedRow]
                        }
                        & $self.OnRowSelect -SelectedData $selectedData -SelectedIndex $self.SelectedRow
                    }
                    return $true
                }
                ([ConsoleKey]::F) {
                    if ($self.AllowFilter) {
                        $self.FilterMode = $true
                        Request-TuiRefresh
                    }
                    return $true
                }
                default {
                    # Number keys for column sorting
                    if ($Key.KeyChar -match '\d' -and $self.AllowSort) {
                        $colIndex = [int]$Key.KeyChar.ToString() - 1
                        if ($colIndex -ge 0 -and $colIndex -lt $self.Columns.Count) {
                            $col = $self.Columns[$colIndex]
                            if ($col.Sortable -ne $false) {
                                if ($self.SortColumn -eq $col.Name) {
                                    # Toggle direction
                                    $self.SortDirection = if ($self.SortDirection -eq "Ascending") { "Descending" } else { "Ascending" }
                                } else {
                                    $self.SortColumn = $col.Name
                                    $self.SortDirection = "Ascending"
                                }
                                & $self.ProcessData -self $self
                                Request-TuiRefresh
                            }
                        }
                        return $true
                    }
                }
            }
            
            return $false
        }
        
        # Public methods
        RefreshData = {
            param($self)
            & $self.ProcessData -self $self
            Request-TuiRefresh
        }
        
        SetFilter = {
            param($self, $FilterText, $FilterColumn)
            $self.FilterText = $FilterText
            $self.FilterColumn = $FilterColumn
            & $self.ProcessData -self $self
            Request-TuiRefresh
        }
        
        ExportData = {
            param($self, $Format = "CSV", $FilePath)
            
            $exportData = if ($self.FilterText) { $self.ProcessedData } else { $self.Data }
            
            switch ($Format.ToUpper()) {
                "CSV" {
                    $exportData | Export-Csv -Path $FilePath -NoTypeInformation
                }
                "JSON" {
                    $exportData | ConvertTo-Json -Depth 10 | Set-Content -Path $FilePath
                }
                "HTML" {
                    # Simple HTML table export
                    $html = "<table border='1'><tr>"
                    foreach ($col in $self.Columns) {
                        $html += "<th>$($col.Header ?? $col.Name)</th>"
                    }
                    $html += "</tr>"
                    
                    foreach ($row in $exportData) {
                        $html += "<tr>"
                        foreach ($col in $self.Columns) {
                            $value = $row."$($col.Name)"
                            $html += "<td>$value</td>"
                        }
                        $html += "</tr>"
                    }
                    $html += "</table>"
                    
                    $html | Set-Content -Path $FilePath
                }
            }
        }
    }
    
    # Initialize data processing after component is created
    & $component.ProcessData -self $component
    
    return $component
}

#endregion

#region Tree View Component

function global:New-TuiTreeView {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "TreeView"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 40
        Height = $Props.Height ?? 20
        RootNode = $Props.RootNode ?? @{ Name = "Root"; Children = @(); Expanded = $true }
        SelectedNode = $null
        SelectedPath = @()
        FlattenedNodes = @()
        ScrollOffset = 0
        ShowRoot = $Props.ShowRoot ?? $true
        IsFocusable = $true
        
        # Node structure:
        # @{
        #     Name = "Node Name"
        #     Data = @{}  # Custom data
        #     Children = @()
        #     Expanded = $false
        #     Icon = "📁"  # Optional
        #     Parent = $null  # Set automatically
        # }
        
        FlattenTree = {
            param($self)
            $flattened = @()
            
            $processNode = {
                param($Node, $Level, $Parent)
                
                $node.Parent = $Parent
                $node.Level = $Level
                
                if ($self.ShowRoot -or $Level -gt 0) {
                    $flattened += $Node
                }
                
                if ($Node.Expanded -and $Node.Children) {
                    foreach ($child in $Node.Children) {
                        & $processNode $child ($Level + 1) $Node
                    }
                }
            }
            
            & $processNode $self.RootNode 0 $null
            $self.FlattenedNodes = $flattened
        }
        
        Render = {
            param($self)
            
            # Flatten tree first
            & $self.FlattenTree -self $self
            
            $borderColor = if ($self.IsFocused) { 
                Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
            } else { 
                Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
            }
            
            Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                -BorderColor $borderColor -Title " Tree View "
            
            $visibleHeight = $self.Height - 2
            $startIdx = $self.ScrollOffset
            $endIdx = [Math]::Min($self.FlattenedNodes.Count - 1, $startIdx + $visibleHeight - 1)
            
            $currentY = $self.Y + 1
            
            for ($i = $startIdx; $i -le $endIdx; $i++) {
                $node = $self.FlattenedNodes[$i]
                $isSelected = ($node -eq $self.SelectedNode)
                
                # Indentation
                $indent = "  " * $node.Level
                
                # Expand/collapse indicator
                $expandIcon = if ($node.Children -and $node.Children.Count -gt 0) {
                    if ($node.Expanded) { "▼" } else { "▶" }
                } else {
                    " "
                }
                
                # Node icon
                $nodeIcon = if ($node.Icon) { 
                    $node.Icon 
                } elseif ($node.Children -and $node.Children.Count -gt 0) {
                    if ($node.Expanded) { "📂" } else { "📁" }
                } else {
                    "📄"
                }
                
                # Colors
                $fg = if ($isSelected) { Get-ThemeColor "Background" -Default ([ConsoleColor]::Black) } else { Get-ThemeColor "Primary" -Default ([ConsoleColor]::White) }
                $bg = if ($isSelected) { Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan) } else { Get-ThemeColor "Background" -Default ([ConsoleColor]::Black) }
                
                # Clear line if selected
                if ($isSelected) {
                    Write-BufferString -X ($self.X + 1) -Y $currentY -Text (" " * ($self.Width - 2)) `
                        -BackgroundColor $bg
                }
                
                # Render node
                $nodeText = "$indent$expandIcon $nodeIcon $($node.Name)"
                if ($nodeText.Length -gt ($self.Width - 3)) {
                    $nodeText = $nodeText.Substring(0, $self.Width - 6) + "..."
                }
                
                Write-BufferString -X ($self.X + 1) -Y $currentY -Text $nodeText `
                    -ForegroundColor $fg -BackgroundColor $bg
                
                $currentY++
            }
            
            # Scrollbar
            if ($self.FlattenedNodes.Count -gt $visibleHeight) {
                $scrollHeight = $visibleHeight
                $scrollPos = if ($self.FlattenedNodes.Count -gt 1) {
                    $selectedIdx = [array]::IndexOf($self.FlattenedNodes, $self.SelectedNode)
                    [Math]::Floor(($selectedIdx / ($self.FlattenedNodes.Count - 1)) * ($scrollHeight - 1))
                } else { 0 }
                
                for ($i = 0; $i -lt $scrollHeight; $i++) {
                    $char = if ($i -eq $scrollPos) { "█" } else { "│" }
                    $color = if ($i -eq $scrollPos) { Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan) } else { Get-ThemeColor "Subtle" -Default ([ConsoleColor]::DarkGray) }
                    Write-BufferString -X ($self.X + $self.Width - 2) -Y ($self.Y + 1 + $i) `
                        -Text $char -ForegroundColor $color
                }
            }
        }
        
        HandleInput = {
            param($self, $Key)
            
            if ($self.FlattenedNodes.Count -eq 0) { return $false }
            
            $currentIdx = if ($self.SelectedNode) {
                [array]::IndexOf($self.FlattenedNodes, $self.SelectedNode)
            } else { 0 }
            
            switch ($Key.Key) {
                ([ConsoleKey]::UpArrow) {
                    if ($currentIdx -gt 0) {
                        $currentIdx--
                        $self.SelectedNode = $self.FlattenedNodes[$currentIdx]
                        
                        # Adjust scroll
                        if ($currentIdx -lt $self.ScrollOffset) {
                            $self.ScrollOffset = $currentIdx
                        }
                        
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::DownArrow) {
                    if ($currentIdx -lt ($self.FlattenedNodes.Count - 1)) {
                        $currentIdx++
                        $self.SelectedNode = $self.FlattenedNodes[$currentIdx]
                        
                        # Adjust scroll
                        $visibleHeight = $self.Height - 2
                        if ($currentIdx -ge ($self.ScrollOffset + $visibleHeight)) {
                            $self.ScrollOffset = $currentIdx - $visibleHeight + 1
                        }
                        
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::LeftArrow) {
                    if ($self.SelectedNode) {
                        if ($self.SelectedNode.Expanded -and $self.SelectedNode.Children) {
                            # Collapse
                            $self.SelectedNode.Expanded = $false
                            Request-TuiRefresh
                        } elseif ($self.SelectedNode.Parent) {
                            # Move to parent
                            $self.SelectedNode = $self.SelectedNode.Parent
                            Request-TuiRefresh
                        }
                    }
                    return $true
                }
                ([ConsoleKey]::RightArrow) {
                    if ($self.SelectedNode -and $self.SelectedNode.Children -and $self.SelectedNode.Children.Count -gt 0) {
                        if (-not $self.SelectedNode.Expanded) {
                            # Expand
                            $self.SelectedNode.Expanded = $true
                            Request-TuiRefresh
                        } else {
                            # Move to first child
                            $self.SelectedNode = $self.SelectedNode.Children[0]
                            Request-TuiRefresh
                        }
                    }
                    return $true
                }
                ([ConsoleKey]::Spacebar) {
                    if ($self.SelectedNode -and $self.SelectedNode.Children -and $self.SelectedNode.Children.Count -gt 0) {
                        $self.SelectedNode.Expanded = -not $self.SelectedNode.Expanded
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::Enter) {
                    if ($self.OnNodeSelect -and $self.SelectedNode) {
                        # Build path
                        $path = @()
                        $current = $self.SelectedNode
                        while ($current) {
                            $path = @($current.Name) + $path
                            $current = $current.Parent
                        }
                        
                        & $self.OnNodeSelect -Node $self.SelectedNode -Path $path
                    }
                    return $true
                }
                ([ConsoleKey]::Home) {
                    if ($self.FlattenedNodes.Count -gt 0) {
                        $self.SelectedNode = $self.FlattenedNodes[0]
                        $self.ScrollOffset = 0
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::End) {
                    if ($self.FlattenedNodes.Count -gt 0) {
                        $self.SelectedNode = $self.FlattenedNodes[-1]
                        $visibleHeight = $self.Height - 2
                        $self.ScrollOffset = [Math]::Max(0, $self.FlattenedNodes.Count - $visibleHeight)
                        Request-TuiRefresh
                    }
                    return $true
                }
                { $_ -in @([ConsoleKey]::Add, [ConsoleKey]::OemPlus) } {
                    # Expand all
                    $expandAll = {
                        param($Node)
                        $Node.Expanded = $true
                        foreach ($child in $Node.Children) {
                            & $expandAll $child
                        }
                    }
                    & $expandAll $self.RootNode
                    Request-TuiRefresh
                    return $true
                }
                { $_ -in @([ConsoleKey]::Subtract, [ConsoleKey]::OemMinus) } {
                    # Collapse all
                    $collapseAll = {
                        param($Node)
                        $Node.Expanded = $false
                        foreach ($child in $Node.Children) {
                            & $collapseAll $child
                        }
                    }
                    & $collapseAll $self.RootNode
                    $self.RootNode.Expanded = $true  # Keep root expanded
                    Request-TuiRefresh
                    return $true
                }
            }
            
            return $false
        }
        
        # Public methods
        AddNode = {
            param($self, $ParentNode, $NewNode)
            if (-not $ParentNode.Children) {
                $ParentNode.Children = @()
            }
            $ParentNode.Children += $NewNode
            $NewNode.Parent = $ParentNode
            Request-TuiRefresh
        }
        
        RemoveNode = {
            param($self, $Node)
            if ($Node.Parent) {
                $Node.Parent.Children = @($Node.Parent.Children | Where-Object { $_ -ne $Node })
                if ($self.SelectedNode -eq $Node) {
                    $self.SelectedNode = $Node.Parent
                }
                Request-TuiRefresh
            }
        }
        
        FindNode = {
            param($self, $Predicate)
            
            $find = {
                param($Node)
                if (& $Predicate $Node) { return $Node }
                foreach ($child in $Node.Children) {
                    $found = & $find $child
                    if ($found) { return $found }
                }
                return $null
            }
            
            return & $find $self.RootNode
        }
    }
    
    return $component
}

#endregion

Export-ModuleMember -Function @(
    'New-TuiDataTable',
    'New-TuiTreeView'
)
# Advanced Input Components Module
# Enhanced input components from the TUI Upgrade Roadmap

#region DateTime Components with Calendar Grid

function global:New-TuiCalendarPicker {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "CalendarPicker"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 30
        Height = $Props.Height ?? 10
        Value = $Props.Value ?? (Get-Date)
        Mode = $Props.Mode ?? "Date"  # Date, DateTime, Time
        IsFocusable = $true
        CurrentView = "Day"  # Day, Month, Year
        SelectedDate = $Props.Value ?? (Get-Date)
        ViewDate = $Props.Value ?? (Get-Date)
        
        Render = {
            param($self)
            
            $borderColor = if ($self.IsFocused) { 
                Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
            } else { 
                Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
            }
            
            # Main container
            Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                -BorderColor $borderColor -Title " Calendar "
            
            # Header with navigation
            $headerY = $self.Y + 1
            $monthYear = $self.ViewDate.ToString("MMMM yyyy")
            $headerX = $self.X + [Math]::Floor(($self.Width - $monthYear.Length) / 2)
            
            Write-BufferString -X ($self.X + 2) -Y $headerY -Text "◄" -ForegroundColor $borderColor
            Write-BufferString -X $headerX -Y $headerY -Text $monthYear -ForegroundColor (Get-ThemeColor "Header")
            Write-BufferString -X ($self.X + $self.Width - 3) -Y $headerY -Text "►" -ForegroundColor $borderColor
            
            # Day headers
            $dayHeaderY = $headerY + 2
            $days = @("Su", "Mo", "Tu", "We", "Th", "Fr", "Sa")
            $dayWidth = 4
            $startX = $self.X + 2
            
            for ($i = 0; $i -lt $days.Count; $i++) {
                Write-BufferString -X ($startX + ($i * $dayWidth)) -Y $dayHeaderY `
                    -Text $days[$i] -ForegroundColor (Get-ThemeColor "Subtle")
            }
            
            # Calendar grid
            $firstDay = Get-Date -Year $self.ViewDate.Year -Month $self.ViewDate.Month -Day 1
            $startDayOfWeek = [int]$firstDay.DayOfWeek
            $daysInMonth = [DateTime]::DaysInMonth($self.ViewDate.Year, $self.ViewDate.Month)
            
            $currentDay = 1
            $calendarY = $dayHeaderY + 1
            
            for ($week = 0; $week -lt 6; $week++) {
                if ($currentDay -gt $daysInMonth) { break }
                
                for ($dayOfWeek = 0; $dayOfWeek -lt 7; $dayOfWeek++) {
                    $x = $startX + ($dayOfWeek * $dayWidth)
                    
                    if ($week -eq 0 -and $dayOfWeek -lt $startDayOfWeek) {
                        continue
                    }
                    
                    if ($currentDay -le $daysInMonth) {
                        $isSelected = ($currentDay -eq $self.SelectedDate.Day -and 
                                     $self.ViewDate.Month -eq $self.SelectedDate.Month -and 
                                     $self.ViewDate.Year -eq $self.SelectedDate.Year)
                        
                        $isToday = ($currentDay -eq (Get-Date).Day -and 
                                  $self.ViewDate.Month -eq (Get-Date).Month -and 
                                  $self.ViewDate.Year -eq (Get-Date).Year)
                        
                        $fg = if ($isSelected) { 
                            Get-ThemeColor "Background" 
                        } elseif ($isToday) { 
                            Get-ThemeColor "Accent" 
                        } else { 
                            Get-ThemeColor "Primary" 
                        }
                        
                        $bg = if ($isSelected) { 
                            Get-ThemeColor "Accent" 
                        } else { 
                            Get-ThemeColor "Background" 
                        }
                        
                        $dayText = $currentDay.ToString().PadLeft(2)
                        Write-BufferString -X $x -Y ($calendarY + $week) -Text $dayText `
                            -ForegroundColor $fg -BackgroundColor $bg
                        
                        $currentDay++
                    }
                }
            }
            
            # Time picker if in DateTime mode
            if ($self.Mode -eq "DateTime") {
                $timeY = $self.Y + $self.Height - 2
                $timeStr = $self.SelectedDate.ToString("HH:mm")
                Write-BufferString -X ($self.X + 2) -Y $timeY -Text "Time: $timeStr" `
                    -ForegroundColor (Get-ThemeColor "Primary")
            }
        }
        
        HandleInput = {
            param($self, $Key)
            
            $handled = $true
            $date = $self.SelectedDate
            $viewDate = $self.ViewDate
            
            switch ($Key.Key) {
                ([ConsoleKey]::LeftArrow) {
                    if ($Key.Modifiers -band [ConsoleModifiers]::Control) {
                        # Previous month
                        $self.ViewDate = $viewDate.AddMonths(-1)
                    } else {
                        # Previous day
                        $date = $date.AddDays(-1)
                        if ($date.Month -ne $viewDate.Month) {
                            $self.ViewDate = $date
                        }
                    }
                }
                ([ConsoleKey]::RightArrow) {
                    if ($Key.Modifiers -band [ConsoleModifiers]::Control) {
                        # Next month
                        $self.ViewDate = $viewDate.AddMonths(1)
                    } else {
                        # Next day
                        $date = $date.AddDays(1)
                        if ($date.Month -ne $viewDate.Month) {
                            $self.ViewDate = $date
                        }
                    }
                }
                ([ConsoleKey]::UpArrow) {
                    $date = $date.AddDays(-7)
                    if ($date.Month -ne $viewDate.Month) {
                        $self.ViewDate = $date
                    }
                }
                ([ConsoleKey]::DownArrow) {
                    $date = $date.AddDays(7)
                    if ($date.Month -ne $viewDate.Month) {
                        $self.ViewDate = $date
                    }
                }
                ([ConsoleKey]::PageUp) {
                    $self.ViewDate = $viewDate.AddMonths(-1)
                    $date = Get-Date -Year $self.ViewDate.Year -Month $self.ViewDate.Month `
                        -Day ([Math]::Min($date.Day, [DateTime]::DaysInMonth($self.ViewDate.Year, $self.ViewDate.Month)))
                }
                ([ConsoleKey]::PageDown) {
                    $self.ViewDate = $viewDate.AddMonths(1)
                    $date = Get-Date -Year $self.ViewDate.Year -Month $self.ViewDate.Month `
                        -Day ([Math]::Min($date.Day, [DateTime]::DaysInMonth($self.ViewDate.Year, $self.ViewDate.Month)))
                }
                ([ConsoleKey]::Home) {
                    $date = Get-Date
                    $self.ViewDate = $date
                }
                ([ConsoleKey]::Enter) {
                    if ($self.OnSelect) {
                        & $self.OnSelect -Date $date
                    }
                }
                default {
                    $handled = $false
                }
            }
            
            if ($handled) {
                $self.SelectedDate = $date
                if ($self.OnChange) {
                    & $self.OnChange -NewValue $date
                }
                Request-TuiRefresh
            }
            
            return $handled
        }
    }
    
    return $component
}

#endregion

#region Enhanced Dropdown with Search

function global:New-TuiSearchableDropdown {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "SearchableDropdown"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 30
        Height = $Props.Height ?? 3
        Options = $Props.Options ?? @()
        Value = $Props.Value
        Placeholder = $Props.Placeholder ?? "Type to search..."
        MaxDisplayItems = $Props.MaxDisplayItems ?? 5
        AllowCustomValue = $Props.AllowCustomValue ?? $false
        IsFocusable = $true
        IsOpen = $false
        SearchText = ""
        FilteredOptions = @()
        SelectedIndex = 0
        
        Render = {
            param($self)
            
            $borderColor = if ($self.IsFocused) { 
                Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
            } else { 
                Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
            }
            
            # Main dropdown box
            Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                -BorderColor $borderColor
            
            # Display text
            $displayText = ""
            if ($self.IsOpen) {
                $displayText = $self.SearchText
                if ([string]::IsNullOrEmpty($displayText) -and -not $self.IsFocused) {
                    $displayText = $self.Placeholder
                }
            } else {
                if ($self.Value) {
                    $selected = $self.Options | Where-Object { $_.Value -eq $self.Value } | Select-Object -First 1
                    if ($selected) {
                        $displayText = $selected.Display
                    } else {
                        $displayText = $self.Value.ToString()
                    }
                } else {
                    $displayText = "Select..."
                }
            }
            
            Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $displayText
            
            # Dropdown indicator
            $indicator = if ($self.IsOpen) { "▲" } else { "▼" }
            Write-BufferString -X ($self.X + $self.Width - 3) -Y ($self.Y + 1) -Text $indicator `
                -ForegroundColor $borderColor
            
            # Cursor for search mode
            if ($self.IsOpen -and $self.IsFocused) {
                $cursorX = $self.X + 2 + $self.SearchText.Length
                if ($cursorX -lt ($self.X + $self.Width - 3)) {
                    Write-BufferString -X $cursorX -Y ($self.Y + 1) -Text "_" `
                        -BackgroundColor (Get-ThemeColor "Accent")
                }
            }
            
            # Options dropdown
            if ($self.IsOpen -and $self.FilteredOptions.Count -gt 0) {
                $dropHeight = [Math]::Min($self.FilteredOptions.Count, $self.MaxDisplayItems) + 2
                Write-BufferBox -X $self.X -Y ($self.Y + $self.Height) -Width $self.Width -Height $dropHeight `
                    -BorderColor $borderColor -BackgroundColor (Get-ThemeColor "Background")
                
                $startIdx = 0
                if ($self.SelectedIndex -ge $self.MaxDisplayItems) {
                    $startIdx = $self.SelectedIndex - $self.MaxDisplayItems + 1
                }
                
                $endIdx = [Math]::Min($startIdx + $self.MaxDisplayItems - 1, $self.FilteredOptions.Count - 1)
                
                for ($i = $startIdx; $i -le $endIdx; $i++) {
                    $option = $self.FilteredOptions[$i]
                    $y = $self.Y + $self.Height + 1 + ($i - $startIdx)
                    
                    $isSelected = ($i -eq $self.SelectedIndex)
                    $fg = if ($isSelected) { Get-ThemeColor "Background" } else { Get-ThemeColor "Primary" }
                    $bg = if ($isSelected) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Background" }
                    
                    $text = $option.Display
                    if ($text.Length -gt ($self.Width - 4)) {
                        $text = $text.Substring(0, $self.Width - 7) + "..."
                    }
                    
                    # Highlight matching text
                    if ($self.SearchText.Length -gt 0 -and -not $isSelected) {
                        $matchIndex = $text.IndexOf($self.SearchText, [StringComparison]::OrdinalIgnoreCase)
                        if ($matchIndex -ge 0) {
                            # Draw text before match
                            if ($matchIndex -gt 0) {
                                Write-BufferString -X ($self.X + 2) -Y $y `
                                    -Text $text.Substring(0, $matchIndex) -ForegroundColor $fg
                            }
                            
                            # Draw matching text highlighted
                            Write-BufferString -X ($self.X + 2 + $matchIndex) -Y $y `
                                -Text $text.Substring($matchIndex, $self.SearchText.Length) `
                                -ForegroundColor (Get-ThemeColor "Warning")
                            
                            # Draw text after match
                            $afterMatch = $matchIndex + $self.SearchText.Length
                            if ($afterMatch -lt $text.Length) {
                                Write-BufferString -X ($self.X + 2 + $afterMatch) -Y $y `
                                    -Text $text.Substring($afterMatch) -ForegroundColor $fg
                            }
                            
                            continue
                        }
                    }
                    
                    Write-BufferString -X ($self.X + 2) -Y $y -Text $text `
                        -ForegroundColor $fg -BackgroundColor $bg
                }
                
                # Scrollbar if needed
                if ($self.FilteredOptions.Count -gt $self.MaxDisplayItems) {
                    $scrollHeight = $self.MaxDisplayItems
                    $scrollPos = [Math]::Floor(($self.SelectedIndex / ($self.FilteredOptions.Count - 1)) * ($scrollHeight - 1))
                    
                    for ($i = 0; $i -lt $scrollHeight; $i++) {
                        $char = if ($i -eq $scrollPos) { "█" } else { "│" }
                        $color = if ($i -eq $scrollPos) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Subtle" }
                        Write-BufferString -X ($self.X + $self.Width - 2) -Y ($self.Y + $self.Height + 1 + $i) `
                            -Text $char -ForegroundColor $color
                    }
                }
            }
        }
        
        FilterOptions = {
            if ([string]::IsNullOrEmpty($this.SearchText)) {
                $this.FilteredOptions = $this.Options
            } else {
                $this.FilteredOptions = @($this.Options | Where-Object {
                    $_.Display -like "*$($this.SearchText)*"
                })
                
                # Add custom value option if allowed and no exact match
                if ($this.AllowCustomValue) {
                    $exactMatch = $this.FilteredOptions | Where-Object { $_.Display -eq $this.SearchText }
                    if (-not $exactMatch) {
                        $this.FilteredOptions = @(@{
                            Display = $this.SearchText
                            Value = $this.SearchText
                            IsCustom = $true
                        }) + $this.FilteredOptions
                    }
                }
            }
            
            # Reset selection to first item
            $this.SelectedIndex = 0
        }
        
        HandleInput = {
            param($self, $Key)
            
            if (-not $self.IsOpen) {
                switch ($Key.Key) {
                    { $_ -in @([ConsoleKey]::Enter, [ConsoleKey]::Spacebar, [ConsoleKey]::DownArrow) } {
                        $self.IsOpen = $true
                        $self.SearchText = ""
                        & $self.FilterOptions
                        Request-TuiRefresh
                        return $true
                    }
                }
                return $false
            }
            
            # Handle open dropdown
            switch ($Key.Key) {
                ([ConsoleKey]::Escape) {
                    $self.IsOpen = $false
                    $self.SearchText = ""
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::Enter) {
                    if ($self.FilteredOptions.Count -gt 0) {
                        $selected = $self.FilteredOptions[$self.SelectedIndex]
                        if ($self.OnChange) {
                            & $self.OnChange -NewValue $selected.Value -Option $selected
                        }
                        $self.Value = $selected.Value
                        $self.IsOpen = $false
                        $self.SearchText = ""
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::UpArrow) {
                    if ($self.SelectedIndex -gt 0) {
                        $self.SelectedIndex--
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::DownArrow) {
                    if ($self.SelectedIndex -lt ($self.FilteredOptions.Count - 1)) {
                        $self.SelectedIndex++
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::Backspace) {
                    if ($self.SearchText.Length -gt 0) {
                        $self.SearchText = $self.SearchText.Substring(0, $self.SearchText.Length - 1)
                        & $self.FilterOptions
                        Request-TuiRefresh
                    }
                    return $true
                }
                default {
                    if ($Key.KeyChar -and -not [char]::IsControl($Key.KeyChar)) {
                        $self.SearchText += $Key.KeyChar
                        & $self.FilterOptions
                        Request-TuiRefresh
                        return $true
                    }
                }
            }
            
            return $false
        }
    }
    
    return $component
}

#endregion

#region Multi-Select Components

function global:New-TuiMultiSelect {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "MultiSelect"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 30
        Height = $Props.Height ?? 10
        Options = $Props.Options ?? @()
        SelectedValues = $Props.SelectedValues ?? @()
        Title = $Props.Title ?? "Select items"
        AllowSelectAll = $Props.AllowSelectAll ?? $true
        IsFocusable = $true
        SelectedIndex = 0
        ScrollOffset = 0
        
        Render = {
            param($self)
            
            $borderColor = if ($self.IsFocused) { 
                Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
            } else { 
                Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
            }
            
            Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                -BorderColor $borderColor -Title " $($self.Title) "
            
            # Select all option
            $currentY = $self.Y + 1
            if ($self.AllowSelectAll) {
                $allSelected = $self.Options.Count -eq $self.SelectedValues.Count
                $checkbox = if ($allSelected) { "[X]" } else { "[ ]" }
                $fg = if ($self.SelectedIndex -eq -1) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Secondary" }
                Write-BufferString -X ($self.X + 2) -Y $currentY -Text "$checkbox Select All" `
                    -ForegroundColor $fg
                $currentY += 2
            }
            
            # Options
            $visibleHeight = $self.Height - 4
            if ($self.AllowSelectAll) { $visibleHeight -= 2 }
            
            $startIdx = $self.ScrollOffset
            $endIdx = [Math]::Min($self.Options.Count - 1, $startIdx + $visibleHeight - 1)
            
            for ($i = $startIdx; $i -le $endIdx; $i++) {
                $option = $self.Options[$i]
                $isChecked = $self.SelectedValues -contains $option.Value
                $isHighlighted = ($i -eq $self.SelectedIndex)
                
                $checkbox = if ($isChecked) { "[X]" } else { "[ ]" }
                $fg = if ($isHighlighted) { Get-ThemeColor "Accent" } else { Get-ThemeColor "Primary" }
                
                $text = "$checkbox $($option.Display)"
                if ($text.Length -gt ($self.Width - 4)) {
                    $text = $text.Substring(0, $self.Width - 7) + "..."
                }
                
                Write-BufferString -X ($self.X + 2) -Y $currentY -Text $text -ForegroundColor $fg
                $currentY++
            }
            
            # Status line
            $statusY = $self.Y + $self.Height - 2
            $statusText = "$($self.SelectedValues.Count) of $($self.Options.Count) selected"
            Write-BufferString -X ($self.X + 2) -Y $statusY -Text $statusText `
                -ForegroundColor (Get-ThemeColor "Subtle")
        }
        
        HandleInput = {
            param($self, $Key)
            
            $maxIndex = $self.Options.Count - 1
            if ($self.AllowSelectAll) { $maxIndex++ }
            
            switch ($Key.Key) {
                ([ConsoleKey]::UpArrow) {
                    if ($self.AllowSelectAll -and $self.SelectedIndex -eq 0) {
                        $self.SelectedIndex = -1
                    } elseif ($self.SelectedIndex -gt 0 -or ($self.AllowSelectAll -and $self.SelectedIndex -gt -1)) {
                        $self.SelectedIndex--
                        if ($self.SelectedIndex -ge 0 -and $self.SelectedIndex -lt $self.ScrollOffset) {
                            $self.ScrollOffset = $self.SelectedIndex
                        }
                    }
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::DownArrow) {
                    if ($self.SelectedIndex -lt ($self.Options.Count - 1)) {
                        $self.SelectedIndex++
                        $visibleHeight = $self.Height - 4
                        if ($self.AllowSelectAll) { $visibleHeight -= 2 }
                        if ($self.SelectedIndex -ge ($self.ScrollOffset + $visibleHeight)) {
                            $self.ScrollOffset = $self.SelectedIndex - $visibleHeight + 1
                        }
                    }
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::Spacebar) {
                    if ($self.SelectedIndex -eq -1 -and $self.AllowSelectAll) {
                        # Toggle all
                        if ($self.SelectedValues.Count -eq $self.Options.Count) {
                            $self.SelectedValues = @()
                        } else {
                            $self.SelectedValues = @($self.Options | ForEach-Object { $_.Value })
                        }
                    } elseif ($self.SelectedIndex -ge 0) {
                        # Toggle individual
                        $option = $self.Options[$self.SelectedIndex]
                        if ($self.SelectedValues -contains $option.Value) {
                            $self.SelectedValues = @($self.SelectedValues | Where-Object { $_ -ne $option.Value })
                        } else {
                            $self.SelectedValues += $option.Value
                        }
                    }
                    
                    if ($self.OnChange) {
                        & $self.OnChange -SelectedValues $self.SelectedValues
                    }
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::Enter) {
                    if ($self.OnSubmit) {
                        & $self.OnSubmit -SelectedValues $self.SelectedValues
                    }
                    return $true
                }
            }
            
            return $false
        }
    }
    
    return $component
}

#endregion

#region Numeric Input Components

function global:New-TuiNumberInput {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "NumberInput"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 20
        Height = $Props.Height ?? 3
        Value = $Props.Value ?? 0
        Min = $Props.Min ?? 0
        Max = $Props.Max ?? 100
        Step = $Props.Step ?? 1
        DecimalPlaces = $Props.DecimalPlaces ?? 0
        IsFocusable = $true
        TextValue = ($Props.Value ?? 0).ToString()
        CursorPosition = 0
        
        Render = {
            param($self)
            
            $borderColor = if ($self.IsFocused) { 
                Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
            } else { 
                Get-ThemeColor "Border" -Default ([ConsoleColor]::DarkGray)
            }
            
            Write-BufferBox -X $self.X -Y $self.Y -Width $self.Width -Height $self.Height `
                -BorderColor $borderColor
            
            # Value display
            $displayValue = $self.TextValue
            if ($displayValue.Length -gt ($self.Width - 6)) {
                $displayValue = $displayValue.Substring(0, $self.Width - 9) + "..."
            }
            
            Write-BufferString -X ($self.X + 2) -Y ($self.Y + 1) -Text $displayValue
            
            # Cursor
            if ($self.IsFocused -and $self.CursorPosition -le $displayValue.Length) {
                $cursorX = $self.X + 2 + $self.CursorPosition
                if ($cursorX -lt ($self.X + $self.Width - 4)) {
                    Write-BufferString -X $cursorX -Y ($self.Y + 1) -Text "_" `
                        -BackgroundColor (Get-ThemeColor "Accent")
                }
            }
            
            # Spinner buttons
            Write-BufferString -X ($self.X + $self.Width - 3) -Y ($self.Y + 1) -Text "▲" `
                -ForegroundColor $borderColor
            Write-BufferString -X ($self.X + $self.Width - 3) -Y ($self.Y + 1) -Text "▼" `
                -ForegroundColor $borderColor
            
            # Min/Max indicators
            if ($self.Value -le $self.Min) {
                Write-BufferString -X ($self.X + 1) -Y ($self.Y + 1) -Text "⊥" `
                    -ForegroundColor (Get-ThemeColor "Warning")
            }
            if ($self.Value -ge $self.Max) {
                Write-BufferString -X ($self.X + $self.Width - 2) -Y ($self.Y + 1) -Text "⊤" `
                    -ForegroundColor (Get-ThemeColor "Warning")
            }
        }
        
        ValidateAndUpdate = {
            try {
                $newValue = [double]$this.TextValue
                $newValue = [Math]::Max($this.Min, [Math]::Min($this.Max, $newValue))
                
                if ($this.DecimalPlaces -eq 0) {
                    $newValue = [Math]::Floor($newValue)
                } else {
                    $newValue = [Math]::Round($newValue, $this.DecimalPlaces)
                }
                
                $this.Value = $newValue
                $this.TextValue = $newValue.ToString("F$($this.DecimalPlaces)")
                
                if ($this.OnChange) {
                    & $this.OnChange -NewValue $newValue
                }
                
                return $true
            } catch {
                # Invalid input, restore previous value
                $this.TextValue = $this.Value.ToString("F$($this.DecimalPlaces)")
                return $false
            }
        }
        
        HandleInput = {
            param($self, $Key)
            
            switch ($Key.Key) {
                ([ConsoleKey]::UpArrow) {
                    $self.Value = [Math]::Min($self.Max, $self.Value + $self.Step)
                    $self.TextValue = $self.Value.ToString("F$($self.DecimalPlaces)")
                    $self.CursorPosition = $self.TextValue.Length
                    if ($self.OnChange) {
                        & $self.OnChange -NewValue $self.Value
                    }
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::DownArrow) {
                    $self.Value = [Math]::Max($self.Min, $self.Value - $self.Step)
                    $self.TextValue = $self.Value.ToString("F$($self.DecimalPlaces)")
                    $self.CursorPosition = $self.TextValue.Length
                    if ($self.OnChange) {
                        & $self.OnChange -NewValue $self.Value
                    }
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::LeftArrow) {
                    if ($self.CursorPosition -gt 0) {
                        $self.CursorPosition--
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::RightArrow) {
                    if ($self.CursorPosition -lt $self.TextValue.Length) {
                        $self.CursorPosition++
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::Home) {
                    $self.CursorPosition = 0
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::End) {
                    $self.CursorPosition = $self.TextValue.Length
                    Request-TuiRefresh
                    return $true
                }
                ([ConsoleKey]::Backspace) {
                    if ($self.CursorPosition -gt 0) {
                        $self.TextValue = $self.TextValue.Remove($self.CursorPosition - 1, 1)
                        $self.CursorPosition--
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::Delete) {
                    if ($self.CursorPosition -lt $self.TextValue.Length) {
                        $self.TextValue = $self.TextValue.Remove($self.CursorPosition, 1)
                        Request-TuiRefresh
                    }
                    return $true
                }
                ([ConsoleKey]::Enter) {
                    & $self.ValidateAndUpdate
                    Request-TuiRefresh
                    return $true
                }
                default {
                    if ($Key.KeyChar -and ($Key.KeyChar -match '[\d\.\-]')) {
                        $self.TextValue = $self.TextValue.Insert($self.CursorPosition, $Key.KeyChar)
                        $self.CursorPosition++
                        Request-TuiRefresh
                        return $true
                    }
                }
            }
            
            return $false
        }
    }
    
    return $component
}

function global:New-TuiSlider {
    param([hashtable]$Props = @{})
    
    $component = @{
        Type = "Slider"
        X = $Props.X ?? 0
        Y = $Props.Y ?? 0
        Width = $Props.Width ?? 30
        Height = $Props.Height ?? 1
        Value = $Props.Value ?? 50
        Min = $Props.Min ?? 0
        Max = $Props.Max ?? 100
        Step = $Props.Step ?? 1
        ShowValue = $Props.ShowValue ?? $true
        IsFocusable = $true
        
        Render = {
            param($self)
            
            $fg = if ($self.IsFocused) { 
                Get-ThemeColor "Accent" -Default ([ConsoleColor]::Cyan)
            } else { 
                Get-ThemeColor "Primary" -Default ([ConsoleColor]::White)
            }
            
            # Calculate position
            $range = $self.Max - $self.Min
            $percent = ($self.Value - $self.Min) / $range
            $trackWidth = $self.Width - 2
            $thumbPos = [Math]::Floor($trackWidth * $percent)
            
            # Draw track
            $track = "─" * $trackWidth
            Write-BufferString -X ($self.X + 1) -Y $self.Y -Text $track -ForegroundColor (Get-ThemeColor "Subtle")
            
            # Draw filled portion
            if ($thumbPos -gt 0) {
                $filled = "═" * $thumbPos
                Write-BufferString -X ($self.X + 1) -Y $self.Y -Text $filled -ForegroundColor $fg
            }
            
            # Draw thumb
            Write-BufferString -X ($self.X + 1 + $thumbPos) -Y $self.Y -Text "●" -ForegroundColor $fg
            
            # Draw bounds
            Write-BufferString -X $self.X -Y $self.Y -Text "[" -ForegroundColor $fg
            Write-BufferString -X ($self.X + $self.Width - 1) -Y $self.Y -Text "]" -ForegroundColor $fg
            
            # Show value
            if ($self.ShowValue) {
                $valueText = $self.Value.ToString()
                $valueX = $self.X + [Math]::Floor(($self.Width - $valueText.Length) / 2)
                Write-BufferString -X $valueX -Y ($self.Y + 1) -Text $valueText -ForegroundColor $fg
            }
        }
        
        HandleInput = {
            param($self, $Key)
            
            $handled = $true
            $oldValue = $self.Value
            
            switch ($Key.Key) {
                ([ConsoleKey]::LeftArrow) {
                    $self.Value = [Math]::Max($self.Min, $self.Value - $self.Step)
                }
                ([ConsoleKey]::RightArrow) {
                    $self.Value = [Math]::Min($self.Max, $self.Value + $self.Step)
                }
                ([ConsoleKey]::Home) {
                    $self.Value = $self.Min
                }
                ([ConsoleKey]::End) {
                    $self.Value = $self.Max
                }
                ([ConsoleKey]::PageDown) {
                    $largeStep = [Math]::Max($self.Step, ($self.Max - $self.Min) / 10)
                    $self.Value = [Math]::Max($self.Min, $self.Value - $largeStep)
                }
                ([ConsoleKey]::PageUp) {
                    $largeStep = [Math]::Max($self.Step, ($self.Max - $self.Min) / 10)
                    $self.Value = [Math]::Min($self.Max, $self.Value + $largeStep)
                }
                default {
                    $handled = $false
                }
            }
            
            if ($handled -and $self.Value -ne $oldValue) {
                if ($self.OnChange) {
                    & $self.OnChange -NewValue $self.Value
                }
                Request-TuiRefresh
            }
            
            return $handled
        }
    }
    
    return $component
}

#endregion

Export-ModuleMember -Function @(
    'New-TuiCalendarPicker',
    'New-TuiSearchableDropdown',
    'New-TuiMultiSelect',
    'New-TuiNumberInput',
    'New-TuiSlider'
)
# Focus Manager Module
# Centralized focus management for TUI components

$script:FocusState = @{
    CurrentScreen = $null
    FocusedComponent = $null
    FocusHistory = @()
    TabOrder = @()
}

function global:Initialize-FocusManager {
    <#
    .SYNOPSIS
    Initializes the focus management system
    #>
    
    $script:FocusState = @{
        CurrentScreen = $null
        FocusedComponent = $null
        FocusHistory = @()
        TabOrder = @()
    }
    
    # Subscribe to screen change events
    if (Get-Command Subscribe-Event -ErrorAction SilentlyContinue) {
        Subscribe-Event -EventName "Screen.Pushed" -Handler {
            param($EventData)
            Set-ScreenFocus -Screen $EventData.Data.Screen
        }
        
        Subscribe-Event -EventName "Screen.Popped" -Handler {
            param($EventData)
            Set-ScreenFocus -Screen $EventData.Data.Screen
        }
    }
}

function global:Set-ScreenFocus {
    <#
    .SYNOPSIS
    Sets focus context for a screen
    #>
    param([hashtable]$Screen)
    
    $script:FocusState.CurrentScreen = $Screen
    
    # Build tab order for the screen
    $script:FocusState.TabOrder = @()
    
    if ($Screen.Components) {
        # Collect all focusable components
        $focusableComponents = @()
        
        if ($Screen.Components -is [hashtable]) {
            foreach ($kvp in $Screen.Components.GetEnumerator()) {
                $component = $kvp.Value
                if ($component -and $component.IsFocusable -ne $false -and $component.Visible -ne $false) {
                    $focusableComponents += @{
                        Name = $kvp.Key
                        Component = $component
                        TabIndex = $component.TabIndex ?? 999
                        Position = @{ X = $component.X; Y = $component.Y }
                    }
                }
            }
        } elseif ($Screen.Components -is [array]) {
            for ($i = 0; $i -lt $Screen.Components.Count; $i++) {
                $component = $Screen.Components[$i]
                if ($component -and $component.IsFocusable -ne $false -and $component.Visible -ne $false) {
                    $focusableComponents += @{
                        Name = "Component$i"
                        Component = $component
                        TabIndex = $component.TabIndex ?? 999
                        Position = @{ X = $component.X; Y = $component.Y }
                    }
                }
            }
        }
        
        # Sort by TabIndex, then by position (top to bottom, left to right)
        $script:FocusState.TabOrder = $focusableComponents | Sort-Object {
            $_.TabIndex
        }, {
            $_.Position.Y
        }, {
            $_.Position.X
        }
        
        # Set initial focus
        if ($script:FocusState.TabOrder.Count -gt 0) {
            $firstComponent = $script:FocusState.TabOrder[0]
            Set-ManagedComponentFocus -Component $firstComponent.Component -ComponentName $firstComponent.Name
        }
    }
}

function global:Set-ManagedComponentFocus {
    <#
    .SYNOPSIS
    Sets focus to a specific component with proper state management
    #>
    param(
        [hashtable]$Component,
        [string]$ComponentName
    )
    
    if (-not $Component) { return }
    
    # Blur previous component
    if ($script:FocusState.FocusedComponent -and $script:FocusState.FocusedComponent -ne $Component) {
        $script:FocusState.FocusedComponent.IsFocused = $false
        if ($script:FocusState.FocusedComponent.OnBlur) {
            & $script:FocusState.FocusedComponent.OnBlur -self $script:FocusState.FocusedComponent
        }
    }
    
    # Update focus state
    $script:FocusState.FocusedComponent = $Component
    $Component.IsFocused = $true
    
    # Track in history
    $script:FocusState.FocusHistory += @{
        Component = $Component
        Name = $ComponentName
        Time = Get-Date
    }
    
    # Keep history size manageable
    if ($script:FocusState.FocusHistory.Count -gt 50) {
        $script:FocusState.FocusHistory = $script:FocusState.FocusHistory[-50..-1]
    }
    
    # Call component's focus handler
    if ($Component.OnFocus) {
        & $Component.OnFocus -self $Component
    }
    
    # Update screen's tracking if it exists
    if ($script:FocusState.CurrentScreen -and $ComponentName) {
        if ($script:FocusState.CurrentScreen.FocusedComponentName) {
            $script:FocusState.CurrentScreen.FocusedComponentName = $ComponentName
        }
    }
    
    # Update engine's focus tracking
    if (Get-Command Set-ComponentFocus -ErrorAction SilentlyContinue) {
        Set-ComponentFocus -Component $Component
    }
    
    Request-TuiRefresh
}

function global:Move-FocusNext {
    <#
    .SYNOPSIS
    Moves focus to the next component in tab order
    #>
    param([bool]$Reverse = $false)
    
    if ($script:FocusState.TabOrder.Count -eq 0) { return }
    
    # Find current component in tab order
    $currentIndex = -1
    for ($i = 0; $i -lt $script:FocusState.TabOrder.Count; $i++) {
        if ($script:FocusState.TabOrder[$i].Component -eq $script:FocusState.FocusedComponent) {
            $currentIndex = $i
            break
        }
    }
    
    # Calculate next index
    if ($currentIndex -eq -1) {
        $nextIndex = 0
    } else {
        if ($Reverse) {
            $nextIndex = ($currentIndex - 1 + $script:FocusState.TabOrder.Count) % $script:FocusState.TabOrder.Count
        } else {
            $nextIndex = ($currentIndex + 1) % $script:FocusState.TabOrder.Count
        }
    }
    
    # Set focus to next component
    $nextItem = $script:FocusState.TabOrder[$nextIndex]
    Set-ManagedComponentFocus -Component $nextItem.Component -ComponentName $nextItem.Name
}

function global:Get-FocusedComponent {
    <#
    .SYNOPSIS
    Gets the currently focused component
    #>
    return $script:FocusState.FocusedComponent
}

function global:Get-FocusableComponents {
    <#
    .SYNOPSIS
    Gets all focusable components in the current screen
    #>
    return $script:FocusState.TabOrder | ForEach-Object { $_.Component }
}

function global:Clear-FocusHistory {
    <#
    .SYNOPSIS
    Clears the focus history
    #>
    $script:FocusState.FocusHistory = @()
}

function global:Set-ComponentTabIndex {
    <#
    .SYNOPSIS
    Sets the tab index for a component
    #>
    param(
        [hashtable]$Component,
        [int]$TabIndex
    )
    
    $Component.TabIndex = $TabIndex
    
    # Rebuild tab order if this is the current screen
    if ($script:FocusState.CurrentScreen) {
        Set-ScreenFocus -Screen $script:FocusState.CurrentScreen
    }
}

function global:Focus-ComponentByName {
    <#
    .SYNOPSIS
    Focuses a component by its name in the current screen
    #>
    param([string]$ComponentName)
    
    if (-not $script:FocusState.CurrentScreen) { return }
    
    $component = $null
    
    if ($script:FocusState.CurrentScreen.Components -is [hashtable]) {
        $component = $script:FocusState.CurrentScreen.Components[$ComponentName]
    }
    
    if ($component) {
        Set-ManagedComponentFocus -Component $component -ComponentName $ComponentName
    }
}

function global:Get-FocusDebugInfo {
    <#
    .SYNOPSIS
    Gets debug information about the current focus state
    #>
    
    return @{
        CurrentScreen = if ($script:FocusState.CurrentScreen) { $script:FocusState.CurrentScreen.Name } else { "None" }
        FocusedComponent = if ($script:FocusState.FocusedComponent) { 
            @{
                Type = $script:FocusState.FocusedComponent.Type
                Position = @{ X = $script:FocusState.FocusedComponent.X; Y = $script:FocusState.FocusedComponent.Y }
                IsFocused = $script:FocusState.FocusedComponent.IsFocused
            }
        } else { "None" }
        TabOrderCount = $script:FocusState.TabOrder.Count
        FocusHistoryCount = $script:FocusState.FocusHistory.Count
        LastFocusChange = if ($script:FocusState.FocusHistory.Count -gt 0) {
            $script:FocusState.FocusHistory[-1].Time
        } else { "Never" }
    }
}

Export-ModuleMember -Function @(
    'Initialize-FocusManager',
    'Set-ScreenFocus',
    'Set-ManagedComponentFocus',
    'Move-FocusNext',
    'Get-FocusedComponent',
    'Get-FocusableComponents',
    'Clear-FocusHistory',
    'Set-ComponentTabIndex',
    'Focus-ComponentByName',
    'Get-FocusDebugInfo'
)
# Layout Manager Utility Module
# Provides helper functions for component positioning and layout management

function global:New-TuiLayoutManager {
    <#
    .SYNOPSIS
    Creates a layout manager for organizing components within a container
    
    .DESCRIPTION
    The layout manager helps with automatic positioning, spacing, and alignment of components.
    It provides various layout modes: Stack, Grid, Dock, and Manual.
    
    .PARAMETER Container
    A hashtable with X, Y, Width, Height properties defining the container bounds
    
    .PARAMETER Mode
    Layout mode: 'Stack', 'Grid', 'Dock', or 'Manual'
    
    .EXAMPLE
    $layout = New-TuiLayoutManager -Container @{X=0; Y=0; Width=80; Height=25} -Mode 'Stack'
    $layout.Add($component1)
    $layout.Add($component2)
    $layout.Apply()
    #>
    param(
        [hashtable]$Container = @{ X = 0; Y = 0; Width = 80; Height = 25 },
        [string]$Mode = 'Manual',
        [hashtable]$Options = @{}
    )
    
    $manager = @{
        Container = $Container
        Mode = $Mode
        Components = @()
        Options = @{
            # Stack options
            Direction = $Options.Direction ?? 'Vertical'  # 'Vertical' or 'Horizontal'
            Spacing = $Options.Spacing ?? 1
            Padding = $Options.Padding ?? @{ Top = 0; Right = 0; Bottom = 0; Left = 0 }
            Alignment = $Options.Alignment ?? 'Left'  # 'Left', 'Center', 'Right'
            
            # Grid options
            Columns = $Options.Columns ?? 2
            RowHeight = $Options.RowHeight ?? 5
            ColumnWidth = $Options.ColumnWidth ?? 20
            
            # Dock options
            FillLast = $Options.FillLast ?? $true
        }
        
        # Methods
        Add = {
            param($Component, [hashtable]$LayoutProps = @{})
            $this = $args[-1]
            $this.Components += @{
                Component = $Component
                LayoutProps = $LayoutProps
            }
        }.GetNewClosure()
        
        Clear = {
            $this = $args[-1]
            $this.Components = @()
        }.GetNewClosure()
        
        Apply = {
            $this = $args[-1]
            switch ($this.Mode) {
                'Stack' { & $this.ApplyStackLayout }
                'Grid' { & $this.ApplyGridLayout }
                'Dock' { & $this.ApplyDockLayout }
                'Manual' { # Do nothing - components use their existing positions }
            }
        }.GetNewClosure()
        
        ApplyStackLayout = {
            $this = $args[-1]
            $x = $this.Container.X + $this.Options.Padding.Left
            $y = $this.Container.Y + $this.Options.Padding.Top
            $maxWidth = $this.Container.Width - $this.Options.Padding.Left - $this.Options.Padding.Right
            $maxHeight = $this.Container.Height - $this.Options.Padding.Top - $this.Options.Padding.Bottom
            
            foreach ($item in $this.Components) {
                $comp = $item.Component
                
                # Apply alignment
                switch ($this.Options.Alignment) {
                    'Center' { $comp.X = $x + [Math]::Floor(($maxWidth - $comp.Width) / 2) }
                    'Right' { $comp.X = $x + $maxWidth - $comp.Width }
                    default { $comp.X = $x }
                }
                
                if ($this.Options.Direction -eq 'Vertical') {
                    $comp.Y = $y
                    $y += $comp.Height + $this.Options.Spacing
                } else {
                    $comp.Y = $y
                    $x += $comp.Width + $this.Options.Spacing
                }
            }
        }.GetNewClosure()
        
        ApplyGridLayout = {
            $this = $args[-1]
            $startX = $this.Container.X + $this.Options.Padding.Left
            $startY = $this.Container.Y + $this.Options.Padding.Top
            $cols = $this.Options.Columns
            
            for ($i = 0; $i -lt $this.Components.Count; $i++) {
                $comp = $this.Components[$i].Component
                $row = [Math]::Floor($i / $cols)
                $col = $i % $cols
                
                $comp.X = $startX + ($col * ($this.Options.ColumnWidth + $this.Options.Spacing))
                $comp.Y = $startY + ($row * ($this.Options.RowHeight + $this.Options.Spacing))
                
                # Optionally constrain size to grid cell
                if ($this.Components[$i].LayoutProps.ConstrainToCell) {
                    $comp.Width = [Math]::Min($comp.Width, $this.Options.ColumnWidth)
                    $comp.Height = [Math]::Min($comp.Height, $this.Options.RowHeight)
                }
            }
        }.GetNewClosure()
        
        ApplyDockLayout = {
            $this = $args[-1]
            $remainingX = $this.Container.X
            $remainingY = $this.Container.Y
            $remainingWidth = $this.Container.Width
            $remainingHeight = $this.Container.Height
            
            # Process in order: Top, Bottom, Left, Right, Fill
            $dockOrder = @('Top', 'Bottom', 'Left', 'Right', 'Fill')
            
            foreach ($dock in $dockOrder) {
                $items = $this.Components | Where-Object { $_.LayoutProps.Dock -eq $dock }
                
                foreach ($item in $items) {
                    $comp = $item.Component
                    
                    switch ($dock) {
                        'Top' {
                            $comp.X = $remainingX
                            $comp.Y = $remainingY
                            $comp.Width = $remainingWidth
                            $remainingY += $comp.Height
                            $remainingHeight -= $comp.Height
                        }
                        'Bottom' {
                            $comp.X = $remainingX
                            $comp.Y = $remainingY + $remainingHeight - $comp.Height
                            $comp.Width = $remainingWidth
                            $remainingHeight -= $comp.Height
                        }
                        'Left' {
                            $comp.X = $remainingX
                            $comp.Y = $remainingY
                            $comp.Height = $remainingHeight
                            $remainingX += $comp.Width
                            $remainingWidth -= $comp.Width
                        }
                        'Right' {
                            $comp.X = $remainingX + $remainingWidth - $comp.Width
                            $comp.Y = $remainingY
                            $comp.Height = $remainingHeight
                            $remainingWidth -= $comp.Width
                        }
                        'Fill' {
                            $comp.X = $remainingX
                            $comp.Y = $remainingY
                            $comp.Width = $remainingWidth
                            $comp.Height = $remainingHeight
                        }
                    }
                }
            }
        }.GetNewClosure()
        
        # Helper to calculate required size
        GetRequiredSize = {
            $this = $args[-1]
            $width = 0
            $height = 0
            
            switch ($this.Mode) {
                'Stack' {
                    if ($this.Options.Direction -eq 'Vertical') {
                        $width = ($this.Components | ForEach-Object { $_.Component.Width } | Measure-Object -Maximum).Maximum
                        $height = ($this.Components | ForEach-Object { $_.Component.Height } | Measure-Object -Sum).Sum
                        $height += ($this.Components.Count - 1) * $this.Options.Spacing
                    } else {
                        $width = ($this.Components | ForEach-Object { $_.Component.Width } | Measure-Object -Sum).Sum
                        $width += ($this.Components.Count - 1) * $this.Options.Spacing
                        $height = ($this.Components | ForEach-Object { $_.Component.Height } | Measure-Object -Maximum).Maximum
                    }
                }
                'Grid' {
                    $cols = $this.Options.Columns
                    $rows = [Math]::Ceiling($this.Components.Count / $cols)
                    $width = $cols * $this.Options.ColumnWidth + ($cols - 1) * $this.Options.Spacing
                    $height = $rows * $this.Options.RowHeight + ($rows - 1) * $this.Options.Spacing
                }
            }
            
            $width += $this.Options.Padding.Left + $this.Options.Padding.Right
            $height += $this.Options.Padding.Top + $this.Options.Padding.Bottom
            
            return @{ Width = $width; Height = $height }
        }.GetNewClosure()
    }
    
    # Bind methods to the manager instance
    $manager.Add = $manager.Add.Invoke(@($manager))
    $manager.Clear = $manager.Clear.Invoke(@($manager))
    $manager.Apply = $manager.Apply.Invoke(@($manager))
    $manager.ApplyStackLayout = $manager.ApplyStackLayout.Invoke(@($manager))
    $manager.ApplyGridLayout = $manager.ApplyGridLayout.Invoke(@($manager))
    $manager.ApplyDockLayout = $manager.ApplyDockLayout.Invoke(@($manager))
    $manager.GetRequiredSize = $manager.GetRequiredSize.Invoke(@($manager))
    
    return $manager
}

function global:Center-Component {
    <#
    .SYNOPSIS
    Centers a component within a container
    #>
    param(
        [hashtable]$Component,
        [hashtable]$Container = @{ X = 0; Y = 0; Width = $global:TuiState.BufferWidth; Height = $global:TuiState.BufferHeight }
    )
    
    $Component.X = $Container.X + [Math]::Floor(($Container.Width - $Component.Width) / 2)
    $Component.Y = $Container.Y + [Math]::Floor(($Container.Height - $Component.Height) / 2)
}

function global:Align-Components {
    <#
    .SYNOPSIS
    Aligns multiple components horizontally or vertically
    #>
    param(
        [hashtable[]]$Components,
        [string]$Direction = 'Horizontal',  # 'Horizontal' or 'Vertical'
        [string]$Alignment = 'Center',      # 'Top', 'Middle', 'Bottom' for horizontal; 'Left', 'Center', 'Right' for vertical
        [int]$Spacing = 2
    )
    
    if ($Components.Count -eq 0) { return }
    
    if ($Direction -eq 'Horizontal') {
        # Calculate total width needed
        $totalWidth = ($Components | ForEach-Object { $_.Width } | Measure-Object -Sum).Sum
        $totalWidth += ($Components.Count - 1) * $Spacing
        
        # Starting X position
        $currentX = switch ($Alignment) {
            'Left' { 0 }
            'Right' { $global:TuiState.BufferWidth - $totalWidth }
            default { [Math]::Floor(($global:TuiState.BufferWidth - $totalWidth) / 2) }
        }
        
        # Position each component
        foreach ($comp in $Components) {
            $comp.X = $currentX
            $currentX += $comp.Width + $Spacing
        }
    } else {
        # Calculate total height needed
        $totalHeight = ($Components | ForEach-Object { $_.Height } | Measure-Object -Sum).Sum
        $totalHeight += ($Components.Count - 1) * $Spacing
        
        # Starting Y position
        $currentY = switch ($Alignment) {
            'Top' { 0 }
            'Bottom' { $global:TuiState.BufferHeight - $totalHeight }
            default { [Math]::Floor(($global:TuiState.BufferHeight - $totalHeight) / 2) }
        }
        
        # Position each component
        foreach ($comp in $Components) {
            $comp.Y = $currentY
            $currentY += $comp.Height + $Spacing
        }
    }
}

function global:Create-ComponentGrid {
    <#
    .SYNOPSIS
    Arranges components in a grid layout
    #>
    param(
        [hashtable[]]$Components,
        [int]$Columns = 2,
        [int]$StartX = 0,
        [int]$StartY = 0,
        [int]$CellWidth = 20,
        [int]$CellHeight = 5,
        [int]$HorizontalSpacing = 2,
        [int]$VerticalSpacing = 1
    )
    
    for ($i = 0; $i -lt $Components.Count; $i++) {
        $row = [Math]::Floor($i / $Columns)
        $col = $i % $Columns
        
        $Components[$i].X = $StartX + ($col * ($CellWidth + $HorizontalSpacing))
        $Components[$i].Y = $StartY + ($row * ($CellHeight + $VerticalSpacing))
    }
}

Export-ModuleMember -Function @(
    'New-TuiLayoutManager',
    'Center-Component',
    'Align-Components',
    'Create-ComponentGrid'
)
# Component Positioning Helper Module
# Provides utilities for easier component placement and relative positioning

function global:New-TuiPositioner {
    <#
    .SYNOPSIS
    Creates a positioning helper for managing component placement
    
    .DESCRIPTION
    The positioner helps calculate positions for components relative to each other
    and handles common layout patterns like rows, columns, and grids.
    
    .PARAMETER Container
    Defines the bounding container for positioning
    
    .EXAMPLE
    $pos = New-TuiPositioner -Container @{X=0; Y=0; Width=80; Height=25}
    $button1Pos = $pos.NextInRow(10, 3)  # Width=10, Height=3
    $button2Pos = $pos.NextInRow(10, 3)  # Automatically positioned after button1
    #>
    param(
        [hashtable]$Container = @{ X = 0; Y = 0; Width = 80; Height = 25 },
        [hashtable]$Options = @{}
    )
    
    $positioner = @{
        Container = $Container
        CurrentX = $Container.X + ($Options.PaddingLeft ?? 0)
        CurrentY = $Container.Y + ($Options.PaddingTop ?? 0)
        RowHeight = 0
        Options = @{
            Spacing = $Options.Spacing ?? 1
            PaddingTop = $Options.PaddingTop ?? 0
            PaddingRight = $Options.PaddingRight ?? 0
            PaddingBottom = $Options.PaddingBottom ?? 0
            PaddingLeft = $Options.PaddingLeft ?? 0
        }
        
        # Reset to start of container
        Reset = {
            $this.CurrentX = $this.Container.X + $this.Options.PaddingLeft
            $this.CurrentY = $this.Container.Y + $this.Options.PaddingTop
            $this.RowHeight = 0
        }
        
        # Move to next row
        NewRow = {
            $this.CurrentX = $this.Container.X + $this.Options.PaddingLeft
            $this.CurrentY += $this.RowHeight + $this.Options.Spacing
            $this.RowHeight = 0
        }
        
        # Get next position in current row
        NextInRow = {
            param([int]$Width, [int]$Height)
            
            # Check if component fits in current row
            $maxX = $this.Container.X + $this.Container.Width - $this.Options.PaddingRight
            if (($this.CurrentX + $Width) -gt $maxX) {
                & $this.NewRow
            }
            
            $position = @{
                X = $this.CurrentX
                Y = $this.CurrentY
                Width = $Width
                Height = $Height
            }
            
            # Update position for next component
            $this.CurrentX += $Width + $this.Options.Spacing
            $this.RowHeight = [Math]::Max($this.RowHeight, $Height)
            
            return $position
        }
        
        # Get next position in current column
        NextInColumn = {
            param([int]$Width, [int]$Height)
            
            # Check if component fits in current column
            $maxY = $this.Container.Y + $this.Container.Height - $this.Options.PaddingBottom
            if (($this.CurrentY + $Height) -gt $maxY) {
                # Move to next column
                $this.CurrentY = $this.Container.Y + $this.Options.PaddingTop
                $this.CurrentX += $Width + $this.Options.Spacing
            }
            
            $position = @{
                X = $this.CurrentX
                Y = $this.CurrentY
                Width = $Width
                Height = $Height
            }
            
            # Update position for next component
            $this.CurrentY += $Height + $this.Options.Spacing
            
            return $position
        }
        
        # Position at specific coordinates
        At = {
            param([int]$X, [int]$Y, [int]$Width, [int]$Height)
            
            $this.CurrentX = $X + $Width + $this.Options.Spacing
            $this.CurrentY = $Y
            $this.RowHeight = $Height
            
            return @{
                X = $X
                Y = $Y
                Width = $Width
                Height = $Height
            }
        }
        
        # Position relative to another position
        RelativeTo = {
            param(
                [hashtable]$Reference,
                [string]$Direction = "Right",  # Right, Left, Above, Below
                [int]$Width,
                [int]$Height,
                [int]$Offset = $null
            )
            
            if ($null -eq $Offset) { $Offset = $this.Options.Spacing }
            
            $position = switch ($Direction) {
                "Right" {
                    @{
                        X = $Reference.X + $Reference.Width + $Offset
                        Y = $Reference.Y
                        Width = $Width
                        Height = $Height
                    }
                }
                "Left" {
                    @{
                        X = $Reference.X - $Width - $Offset
                        Y = $Reference.Y
                        Width = $Width
                        Height = $Height
                    }
                }
                "Below" {
                    @{
                        X = $Reference.X
                        Y = $Reference.Y + $Reference.Height + $Offset
                        Width = $Width
                        Height = $Height
                    }
                }
                "Above" {
                    @{
                        X = $Reference.X
                        Y = $Reference.Y - $Height - $Offset
                        Width = $Width
                        Height = $Height
                    }
                }
            }
            
            return $position
        }
        
        # Center component in container
        Center = {
            param([int]$Width, [int]$Height)
            
            return @{
                X = $this.Container.X + [Math]::Floor(($this.Container.Width - $Width) / 2)
                Y = $this.Container.Y + [Math]::Floor(($this.Container.Height - $Height) / 2)
                Width = $Width
                Height = $Height
            }
        }
        
        # Align to edges
        AlignTopLeft = {
            param([int]$Width, [int]$Height)
            return @{
                X = $this.Container.X + $this.Options.PaddingLeft
                Y = $this.Container.Y + $this.Options.PaddingTop
                Width = $Width
                Height = $Height
            }
        }
        
        AlignTopRight = {
            param([int]$Width, [int]$Height)
            return @{
                X = $this.Container.X + $this.Container.Width - $Width - $this.Options.PaddingRight
                Y = $this.Container.Y + $this.Options.PaddingTop
                Width = $Width
                Height = $Height
            }
        }
        
        AlignBottomLeft = {
            param([int]$Width, [int]$Height)
            return @{
                X = $this.Container.X + $this.Options.PaddingLeft
                Y = $this.Container.Y + $this.Container.Height - $Height - $this.Options.PaddingBottom
                Width = $Width
                Height = $Height
            }
        }
        
        AlignBottomRight = {
            param([int]$Width, [int]$Height)
            return @{
                X = $this.Container.X + $this.Container.Width - $Width - $this.Options.PaddingRight
                Y = $this.Container.Y + $this.Container.Height - $Height - $this.Options.PaddingBottom
                Width = $Width
                Height = $Height
            }
        }
    }
    
    return $positioner
}

function global:Position-Components {
    <#
    .SYNOPSIS
    Positions multiple components using a layout pattern
    
    .PARAMETER Components
    Array of component hashtables to position
    
    .PARAMETER Pattern
    Layout pattern: 'Row', 'Column', 'Grid', 'Flow'
    
    .PARAMETER Container
    Container bounds
    
    .PARAMETER Options
    Layout options (spacing, columns for grid, etc.)
    #>
    param(
        [hashtable[]]$Components,
        [string]$Pattern = 'Row',
        [hashtable]$Container = @{ X = 0; Y = 0; Width = 80; Height = 25 },
        [hashtable]$Options = @{}
    )
    
    $spacing = $Options.Spacing ?? 1
    $padding = $Options.Padding ?? @{ Top = 0; Right = 0; Bottom = 0; Left = 0 }
    
    switch ($Pattern) {
        'Row' {
            $x = $Container.X + $padding.Left
            $y = $Container.Y + $padding.Top
            
            foreach ($comp in $Components) {
                $comp.X = $x
                $comp.Y = $y
                $x += $comp.Width + $spacing
            }
        }
        
        'Column' {
            $x = $Container.X + $padding.Left
            $y = $Container.Y + $padding.Top
            
            foreach ($comp in $Components) {
                $comp.X = $x
                $comp.Y = $y
                $y += $comp.Height + $spacing
            }
        }
        
        'Grid' {
            $columns = $Options.Columns ?? 2
            $x = $Container.X + $padding.Left
            $y = $Container.Y + $padding.Top
            $col = 0
            $rowHeight = 0
            
            foreach ($comp in $Components) {
                if ($col -ge $columns) {
                    $col = 0
                    $x = $Container.X + $padding.Left
                    $y += $rowHeight + $spacing
                    $rowHeight = 0
                }
                
                $comp.X = $x
                $comp.Y = $y
                $x += $comp.Width + $spacing
                $rowHeight = [Math]::Max($rowHeight, $comp.Height)
                $col++
            }
        }
        
        'Flow' {
            $x = $Container.X + $padding.Left
            $y = $Container.Y + $padding.Top
            $maxX = $Container.X + $Container.Width - $padding.Right
            $rowHeight = 0
            
            foreach ($comp in $Components) {
                # Check if component fits in current row
                if (($x + $comp.Width) -gt $maxX -and $x -ne ($Container.X + $padding.Left)) {
                    # Move to next row
                    $x = $Container.X + $padding.Left
                    $y += $rowHeight + $spacing
                    $rowHeight = 0
                }
                
                $comp.X = $x
                $comp.Y = $y
                $x += $comp.Width + $spacing
                $rowHeight = [Math]::Max($rowHeight, $comp.Height)
            }
        }
    }
}

function global:Get-RelativePosition {
    <#
    .SYNOPSIS
    Calculate position relative to another component
    #>
    param(
        [hashtable]$Reference,
        [string]$Direction = "Right",
        [int]$Offset = 1
    )
    
    switch ($Direction) {
        "Right" { return @{ X = $Reference.X + $Reference.Width + $Offset; Y = $Reference.Y } }
        "Left" { return @{ X = $Reference.X - $Offset; Y = $Reference.Y } }
        "Above" { return @{ X = $Reference.X; Y = $Reference.Y - $Offset } }
        "Below" { return @{ X = $Reference.X; Y = $Reference.Y + $Reference.Height + $Offset } }
        "TopRight" { return @{ X = $Reference.X + $Reference.Width + $Offset; Y = $Reference.Y } }
        "TopLeft" { return @{ X = $Reference.X - $Offset; Y = $Reference.Y } }
        "BottomRight" { return @{ X = $Reference.X + $Reference.Width + $Offset; Y = $Reference.Y + $Reference.Height } }
        "BottomLeft" { return @{ X = $Reference.X - $Offset; Y = $Reference.Y + $Reference.Height } }
    }
}

Export-ModuleMember -Function @(
    'New-TuiPositioner',
    'Position-Components',
    'Get-RelativePosition'
)
