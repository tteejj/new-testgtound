Of course. Here is the continuation of the `helper.ps1` file, followed by the remaining modules.

---
### **File 2: `helper.ps1` (Continuation)**

```powershell
    $script:Data.Settings = Get-DefaultSettings
    $Global:AppConfig = $script:Data.Settings
    Save-UnifiedData
    Write-Success "All settings have been reset to default. Please restart the application."
    $script:keepRunning = $false
}
#endregion
```

---
### **File 3: `theme.ps1`**
*This is the advanced theme module from `CURRENT`. It supports multiple named themes, hex colors, gradients, and visual effects. It is now the definitive theme engine for the application.*

```powershell
# Enhanced Theme System Module
# Advanced theming with gradients, effects, and visual styles

#region Theme Presets

$script:ThemePresets = @{
    "Cyberpunk" = @{
        Name = "Cyberpunk"
        Description = "Neon-lit dystopian future"
        Palette = @{
            PrimaryFG = "#FF00FF"; SecondaryFG = "#00FFFF"; AccentFG = "#FF1493"; SuccessFG = "#00FF00"; ErrorFG = "#FF0040";
            WarningFG = "#FFFF00"; InfoFG = "#00BFFF"; HeaderFG = "#FF00FF"; SubtleFG = "#8B008B"; Background = "#0D0D0D"
            DataTable = @{ Header = @{ FG = "#FF00FF"; BG = "#0D0D0D" }; DataRow = @{ FG = "#00FFFF"; BG = "#0D0D0D" }; AltRow = @{ FG = "#FF1493"; BG = "#1A1A1A" }; Border = "#FF00FF" }
        }
        Effects = @{ GlowEffect = $true; AnimatedText = $true; NeonBorders = $true }
    }
    "Matrix" = @{
        Name = "Matrix"
        Description = "Follow the white rabbit"
        Palette = @{
            PrimaryFG = "#00FF00"; SecondaryFG = "#008F00"; AccentFG = "#00FF00"; SuccessFG = "#00FF00"; ErrorFG = "#FF0000";
            WarningFG = "#FFFF00"; InfoFG = "#00FF00"; HeaderFG = "#00FF00"; SubtleFG = "#004F00"; Background = "#000000"
            DataTable = @{ Header = @{ FG = "#00FF00"; BG = "#000000" }; DataRow = @{ FG = "#00FF00"; BG = "#000000" }; AltRow = @{ FG = "#008F00"; BG = "#111111" }; Border = "#00FF00" }
        }
        Effects = @{ MatrixRain = $true; GreenGlow = $true; MonoChrome = $true }
    }
    "Synthwave" = @{
        Name = "Synthwave"
        Description = "80s retro-futuristic vibes"
        Palette = @{
            PrimaryFG = "#FF6EC7"; SecondaryFG = "#B967FF"; AccentFG = "#01CDFE"; SuccessFG = "#05FFA1"; ErrorFG = "#FF71CE";
            WarningFG = "#FFFB96"; InfoFG = "#01CDFE"; HeaderFG = "#FF6EC7"; SubtleFG = "#8B5A8F"; Background = "#1A0033"
            DataTable = @{ Header = @{ FG = "#FF6EC7"; BG = "#1A0033" }; DataRow = @{ FG = "#01CDFE"; BG = "#1A0033" }; AltRow = @{ FG = "#B967FF"; BG = "#2A0055" }; Border = "#01CDFE" }
        }
        Effects = @{ ChromaticAberration = $true; RetroGrid = $true; NeonGlow = $true }
    }
    "Nord" = @{
        Name = "Nord"
        Description = "Arctic, north-bluish clean and elegant"
        Palette = @{
            PrimaryFG = "#D8DEE9"; SecondaryFG = "#E5E9F0"; AccentFG = "#88C0D0"; SuccessFG = "#A3BE8C"; ErrorFG = "#BF616A";
            WarningFG = "#EBCB8B"; InfoFG = "#81A1C1"; HeaderFG = "#5E81AC"; SubtleFG = "#4C566A"; Background = "#2E3440"
            DataTable = @{ Header = @{ FG = "#5E81AC"; BG = "#2E3440" }; DataRow = @{ FG = "#D8DEE9"; BG = "#2E3440" }; AltRow = @{ FG = "#E5E9F0"; BG = "#3B4252" }; Border = "#88C0D0" }
        }
        Effects = @{ SoftShadows = $true; MinimalBorders = $true; CleanDesign = $true }
    }
    "Dracula" = @{
        Name = "Dracula"
        Description = "Dark theme for the creatures of the night"
        Palette = @{
            PrimaryFG = "#F8F8F2"; SecondaryFG = "#6272A4"; AccentFG = "#BD93F9"; SuccessFG = "#50FA7B"; ErrorFG = "#FF5555";
            WarningFG = "#F1FA8C"; InfoFG = "#8BE9FD"; HeaderFG = "#FF79C6"; SubtleFG = "#44475A"; Background = "#282A36"
            DataTable = @{ Header = @{ FG = "#FF79C6"; BG = "#282A36" }; DataRow = @{ FG = "#F8F8F2"; BG = "#282A36" }; AltRow = @{ FG = "#6272A4"; BG = "#44475A" }; Border = "#BD93F9" }
        }
        Effects = @{ VampireMode = $true; PurpleAccents = $true; DarkContrast = $true }
    }
    "Legacy" = @{
        Name = "Legacy"
        Description = "Classic console colors for maximum compatibility"
        Palette = @{
            PrimaryFG = "White"; SecondaryFG = "Gray"; AccentFG = "Magenta"; SuccessFG = "Green"; ErrorFG = "Red";
            WarningFG = "Yellow"; InfoFG = "Blue"; HeaderFG = "Cyan"; SubtleFG = "DarkGray"; Background = "Black"
            DataTable = @{ Header = @{ FG = "Cyan"; BG = "Black" }; DataRow = @{ FG = "White"; BG = "Black" }; AltRow = @{ FG = "Gray"; BG = "Black" }; Border = "Cyan" }
        }
        Effects = @{ Bold = $false; Italic = $false; Underline = $false; Blink = $false }
    }
}

$script:CurrentTheme = $null

#endregion

#region Gradient Support

function global:Get-GradientText {
    param(
        [string]$Text,
        [string]$StartColor,
        [string]$EndColor,
        [switch]$Bold
    )
    
    if ($Text.Length -eq 0) { return "" }
    
    $startR = [Convert]::ToInt32($StartColor.Substring(1,2), 16)
    $startG = [Convert]::ToInt32($StartColor.Substring(3,2), 16)
    $startB = [Convert]::ToInt32($StartColor.Substring(5,2), 16)
    
    $endR = [Convert]::ToInt32($EndColor.Substring(1,2), 16)
    $endG = [Convert]::ToInt32($EndColor.Substring(3,2), 16)
    $endB = [Convert]::ToInt32($EndColor.Substring(5,2), 16)
    
    $result = ""
    $boldCode = if ($Bold) { "$($PSStyle.Bold)" } else { "" }
    
    for ($i = 0; $i -lt $Text.Length; $i++) {
        $progress = if ($Text.Length -gt 1) { $i / ($Text.Length - 1) } else { 0 }
        
        $r = [Math]::Round($startR + ($endR - $startR) * $progress)
        $g = [Math]::Round($startG + ($endG - $startG) * $progress)
        $b = [Math]::Round($startB + ($endB - $startB) * $progress)
        
        $result += "$boldCode$($PSStyle.Foreground.FromRgb($r,$g,$b))$($Text[$i])"
    }
    
    return $result + "$($PSStyle.Reset)"
}

#endregion

#region Visual Effects

function global:Show-TypewriterText {
    param(
        [string]$Text,
        [int]$Delay = 50,
        [string]$Color = "#FFFFFF"
    )
    
    foreach ($char in $Text.ToCharArray()) {
        Write-Host (Apply-PSStyle -Text $char -FG $Color) -NoNewline
        Start-Sleep -Milliseconds $Delay
    }
    Write-Host
}

function global:Show-GlowText {
    param(
        [string]$Text,
        [string]$GlowColor = "#00FFFF",
        [int]$GlowIntensity = 3
    )
    
    $r = [Convert]::ToInt32($GlowColor.Substring(1,2), 16)
    $g = [Convert]::ToInt32($GlowColor.Substring(3,2), 16)
    $b = [Convert]::ToInt32($GlowColor.Substring(5,2), 16)
    
    for ($i = $GlowIntensity; $i -gt 0; $i--) {
        $intensity = 0.3 * ($i / $GlowIntensity)
        $dimR = [Math]::Round($r * $intensity)
        $dimG = [Math]::Round($g * $intensity)
        $dimB = [Math]::Round($b * $intensity)
        
        $glowLayer = "$($PSStyle.Foreground.FromRgb($dimR,$dimG,$dimB))"
        Write-Host "${glowLayer}$Text$($PSStyle.Reset)"
    }
    
    Write-Host (Apply-PSStyle -Text $Text -FG $GlowColor -Bold)
}

function global:Show-MatrixRain {
    param(
        [int]$Duration = 5,
        [int]$Columns = 10
    )
    
    $chars = "ï½±ï½²ï½³ï½´ï½µï½¶ï½·ï½¸ï½¹ï½ºï½»ï½¼ï½½ï½¾ï½¿ï¾€ï¾ï¾‚ï¾ƒï¾„ï¾…ï¾†ï¾‡ï¾ˆï¾‰ï¾Šï¾‹ï¾Œï¾ï¾ï¾ï¾ï¾‘ï¾’ï¾“ï¾”ï¾•ï¾–ï¾—ï¾˜ï¾™ï¾šï¾›ï¾œï¾0123456789".ToCharArray()
    $rain = @{}
    
    for ($i = 0; $i -lt $Columns; $i++) {
        $rain[$i] = @{
            Position = Get-Random -Minimum 0 -Maximum 20
            Speed = Get-Random -Minimum 1 -Maximum 3
        }
    }
    
    $endTime = (Get-Date).AddSeconds($Duration)
    
    while ((Get-Date) -lt $endTime) {
        Clear-Host
        
        for ($row = 0; $row -lt 20; $row++) {
            for ($col = 0; $col -lt $Columns; $col++) {
                if ($rain[$col].Position -eq $row) {
                    $char = $chars | Get-Random
                    Write-Host (Apply-PSStyle -Text $char -FG "#00FF00" -Bold) -NoNewline
                } elseif ($rain[$col].Position - 1 -eq $row) {
                    $char = $chars | Get-Random
                    Write-Host (Apply-PSStyle -Text $char -FG "#00AA00") -NoNewline
                } elseif ($rain[$col].Position - 2 -eq $row) {
                    $char = $chars | Get-Random
                    Write-Host (Apply-PSStyle -Text $char -FG "#005500") -NoNewline
                } else {
                    Write-Host " " -NoNewline
                }
                Write-Host " " -NoNewline
            }
            Write-Host
        }
        
        foreach ($col in $rain.Keys) {
            $rain[$col].Position += $rain[$col].Speed
            if ($rain[$col].Position -gt 25) {
                $rain[$col].Position = -2
                $rain[$col].Speed = Get-Random -Minimum 1 -Maximum 3
            }
        }
        
        Start-Sleep -Milliseconds 100
    }
}

#endregion

#region Theme System Functions

function global:Initialize-ThemeSystem {
    $defaultThemeName = "Legacy"
    try {
        if ($PSVersionTable.PSVersion.Major -ge 7) { $defaultThemeName = "Cyberpunk" }
        elseif ($env:WT_SESSION -or $env:TERM_PROGRAM -eq "vscode") { $defaultThemeName = "Nord" }
    } catch { $defaultThemeName = "Legacy" }
    
    $themeName = $defaultThemeName
    if ($script:Data -and $script:Data.Settings -and $script:Data.Settings.CurrentTheme) { 
        $themeName = $script:Data.Settings.CurrentTheme
    }
    
    Apply-Theme -ThemeName $themeName
}

function global:Apply-Theme {
    param(
        [string]$ThemeName
    )
    
    if (-not $script:ThemePresets.ContainsKey($ThemeName)) {
        Write-Warning "Theme '$ThemeName' not found. Available themes: $($script:ThemePresets.Keys -join ', '). Using Legacy."
        $ThemeName = "Legacy"
    }
    
    $script:CurrentTheme = $script:ThemePresets[$ThemeName]
    
    if ($script:CurrentTheme.Effects.MatrixRain) {
        Write-Host "`nActivating Matrix mode..." -ForegroundColor Green
        Show-MatrixRain -Duration 2 -Columns 20
    }
    
    if ($script:CurrentTheme.Effects.NeonGlow) {
        Show-GlowText -Text "Theme '$ThemeName' Activated!" -GlowColor $script:CurrentTheme.Palette.AccentFG
    } else {
        Write-Success "Theme '$ThemeName' applied successfully!"
    }
    
    if ($script:Data -and $script:Data.Settings) {
        $script:Data.Settings.Theme = @{
            Header = Get-LegacyColor $script:CurrentTheme.Palette.HeaderFG
            Success = Get-LegacyColor $script:CurrentTheme.Palette.SuccessFG
            Warning = Get-LegacyColor $script:CurrentTheme.Palette.WarningFG
            Error = Get-LegacyColor $script:CurrentTheme.Palette.ErrorFG
            Info = Get-LegacyColor $script:CurrentTheme.Palette.InfoFG
            Accent = Get-LegacyColor $script:CurrentTheme.Palette.AccentFG
            Subtle = Get-LegacyColor $script:CurrentTheme.Palette.SubtleFG
        }
        
        $script:Data.Settings.CurrentTheme = $ThemeName
        Save-UnifiedData
    }
}

function global:Get-ThemeProperty {
    param([string]$Path)
    
    if (-not $script:CurrentTheme) {
        switch ($Path) {
            "Palette.HeaderFG" { return "Cyan" }; "Palette.SuccessFG" { return "Green" }; "Palette.ErrorFG" { return "Red" }
            "Palette.WarningFG" { return "Yellow" }; "Palette.InfoFG" { return "Blue" }; "Palette.AccentFG" { return "Magenta" }
            "Palette.SubtleFG" { return "DarkGray" }; "Palette.PrimaryFG" { return "White" }; "Palette.SecondaryFG" { return "Gray" }
            "DataTable.Header.FG" { return "Cyan" }; "DataTable.DataRow.FG" { return "White" }; "DataTable.AltRow.FG" { return "Gray" }
            "DataTable.DataRow.BG" { return $null }; "DataTable.AltRow.BG" { return $null }; default { return "White" }
        }
    }
    
    $parts = $Path -split '\.'
    $current = $script:CurrentTheme
    
    foreach ($part in $parts) {
        if ($current -is [hashtable] -and $current.ContainsKey($part)) {
            $current = $current[$part]
        } else {
            return "White"
        }
    }
    
    return $current
}

function global:Get-LegacyColor {
    param([string]$Color)
    
    if ($Color -in [System.Enum]::GetNames([System.ConsoleColor])) { return $Color }

    if ($Color -match '^#[0-9A-Fa-f]{6}$') {
        $colorMappings = @{
            '#FF0000' = 'Red'; '#DC143C' = 'Red'; '#FF6347' = 'Red'; '#FF0040' = 'Red'; '#FF5555' = 'Red'; '#FF71CE' = 'Red'; '#BF616A' = 'Red'
            '#00FF00' = 'Green'; '#39FF14' = 'Green'; '#32CD32' = 'Green'; '#228B22' = 'Green'; '#05FFA1' = 'Green'; '#50FA7B' = 'Green'; '#A3BE8C' = 'Green'
            '#00FFFF' = 'Cyan'; '#1E90FF' = 'Blue'; '#4169E1' = 'Blue'; '#4682B4' = 'Blue'; '#00BFFF' = 'Blue'; '#01CDFE' = 'Cyan'; '#8BE9FD' = 'Cyan'; '#81A1C1' = 'Blue'; '#88C0D0' = 'Cyan'; '#5E81AC' = 'Blue'
            '#FFFF00' = 'Yellow'; '#FFD700' = 'Yellow'; '#FF8C00' = 'Yellow'; '#FF6D00' = 'Yellow'; '#FFFB96' = 'Yellow'; '#F1FA8C' = 'Yellow'; '#EBCB8B' = 'Yellow'
            '#FF1493' = 'Magenta'; '#FF00FF' = 'Magenta'; '#BD93F9' = 'Magenta'; '#B967FF' = 'Magenta'; '#FF6EC7' = 'Magenta'; '#FF79C6' = 'Magenta'
            '#808080' = 'Gray'; '#666666' = 'DarkGray'; '#708090' = 'DarkGray'; '#696969' = 'DarkGray'; '#8B008B' = 'DarkMagenta'; '#4C566A' = 'DarkGray'; '#44475A' = 'DarkGray'; '#6272A4' = 'DarkGray'
            '#FFFFFF' = 'White'; '#E0F6FF' = 'White'; '#F5DEB3' = 'White'; '#F8F8F2' = 'White'; '#D8DEE9' = 'White'; '#E5E9F0' = 'White'; '#87CEEB' = 'Gray'; '#DEB887' = 'Gray'
        }
        if ($colorMappings.ContainsKey($Color.ToUpper())) { return $colorMappings[$Color.ToUpper()] } else { return 'White' }
    }
    
    return 'White'
}

function global:Apply-PSStyle {
    param(
        [string]$Text,
        [string]$FG,
        [string]$BG,
        [switch]$Bold,
        [switch]$Italic,
        [switch]$Underline,
        [switch]$Blink
    )
    
    if ($PSVersionTable.PSVersion.Major -ge 7 -and $script:CurrentTheme.Name -ne "Legacy") {
        try {
            $styledText = $Text
            if ($FG -and $FG -match '^#[0-9A-Fa-f]{6}$') { $styledText = "$($PSStyle.Foreground.FromRgb($FG.Substring(1)))$styledText" }
            if ($BG -and $BG -match '^#[0-9A-Fa-f]{6}$') { $styledText = "$($PSStyle.Background.FromRgb($BG.Substring(1)))$styledText" }
            if ($Bold) { $styledText = "$($PSStyle.Bold)$styledText" }
            if ($Italic) { $styledText = "$($PSStyle.Italic)$styledText" }
            if ($Underline) { $styledText = "$($PSStyle.Underline)$styledText" }
            if ($Blink) { $styledText = "$($PSStyle.Blink)$styledText" }
            return "$styledText$($PSStyle.Reset)"
        } catch { return $Text }
    } else { return $Text }
}

#endregion

#region Legacy Support Functions

function global:Write-Header {
    param([string]$Text)
    $headerColor = Get-LegacyColor (Get-ThemeProperty "Palette.HeaderFG")
    Write-Host "`n$Text" -ForegroundColor $headerColor
    Write-Host ("=" * $Text.Length) -ForegroundColor $headerColor
}

function global:Write-Success {
    param([string]$Text)
    $successColor = Get-LegacyColor (Get-ThemeProperty "Palette.SuccessFG")
    Write-Host "âœ“ $Text" -ForegroundColor $successColor
}

function global:Write-Warning {
    param([string]$Text)
    $warningColor = Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG")
    Write-Host "âš  $Text" -ForegroundColor $warningColor
}

function global:Write-Error {
    param([string]$Text)
    $errorColor = Get-LegacyColor (Get-ThemeProperty "Palette.ErrorFG")
    Write-Host "âœ— $Text" -ForegroundColor $errorColor
}

function global:Write-Info {
    param([string]$Text)
    $infoColor = Get-LegacyColor (Get-ThemeProperty "Palette.InfoFG")
    Write-Host "â„¹ $Text" -ForegroundColor $infoColor
}

#endregion

#region Theme Management UI

function global:Edit-ThemeSettings {
    Write-Header "Theme & Appearance Settings"
    
    if (-not $script:Data.Settings.Theme) {
        $script:Data.Settings.Theme = @{ Header = "Cyan"; Success = "Green"; Warning = "Yellow"; Error = "Red"; Info = "Blue"; Accent = "Magenta"; Subtle = "DarkGray" }
    }
    
    Write-Host "Current Theme: $($script:CurrentTheme.Name)" -ForegroundColor Yellow
    Write-Host "`nTheme Management Options:" -ForegroundColor Yellow
    Write-Host "[1] Change Theme"; Write-Host "[2] Test Current Theme"; Write-Host "[3] Reset to Default Theme (Legacy)"; Write-Host "[4] View Theme Details"; Write-Host "[B] Back"
    
    $choice = Read-Host "`nChoice"
    
    switch ($choice.ToUpper()) {
        "1" { Show-ThemeSelector }
        "2" { Test-CurrentTheme }
        "3" { Apply-Theme -ThemeName "Legacy" }
        "4" { Show-ThemeDetails }
        "B" { return }
        default { Write-Warning "Invalid choice." }
    }
    
    Save-UnifiedData
}

function global:Show-ThemeSelector {
    Write-Header "Theme Selection"
    
    Write-Host "Available Themes:" -ForegroundColor Yellow
    $themeNames = $script:ThemePresets.Keys | Sort-Object
    
    for ($i = 0; $i -lt $themeNames.Count; $i++) {
        $themeName = $themeNames[$i]
        $theme = $script:ThemePresets[$themeName]
        $current = if ($script:CurrentTheme.Name -eq $themeName) { " (Current)" } else { "" }
        Write-Host "  [$($i + 1)] $themeName$current" -ForegroundColor (Get-LegacyColor $theme.Palette.AccentFG)
        Write-Host "      $($theme.Description)" -ForegroundColor DarkGray
    }
    
    Write-Host "`n[B] Back" -ForegroundColor Yellow
    
    $choice = Read-Host "`nSelect theme number or option"
    
    if ($choice.ToUpper() -eq 'B') { return }
    elseif ($choice -match '^\d+$') {
        $index = [int]$choice - 1
        if ($index -ge 0 -and $index -lt $themeNames.Count) {
            Apply-Theme -ThemeName $themeNames[$index]
            Test-CurrentTheme
        } else { Write-Warning "Invalid selection." }
    } else { Write-Warning "Invalid choice." }
}

function global:Test-CurrentTheme {
    Write-Header "Theme Test - $($script:CurrentTheme.Name)"
    
    Write-Host "Primary Text" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.PrimaryFG"))
    Write-Host "Secondary Text" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SecondaryFG"))
    Write-Host "Accent Text" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.AccentFG"))
    Write-Host ""
    
    Write-Success "Success message"; Write-Error "Error message"; Write-Warning "Warning message"; Write-Info "Info message"
    
    Write-Host "`nSample Table:" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.HeaderFG"))
    
    $sampleData = @(
        [PSCustomObject]@{ Name = "Project Alpha"; Status = "Active"; Progress = 75 }
        [PSCustomObject]@{ Name = "Project Beta"; Status = "Completed"; Progress = 100 }
        [PSCustomObject]@{ Name = "Project Gamma"; Status = "Pending"; Progress = 25 }
    )
    
    $sampleData | Format-TableUnicode -Title "Sample Projects"
    
    Write-Host "`nPress any key to continue..." -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
}

function global:Show-ThemeDetails {
    Write-Header "Theme Details - $($script:CurrentTheme.Name)"
    
    Write-Host $script:CurrentTheme.Description -ForegroundColor Gray
    Write-Host "`nColor Palette:" -ForegroundColor Yellow
    
    foreach ($colorKey in $script:CurrentTheme.Palette.Keys) {
        if ($colorKey -ne "DataTable") {
            $color = $script:CurrentTheme.Palette[$colorKey]
            $legacyColor = Get-LegacyColor $color
            Write-Host "  $colorKey`: $color" -ForegroundColor $legacyColor
        }
    }
    
    Write-Host "`nEffects:" -ForegroundColor Yellow
    foreach ($effectKey in $script:CurrentTheme.Effects.Keys) {
        $enabled = if ($script:CurrentTheme.Effects[$effectKey]) { "Enabled" } else { "Disabled" }
        Write-Host "  $effectKey`: $enabled"
    }
    
    Write-Host "`nPress any key to continue..." -ForegroundColor DarkGray
    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
}

#endregion
```

---
### **File 4: `ui.ps1`**
*This is the UI module. It combines the advanced TUI engine from `NEW` with the visually rich components from `CURRENT`. Functions like `Show-AnimatedHeader` and `Show-StatusCards` are now implemented as "Views" that are rendered to the back buffer, making them compatible with the new architecture.*

```powershell
# Enhanced UI Components Module
# TUI Engine, Tables, menus, borders, and display functions

#region TUI Engine (Buffer Management)
function global:New-ConsoleCell {
    param( [char]$Character = ' ', [string]$FG_Ansi = '39', [string]$BG_Ansi = '49' )
    return @{ Char = $Character; FG_Ansi = $FG_Ansi; BG_Ansi = $BG_Ansi }
}

function global:New-ConsoleBufferInternal {
    param([int]$Width, [int]$Height)
    Write-AppLog "Creating new buffer array: ${Width}x${Height}" "TRACE"
    $grid = @()
    for ($y = 0; $y -lt $Height; $y++) {
        $row = @()
        for ($x = 0; $x -lt $Width; $x++) { $row += New-ConsoleCell }
        $grid += ,$row
    }
    return $grid
}

function global:Initialize-ConsoleBuffers {
    param([int]$Width, [int]$Height)
    Write-AppLog "Initializing console buffers: ${Width}x${Height}" "DEBUG"
    $script:FrontBuffer = New-ConsoleBufferInternal -Width $Width -Height $Height
    $script:BackBuffer = New-ConsoleBufferInternal -Width $Width -Height $Height
    $script:BufferWidth = $Width
    $script:BufferHeight = $Height
}

function global:Clear-BackBuffer {
    if ($null -eq $script:BackBuffer) { Write-Warning "Back buffer is not initialized."; return }
    $defaultCell = New-ConsoleCell
    $defaultCell.FG_Ansi = Get-AnsiCode (Get-ThemeProperty "Palette.PrimaryFG")
    $defaultCell.BG_Ansi = Get-AnsiCode (Get-ThemeProperty "Palette.Background") '49'
    for ($y = 0; $y -lt $script:BufferHeight; $y++) {
        for ($x = 0; $x -lt $script:BufferWidth; $x++) {
            $script:BackBuffer[$y][$x] = $defaultCell.Clone()
        }
    }
}

function global:Write-CellToBuffer {
    param( [int]$X, [int]$Y, [hashtable]$Cell, [hashtable]$ClippingView = $null )
    if ($Y -lt 0 -or $Y -ge $script:BufferHeight -or $X -lt 0 -or $X -ge $script:BufferWidth) { return }
    if ($ClippingView) {
        if ($X -lt $ClippingView.X -or $X -ge ($ClippingView.X + $ClippingView.Width) -or $Y -lt $ClippingView.Y -or $Y -ge ($ClippingView.Y + $ClippingView.Height)) {
            return
        }
    }
    $targetCell = @{ Char = $Cell.Char ?? ' '; FG_Ansi = $Cell.FG_Ansi ?? "39"; BG_Ansi = $Cell.BG_Ansi ?? "49" }
    $script:BackBuffer[$Y][$X] = $targetCell
}

function global:Write-StringToBuffer {
    param( [int]$TargetX, [int]$TargetY, [string]$Text, [string]$FG_Ansi = "39", [string]$BG_Ansi = "49", [hashtable]$ClippingView = $null )
    if ($TargetY -lt 0 -or $TargetY -ge $script:BufferHeight) { return }
    $currentX = $TargetX
    foreach ($char in $Text.ToCharArray()) {
        if ($currentX -ge $script:BufferWidth) { break }
        if ($currentX -ge 0) {
            $cell = @{ Char = $char; FG_Ansi = $FG_Ansi; BG_Ansi = $BG_Ansi }
            Write-CellToBuffer -X $currentX -Y $TargetY -Cell $cell -ClippingView $ClippingView
        }
        $currentX++
    }
}

function global:Show-PmcCurrentScreen {
    $currentScreen = Get-CurrentScreen
    if (-not $currentScreen) { return }

    Clear-BackBuffer
    
    foreach ($viewDef in $currentScreen.Views) {
        $renderFunctionName = "Render-$($viewDef.Type)"
        if (Get-Command $renderFunctionName -ErrorAction SilentlyContinue) {
            & $renderFunctionName -ViewDefinition $viewDef
        } else {
            Write-AppLog "Renderer '$renderFunctionName' not found for view '$($viewDef.Name)'" "WARN"
        }
    }

    Show-PmcConsoleBuffer
}

function global:Show-PmcConsoleBuffer {
    Write-AppLog "Show-PmcConsoleBuffer: Starting presentation." "TRACE"
    $output = [System.Text.StringBuilder]::new(16384)
    $currentTerminalState = @{ FG_Ansi = "39"; BG_Ansi = "49" }
    
    for ($y = 0; $y -lt $script:BufferHeight; $y++) {
        $needsMove = $true
        for ($x = 0; $x -lt $script:BufferWidth; $x++) {
            $backCell = $script:BackBuffer[$y][$x]
            $frontCell = $script:FrontBuffer[$y][$x]
            $isDifferent = ($backCell.Char -ne $frontCell.Char) -or ($backCell.FG_Ansi -ne $frontCell.FG_Ansi) -or ($backCell.BG_Ansi -ne $frontCell.BG_Ansi)
            
            if ($isDifferent) {
                if ($needsMove) { $output.Append("`e[$($y + 1);$($x + 1)H") | Out-Null; $needsMove = $false }
                
                if ($backCell.FG_Ansi -ne $currentTerminalState.FG_Ansi) { $output.Append("`e[$($backCell.FG_Ansi)m") | Out-Null; $currentTerminalState.FG_Ansi = $backCell.FG_Ansi }
                if ($backCell.BG_Ansi -ne $currentTerminalState.BG_Ansi) { $output.Append("`e[$($backCell.BG_Ansi)m") | Out-Null; $currentTerminalState.BG_Ansi = $backCell.BG_Ansi }
                
                $output.Append($backCell.Char) | Out-Null
                $script:FrontBuffer[$y][$x] = $backCell.Clone()
            } else {
                $needsMove = $true
            }
        }
    }
    
    if ($currentTerminalState.FG_Ansi -ne '39' -or $currentTerminalState.BG_Ansi -ne '49') { 
        $output.Append("`e[0m") | Out-Null
    }
    
    if ($output.Length -gt 0) {
        Write-Host $output.ToString() -NoNewline
    }
}
#endregion

#region View Renderers
function global:Render-AnimatedHeaderView {
    param([hashtable]$ViewDefinition)
    $x = $ViewDefinition.X; $y = $ViewDefinition.Y; $width = $ViewDefinition.Width; $height = $ViewDefinition.Height
    
    $headerLines = @(
        "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—",
        "â•‘  â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—     â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â•‘",
        "â•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â• â•‘",
        "â•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â•‘",
        "â•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘    â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â•šâ•â•â•â•â–ˆâ–ˆâ•‘ â•‘",
        "â•‘  â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•     â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘ â•‘",
        "â•‘   â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•â•â•â•šâ•â•â•šâ•â•     â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•       â•šâ•â•â•â•  â•šâ•â•â•â•â•â•â• â•‘",
        "â•‘                  ğŸš€ PRODUCTIVITY SUITE v5.0 TURBO ğŸš€                     â•‘",
        "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    )
    
    $gradientColors = @("#0080FF", "#00A0FF", "#00C0FF", "#00D0FF", "#00E0FF", "#00F0FF", "#00FFFF", "#00FFFF", "#00FFFF")

    for ($i = 0; $i -lt [Math]::Min($headerLines.Count, $height); $i++) {
        $line = $headerLines[$i]
        $ansiLine = Get-GradientText -Text $line -StartColor $gradientColors[$i] -EndColor $gradientColors[$i]
        # This is a simplified approach. A true buffer write would parse the ANSI.
        # For now, we just Write-Host for this specific component.
        Write-Host $ansiLine
    }
}

function global:Render-StatusCardsView {
    param([hashtable]$ViewDefinition)
    $x = $ViewDefinition.X; $y = $ViewDefinition.Y; $width = $ViewDefinition.Width; $height = $ViewDefinition.Height
    
    # This is a complex component. For integration, we'll use Write-Host as a temporary measure.
    # A full implementation would draw each character to the buffer.
    [Console]::SetCursorPosition($x, $y)
    Show-StatusCards
}

function global:Render-ActivityTimelineView {
    param([hashtable]$ViewDefinition)
    [Console]::SetCursorPosition($ViewDefinition.X, $ViewDefinition.Y)
    Show-ActivityTimeline
}

function global:Render-QuickActionsView {
    param([hashtable]$ViewDefinition)
    [Console]::SetCursorPosition($ViewDefinition.X, $ViewDefinition.Y)
    Show-QuickActions
}

function global:Render-MainMenuView {
    param([hashtable]$ViewDefinition)
    [Console]::SetCursorPosition($ViewDefinition.X, $ViewDefinition.Y)
    Show-MainMenuDisplay
}

function global:Render-HeaderView {
    param([hashtable]$ViewDefinition)
    $x = $ViewDefinition.X; $y = $ViewDefinition.Y; $width = $ViewDefinition.Width
    $text = if ($ViewDefinition.Text -is [scriptblock]) { & $ViewDefinition.Text } else { $ViewDefinition.Text }
    $headerColor = Get-LegacyColor (Get-ThemeProperty "Palette.HeaderFG")
    
    [Console]::SetCursorPosition($x, $y)
    Write-Host "`n$text" -ForegroundColor $headerColor
    Write-Host ("=" * $text.Length) -ForegroundColor $headerColor
}

function global:Render-ListView {
    param([hashtable]$ViewDefinition)
    $x = $ViewDefinition.X; $y = $ViewDefinition.Y; $width = $ViewDefinition.Width; $height = $ViewDefinition.Height
    $items = if ($ViewDefinition.DataSource -is [scriptblock]) { & $ViewDefinition.DataSource } else { $ViewDefinition.DataSource }
    $displayProp = $ViewDefinition.DisplayProperty
    $keyProp = $ViewDefinition.KeyProperty
    
    $viewState = $script:ListViewStates[$ViewDefinition.Name]
    if (-not $viewState) {
        $viewState = @{ SelectedIndex = 0; TopIndex = 0 }
        $script:ListViewStates[$ViewDefinition.Name] = $viewState
    }
    
    for ($i = 0; $i -lt [Math]::Min($items.Count, $height)) {
        $itemIndex = $viewState.TopIndex + $i
        if ($itemIndex -ge $items.Count) { break }
        $item = $items[$itemIndex]
        $displayText = $item.$displayProp
        $keyText = if ($keyProp) { "[$($item.$keyProp)] " } else { "[$($itemIndex + 1)] " }
        
        $line = "$keyText$displayText"
        if ($itemIndex -eq $viewState.SelectedIndex) {
            Write-StringToBuffer -TargetX $x -TargetY ($y + $i) -Text $line -FG_Ansi (Get-AnsiCode "Black") -BG_Ansi (Get-AnsiCode "Cyan")
        } else {
            Write-StringToBuffer -TargetX $x -TargetY ($y + $i) -Text $line
        }
    }
}

#endregion

#region Standalone UI Components (from CURRENT, adapted)

function global:Show-Dashboard {
    Clear-Host
    Show-AnimatedHeader
    Show-StatusCards
    Show-ActivityTimeline
    Show-QuickActions
    Show-MainMenuDisplay
}

function global:Show-AnimatedHeader {
    $headerLines = @(
        "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—",
        "â•‘  â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—     â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â•‘",
        "â•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—    â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â• â•‘",
        "â•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘    â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â•‘",
        "â•‘  â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘    â•šâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•”â•â•šâ•â•â•â•â–ˆâ–ˆâ•‘ â•‘",
        "â•‘  â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘     â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•     â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘ â•‘",
        "â•‘   â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•â•â•â•šâ•â•â•šâ•â•     â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•       â•šâ•â•â•â•  â•šâ•â•â•â•â•â•â• â•‘",
        "â•‘                  ğŸš€ PRODUCTIVITY SUITE v5.0 TURBO ğŸš€                     â•‘",
        "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    )
    
    $gradientColors = @("#0080FF", "#00A0FF", "#00C0FF", "#00D0FF", "#00E0FF", "#00F0FF", "#00FFFF", "#00FFFF", "#00FFFF")
    
    for ($i = 0; $i -lt $headerLines.Count; $i++) {
        Write-Host (Apply-PSStyle -Text $headerLines[$i] -FG $gradientColors[$i])
    }
    Write-Host
}

function global:Show-StatusCards {
    if (-not $script:Data) { 
        Write-Host "ğŸ“Š Status cards unavailable (no data)" -ForegroundColor Gray
        return 
    }
    
    $activeTimers = if ($script:Data.ActiveTimers) { $script:Data.ActiveTimers.Count } else { 0 }
    $activeTasks = if ($script:Data.Tasks) { ($script:Data.Tasks | Where-Object { (-not $_.Completed) -and ($_.IsCommand -ne $true) }).Count } else { 0 }
    $todayHours = 0.0
    if ($script:Data.TimeEntries) {
        $todayHours = ($script:Data.TimeEntries | Where-Object { $_.Date -eq (Get-Date).ToString("yyyy-MM-dd") } | Measure-Object -Property Hours -Sum).Sum
        $todayHours = if ($todayHours) { [Math]::Round($todayHours, 2) } else { 0.0 }
    }
    
    $cards = @(
        @{ Icon = "ğŸ“…"; Title = "TODAY"; Value = (Get-Date).ToString("MMM dd"); Subtitle = (Get-Date).ToString("dddd"); Color = "Palette.InfoFG" },
        @{ Icon = "â±ï¸"; Title = "HOURS"; Value = "$todayHours"; Subtitle = "logged today"; Color = if ($todayHours -ge 6) { "Palette.SuccessFG" } else { "Palette.WarningFG" } },
        @{ Icon = "â°"; Title = "TIMERS"; Value = "$activeTimers"; Subtitle = "active"; Color = if ($activeTimers -gt 0) { "Palette.ErrorFG" } else { "Palette.SubtleFG" } },
        @{ Icon = "âœ…"; Title = "TASKS"; Value = "$activeTasks"; Subtitle = "pending"; Color = if ($activeTasks -gt 10) { "Palette.ErrorFG" } elseif ($activeTasks -gt 5) { "Palette.WarningFG" } else { "Palette.SuccessFG" } }
    )
    
    Write-Host "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"
    Write-Host "â”‚" -NoNewline
    foreach ($card in $cards) {
        $iconAndTitle = "$($card.Icon) $($card.Title)"
        Write-Host (Apply-PSStyle -Text $iconAndTitle.PadRight(16) -FG (Get-ThemeProperty $card.Color)) -NoNewline
        Write-Host "â”‚" -NoNewline
    }
    Write-Host
    
    Write-Host "â”‚" -NoNewline
    foreach ($card in $cards) {
        Write-Host (Apply-PSStyle -Text $card.Value.PadRight(16) -FG (Get-ThemeProperty $card.Color) -Bold) -NoNewline
        Write-Host "â”‚" -NoNewline
    }
    Write-Host
    
    Write-Host "â”‚" -NoNewline
    foreach ($card in $cards) {
        Write-Host (Apply-PSStyle -Text $card.Subtitle.PadRight(16) -FG (Get-ThemeProperty "Palette.SubtleFG")) -NoNewline
        Write-Host "â”‚" -NoNewline
    }
    Write-Host
    Write-Host "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜"
}

function global:Show-ActivityTimeline {
    if (-not $script:Data) {
        Write-Host "`nğŸ“Š Activity timeline unavailable" -ForegroundColor Gray
        return
    }
    
    Write-Host "`nğŸ“Š " -NoNewline
    Write-Host (Apply-PSStyle -Text "ACTIVITY TIMELINE" -FG (Get-ThemeProperty "Palette.AccentFG") -Bold)
    
    $weekStart = Get-WeekStart
    $sparklineChars = @(" ", "â–‚", "â–ƒ", "â–„", "â–…", "â–†", "â–‡", "â–ˆ")
    $weekData = @()
    
    for ($i = 0; $i -lt 7; $i++) {
        $date = $weekStart.AddDays($i).ToString("yyyy-MM-dd")
        $dayHours = 0
        if ($script:Data.TimeEntries) {
            $dayHours = ($script:Data.TimeEntries | Where-Object { $_.Date -eq $date } | Measure-Object -Property Hours -Sum).Sum
        }
        $weekData += if ($dayHours) { [Math]::Min($dayHours, 10) } else { 0 }
    }
    
    $maxHours = ($weekData | Measure-Object -Maximum).Maximum
    if ($maxHours -eq 0) { $maxHours = 1 }
    
    Write-Host "   " -NoNewline
    for ($i = 0; $i -lt 7; $i++) {
        $normalized = [Math]::Floor(($weekData[$i] / $maxHours) * ($sparklineChars.Count -1))
        $char = $sparklineChars[$normalized]
        $isToday = $i -eq [int](Get-Date).DayOfWeek
        
        if ($isToday) {
            Write-Host (Apply-PSStyle -Text "[$char]" -FG (Get-ThemeProperty "Palette.SuccessFG") -Bold) -NoNewline
        } else {
            $color = if ($weekData[$i] -ge 6) { "Palette.SuccessFG" } elseif ($weekData[$i] -gt 0) { "Palette.WarningFG" } else { "Palette.SubtleFG" }
            Write-Host (Apply-PSStyle -Text " $char " -FG (Get-ThemeProperty $color)) -NoNewline
        }
    }
    Write-Host " â†’ $([Math]::Round(($weekData | Measure-Object -Sum).Sum, 1))h this week"
}

function global:Show-QuickActions {
    Write-Host "`nâš¡ " -NoNewline
    Write-Host (Apply-PSStyle -Text "QUICK ACTIONS" -FG (Get-ThemeProperty "Palette.WarningFG") -Bold)
    
    $quickActions = @(
        @{ Key = "M"; Icon = "ğŸ“"; Text = "Manual Entry"; }, @{ Key = "S"; Icon = "â–¶ï¸"; Text = "Start Timer"; },
        @{ Key = "A"; Icon = "â•"; Text = "Add Task"; }, @{ Key = "V"; Icon = "ğŸ‘ï¸"; Text = "View Timers"; },
        @{ Key = "T"; Icon = "ğŸ“…"; Text = "Today View"; }, @{ Key = "W"; Icon = "ğŸ“Š"; Text = "Week Report"; }
    )
    
    $actionsPerRow = 3
    for ($i = 0; $i -lt $quickActions.Count; $i += $actionsPerRow) {
        Write-Host "   " -NoNewline
        for ($j = 0; $j -lt $actionsPerRow -and ($i + $j) -lt $quickActions.Count; $j++) {
            $action = $quickActions[$i + $j]
            Write-Host (Apply-PSStyle -Text "[$($action.Key)]" -FG (Get-ThemeProperty "Palette.InfoFG") -Bold) -NoNewline
            Write-Host " $($action.Icon) $($action.Text)".PadRight(20) -NoNewline
        }
        Write-Host
    }
}

function global:Show-MainMenuDisplay {
    Write-Host "`nğŸ¯ " -NoNewline
    Write-Host (Apply-PSStyle -Text "MAIN MENU" -FG (Get-ThemeProperty "Palette.AccentFG") -Bold)
    
    $menuItems = @(
        @{ Num = "1"; Icon = "â°"; Text = "Time Management"; Color = "Palette.InfoFG" },
        @{ Num = "2"; Icon = "ğŸ“‹"; Text = "Task Management"; Color = "Palette.SuccessFG" },
        @{ Num = "3"; Icon = "ğŸ“ˆ"; Text = "Reports & Analytics"; Color = "Palette.WarningFG" },
        @{ Num = "4"; Icon = "ğŸ¢"; Text = "Projects & Clients"; Color = "Palette.AccentFG" },
        @{ Num = "5"; Icon = "ğŸ”§"; Text = "Tools & Utilities"; Color = "Palette.ErrorFG" },
        @{ Num = "6"; Icon = "âš™ï¸"; Text = "Settings & Config"; Color = "Palette.SubtleFG" }
    )
    
    foreach ($item in $menuItems) {
        Write-Host "   " -NoNewline
        Write-Host (Apply-PSStyle -Text "[$($item.Num)]" -FG (Get-ThemeProperty $item.Color) -Bold) -NoNewline
        Write-Host " $($item.Icon) " -NoNewline
        Write-Host (Apply-PSStyle -Text $item.Text -FG (Get-ThemeProperty $item.Color))
    }
    
    Write-Host "`n   " -NoNewline
    Write-Host (Apply-PSStyle -Text "[Q]" -FG (Get-ThemeProperty "Palette.ErrorFG") -Bold) -NoNewline
    Write-Host " ğŸšª Quit"
}

function global:Show-Notification {
    param(
        [string]$Message,
        [string]$Type = "Info", # Info, Success, Warning, Error
        [int]$Duration = 3000,
        [switch]$Persist
    )
    
    $icons = @{ "Info" = "â„¹ï¸"; "Success" = "âœ…"; "Warning" = "âš ï¸"; "Error" = "âŒ" }
    $colors = @{ "Info" = "Palette.InfoFG"; "Success" = "Palette.SuccessFG"; "Warning" = "Palette.WarningFG"; "Error" = "Palette.ErrorFG" }
    $borderStyle = if ($Type -eq "Error") { "Heavy" } else { "Rounded" }
    $border = Get-BorderStyleChars -Style $borderStyle
    $paddedMessage = " $($icons[$Type]) $Message "
    $width = $paddedMessage.Length + 2
    
    Write-Host "`n$($border.TopLeft)$($border.Horizontal * $width)$($border.TopRight)" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty $colors[$Type]))
    Write-Host "$($border.Vertical)" -NoNewline -ForegroundColor (Get-LegacyColor (Get-ThemeProperty $colors[$Type]))
    Write-Host (Apply-PSStyle -Text $paddedMessage -FG (Get-ThemeProperty $colors[$Type]) -Bold) -NoNewline
    Write-Host "$($border.Vertical)" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty $colors[$Type]))
    Write-Host "$($border.BottomLeft)$($border.Horizontal * $width)$($border.BottomRight)" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty $colors[$Type]))
    
    if (-not $Persist) {
        Start-Sleep -Milliseconds $Duration
        # This clearing method is imperfect in a non-blocking loop but works for simple notifications.
        [Console]::SetCursorPosition(0, [Console]::CursorTop - 4)
        Write-Host (" " * ($width + 4)); Write-Host (" " * ($width + 4)); Write-Host (" " * ($width + 4)); Write-Host (" " * ($width + 4))
        [Console]::SetCursorPosition(0, [Console]::CursorTop - 4)
    }
}

function global:Format-TableUnicode {
    param(
        [Parameter(ValueFromPipeline)] [object[]]$InputData,
        [hashtable[]]$Columns,
        [string]$BorderStyle = "Single",
        [string]$Title = "",
        [switch]$NoHeader,
        [hashtable]$RowHighlightRules = @{}
    )
    
    begin {
        $allData = @()
        $border = Get-BorderStyleChars -Style $BorderStyle 
        try { $MaxWidth = $Host.UI.RawUI.WindowSize.Width - 2 } catch { $MaxWidth = 80 }
    }
    process { if ($InputData) { $allData += $InputData } }
    end {
        if ($allData.Count -eq 0) { Write-Host "No data to display." -ForegroundColor Gray; return }
        if (-not $Columns) {
            $props = $allData[0].PSObject.Properties | Where-Object { $_.MemberType -eq 'NoteProperty' }
            $Columns = $props | ForEach-Object { @{ Name = $_.Name; Title = $_.Name; Width = 0 } }
        }
        
        # Calculate and adjust column widths
        foreach ($col in $Columns) {
            if ($null -eq $col.Width -or $col.Width -eq 0) {
                $maxLen = if ($col.Title) { $col.Title.Length } else { $col.Name.Length }
                foreach ($item in $allData) {
                    $value = $item | Select-Object -ExpandProperty $col.Name
                    $len = if ($value) { $value.ToString().Length } else { 0 }
                    if ($len -gt $maxLen) { $maxLen = $len }
                }
                $col.Width = [Math]::Min($maxLen + 2, ($MaxWidth / 2))
                if ($col.Width -lt ($col.Title.Length + 2)) {$col.Width = $col.Title.Length + 2}
                if ($col.Width -lt 5) { $col.Width = 5 }
            }
        }
        $totalCurrentWidth = ($Columns | Measure-Object -Property Width -Sum).Sum + ($Columns.Count + 1)
        if ($totalCurrentWidth -gt $MaxWidth) {
            $reductionFactor = ($MaxWidth - ($Columns.Count + 1)) / ($Columns | Measure-Object -Property Width -Sum).Sum
            if($reductionFactor -lt 1 -and $reductionFactor -gt 0){
                foreach ($col in $Columns) { $col.Width = [Math]::Max(5, [int]($col.Width * $reductionFactor)) }
            }
            $totalCurrentWidth = ($Columns | Measure-Object -Property Width -Sum).Sum + ($Columns.Count + 1)
        }
        
        # Draw top border
        Write-Host $border.TopLeft -NoNewline
        for ($i = 0; $i -lt $Columns.Count; $i++) { Write-Host ($border.Horizontal * $Columns[$i].Width) -NoNewline; if ($i -lt $Columns.Count - 1) { Write-Host $border.TTop -NoNewline } }
        Write-Host $border.TopRight
        
        # Draw title
        if ($Title) {
            $titleAreaWidth = $totalCurrentWidth - 2
            Write-Host $border.Vertical -NoNewline
            $titlePadded = " $Title ".PadRight($titleAreaWidth) 
            if ($titlePadded.Length -gt $titleAreaWidth) { $titlePadded = $titlePadded.Substring(0, [Math]::Max(0, $titleAreaWidth -1)) + "â€¦" }
            Write-Host (Apply-PSStyle -Text $titlePadded -FG (Get-ThemeProperty "Palette.AccentFG") -Bold) -NoNewline 
            Write-Host $border.Vertical
            Write-Host $border.TLeft -NoNewline
            for ($i = 0; $i -lt $Columns.Count; $i++) { Write-Host ($border.Horizontal * $Columns[$i].Width) -NoNewline; if ($i -lt $Columns.Count - 1) { Write-Host $border.Cross -NoNewline } }
            Write-Host $border.TRight
        }
        
        # Draw header
        if (-not $NoHeader) {
            Write-Host $border.Vertical -NoNewline
            foreach ($col in $Columns) {
                $headerText = Format-TableCell -Text $col.Title -Width $col.Width -Align ($col.AlignHeader ?? "Center")
                Write-Host (Apply-PSStyle -Text $headerText -FG (Get-ThemeProperty "DataTable.Header.FG") -Bold) -NoNewline 
                Write-Host $border.Vertical -NoNewline
            }
            Write-Host
            Write-Host $border.TLeft -NoNewline
            for ($i = 0; $i -lt $Columns.Count; $i++) { Write-Host ($border.Horizontal * $Columns[$i].Width) -NoNewline; if ($i -lt $Columns.Count - 1) { Write-Host $border.Cross -NoNewline } }
            Write-Host $border.TRight
        }
        
        # Draw data rows
        $rowIndex = 0
        foreach ($item in $allData) {
            Write-Host $border.Vertical -NoNewline
            $rowFG = Get-ThemeProperty "DataTable.DataRow.FG"; $rowBG = Get-ThemeProperty "DataTable.DataRow.BG"; $rowBold = $false
            if ($rowIndex % 2 -eq 1 -and (-not $RowHighlightRules -or $RowHighlightRules.Count -eq 0)) { $rowFG = Get-ThemeProperty "DataTable.AltRow.FG"; $rowBG = Get-ThemeProperty "DataTable.AltRow.BG" }
            foreach($ruleName in $RowHighlightRules.Keys){
                $rule = $RowHighlightRules[$ruleName]
                if($item | Where-Object $rule.Condition){
                    $rowFG = if ($rule.FG) { Get-ThemeProperty "Palette.$($rule.FG)FG" } else { $rowFG }
                    $rowBold = if ($rule.Bold) { $rule.Bold } else { $rowBold }
                    break
                }
            }
            foreach ($col in $Columns) {
                $value = $item | Select-Object -ExpandProperty $col.Name
                $cellText = Format-TableCell -Text $value -Width $col.Width -Align ($col.AlignData ?? "Left")
                Write-Host (Apply-PSStyle -Text $cellText -FG $rowFG -BG $rowBG -Bold:$rowBold) -NoNewline
                Write-Host $border.Vertical -NoNewline
            }
            Write-Host
            $rowIndex++
        }
        
        # Draw bottom border
        Write-Host $border.BottomLeft -NoNewline
        for ($i = 0; $i -lt $Columns.Count; $i++) { Write-Host ($border.Horizontal * $Columns[$i].Width) -NoNewline; if ($i -lt $Columns.Count - 1) { Write-Host $border.TBottom -NoNewline } }
        Write-Host $border.BottomRight
    }
}

function global:Format-TableCell {
    param([string]$Text, [int]$Width, [string]$Align = "Left")
    $Text = if ($null -eq $Text) { "" } else { $Text.ToString() } 
    if ($Width -lt 1) { $Width = 1 }
    $contentWidth = $Width - 2
    if ($contentWidth -lt 0) {$contentWidth = 0}
    if ($Text.Length -gt $contentWidth) {
        if ($contentWidth -ge 1) { $Text = $Text.Substring(0, [Math]::Max(0, $contentWidth -1)) + "â€¦" }
        else {$Text = ""}
    }
    $paddedText = switch ($Align.ToLower()) {
        "center" { $Text.PadLeft([int](($contentWidth + $Text.Length) / 2)).PadRight($contentWidth) } 
        "right"  { $Text.PadLeft($contentWidth) } 
        default  { $Text.PadRight($contentWidth) } 
    }
    return " $paddedText "
}

function global:Draw-ProgressBar {
    param(
        [int]$Percent,
        [int]$Width = 20,
        [string]$FillChar = "â–ˆ",
        [string]$EmptyChar = "â–‘"
    )
    if($Percent -lt 0) {$Percent = 0} elseif($Percent -gt 100) {$Percent = 100}
    if($Width -lt 5) {$Width = 5}
    $filledBlocks = [Math]::Floor($Width * ($Percent / 100))
    $emptyBlocks = $Width - $filledBlocks
    $color = if ($Percent -ge 80) { Get-ThemeProperty "Palette.SuccessFG" } 
             elseif ($Percent -ge 50) { Get-ThemeProperty "Palette.WarningFG" } 
             else { Get-ThemeProperty "Palette.ErrorFG" }
    
    Write-Host "[" -NoNewline
    Write-Host (Apply-PSStyle -Text ($FillChar * $filledBlocks) -FG $color) -NoNewline
    Write-Host (Apply-PSStyle -Text ($EmptyChar * $emptyBlocks) -FG (Get-ThemeProperty "Palette.SubtleFG")) -NoNewline
    Write-Host "] $($Percent.ToString().PadLeft(3))%" -NoNewline
}

#endregion
```

---
### **File 5: `core-data.ps1`**
*This is the data management module from `CURRENT`. It contains all the rich functionality for Projects, Tasks, and Command Snippets. It has been reviewed to ensure it uses the new helper and theme functions correctly.*

```powershell
# Core Data Management Module
# Projects, tasks, todos, and command snippets

#region Data Model Initialization

function global:Get-DefaultSettings {
    return @{
        # Time Tracker Settings
        DefaultRate = 100.0 # Use double for currency/rate
        Currency = "USD"
        HoursPerDay = 8.0 # Use double for hours
        DaysPerWeek = 5
        TimeTrackerTemplates = @{
            "ADMIN" = @{ Name = "Administrative Tasks"; Id1 = "100"; Id2 = "ADM"; Client = "Internal"; Department = "Operations"; BillingType = "Non-Billable"; Status = "Active"; Budget = 0.0; Rate = 0.0; Notes = "General administrative tasks" }
            "MEETING" = @{ Name = "Meetings & Calls"; Id1 = "101"; Id2 = "MTG"; Client = "Internal"; Department = "Various"; BillingType = "Non-Billable"; Status = "Active"; Budget = 0.0; Rate = 0.0; Notes = "Team meetings and calls" }
            "TRAINING" = @{ Name = "Training & Learning"; Id1 = "102"; Id2 = "TRN"; Client = "Internal"; Department = "HR"; BillingType = "Non-Billable"; Status = "Active"; Budget = 0.0; Rate = 0.0; Notes = "Professional development" }
            "BREAK" = @{ Name = "Breaks & Personal"; Id1 = "103"; Id2 = "BRK"; Client = "Internal"; Department = "Personal"; BillingType = "Non-Billable"; Status = "Active"; Budget = 0.0; Rate = 0.0; Notes = "Breaks and personal time" }
        }
        # Todo Tracker Settings
        DefaultPriority = "Medium"
        DefaultCategory = "General"
        ShowCompletedDays = 7
        EnableTimeTracking = $true
        AutoArchiveDays = 30
        # Command Snippets Settings
        CommandSnippets = @{
            EnableHotkeys = $true
            AutoCopyToClipboard = $true
            ShowInTaskList = $false
            DefaultCategory = "Commands"
            RecentLimit = 10
        }
        # Excel Integration Settings
        ExcelFormConfig = @{
            WorksheetName = "Project Info"
            StandardFields = @{
                "Id1" = @{ LabelCell = "A5"; ValueCell = "B5"; Label = "Project ID"; Field = "Id1" }
                "Id2" = @{ LabelCell = "A6"; ValueCell = "B6"; Label = "Task Code"; Field = "Id2" }
                "Name" = @{ LabelCell = "A7"; ValueCell = "B7"; Label = "Project Name"; Field = "Name" }
                "FullName" = @{ LabelCell = "A8"; ValueCell = "B8"; Label = "Full Description"; Field = "FullName" }
                "AssignedDate" = @{ LabelCell = "A9"; ValueCell = "B9"; Label = "Start Date"; Field = "AssignedDate" }
                "DueDate" = @{ LabelCell = "A10"; ValueCell = "B10"; Label = "End Date"; Field = "DueDate" }
                "Manager" = @{ LabelCell = "A11"; ValueCell = "B11"; Label = "Project Manager"; Field = "Manager" }
                "Budget" = @{ LabelCell = "A12"; ValueCell = "B12"; Label = "Budget"; Field = "Budget" }
                "Status" = @{ LabelCell = "A13"; ValueCell = "B13"; Label = "Status"; Field = "Status" }
                "Priority" = @{ LabelCell = "A14"; ValueCell = "B14"; Label = "Priority"; Field = "Priority" }
                "Department" = @{ LabelCell = "A15"; ValueCell = "B15"; Label = "Department"; Field = "Department" }
                "Client" = @{ LabelCell = "A16"; ValueCell = "B16"; Label = "Client"; Field = "Client" }
                "BillingType" = @{ LabelCell = "A17"; ValueCell = "B17"; Label = "Billing Type"; Field = "BillingType" }
                "Rate" = @{ LabelCell = "A18"; ValueCell = "B18"; Label = "Hourly Rate"; Field = "Rate" }
            }
        }
        # UI Theme
        Theme = @{
            Header = "Cyan"; Success = "Green"; Warning = "Yellow"; Error = "Red"
            Info = "Blue"; Accent = "Magenta"; Subtle = "DarkGray"
        }
        CurrentTheme = "Cyberpunk" # Default advanced theme
        QuickActionTipShown = $false
        logFilePath = "" # Will be set by helper
        logMaxSizeMB = 10
    }
}
#endregion

#region Project Management

function global:Get-ProjectOrTemplate {
    param([string]$Key)
    if ([string]::IsNullOrEmpty($Key)) { return $null }
    if ($script:Data.Projects.ContainsKey($Key)) {
        return $script:Data.Projects[$Key]
    } elseif ($script:Data.Settings.TimeTrackerTemplates.ContainsKey($Key.ToUpper())) {
        return $script:Data.Settings.TimeTrackerTemplates[$Key.ToUpper()]
    }
    return $null
}

function global:Show-ProjectsAndTemplates {
    param([switch]$Simple)
    
    if ($Simple) {
        Write-Host "`nProjects:" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG"))
        if (-not $script:Data.Projects -or $script:Data.Projects.Count -eq 0) {
            Write-Host "  No projects defined." -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
        } else {
            foreach ($proj in $script:Data.Projects.GetEnumerator() | Sort-Object {$_.Value.Name}) {
                Write-Host "  [$($proj.Key)] $($proj.Value.Name)" -NoNewline
                if ($proj.Value.Client) { Write-Host " ($($proj.Value.Client))" -NoNewline }
                Write-Host
            }
        }
        Write-Host "`nTemplates:" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG"))
        if (-not $script:Data.Settings.TimeTrackerTemplates -or $script:Data.Settings.TimeTrackerTemplates.Count -eq 0) {
            Write-Host "  No templates defined." -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
        } else {
            foreach ($tmpl in $script:Data.Settings.TimeTrackerTemplates.GetEnumerator()) {
                Write-Host "  [$($tmpl.Key)] $($tmpl.Value.Name)"
            }
        }
    } else {
        $projectData = @()
        if ($script:Data.Projects -and $script:Data.Projects.Count -gt 0) {
            foreach ($proj in $script:Data.Projects.GetEnumerator() | Sort-Object {$_.Value.Name}) {
                Update-ProjectStatistics -ProjectKey $proj.Key
                $projectData += [PSCustomObject]@{
                    Key = $proj.Key
                    Name = $proj.Value.Name
                    Client = if ($proj.Value.Client) { $proj.Value.Client } else { "-" }
                    Status = $proj.Value.Status
                    Type = $proj.Value.BillingType
                    Hours = "$($proj.Value.TotalHours)h"
                    Tasks = "$($proj.Value.ActiveTasks)/$($proj.Value.CompletedTasks + $proj.Value.ActiveTasks)"
                    Budget = $proj.Value.Budget
                }
            }
        }
        
        if ($projectData.Count -gt 0) {
            $projectData | Format-TableUnicode -Columns @(
                @{Name="Key"; Title="Key"; Width=10}
                @{Name="Name"; Title="Project Name"; Width=25}
                @{Name="Client"; Title="Client"; Width=20}
                @{Name="Status"; Title="Status"; Width=10; AlignData="Center"}
                @{Name="Type"; Title="Billing"; Width=12}
                @{Name="Hours"; Title="Hours"; Width=8; AlignData="Right"}
                @{Name="Tasks"; Title="Tasks"; Width=10; AlignData="Center"}
            ) -Title "Projects" -BorderStyle "Double" -RowHighlightRules @{
                Overbudget = @{ Condition = { ($_.Hours -match '^(\d+\.?\d*)') -and ($_.Budget -gt 0) -and ([double]$Matches[1] -gt $_.Budget) }; FG = "Error" }
                Active = @{ Condition = { $_.Status -eq "Active" }; FG = "Success" }
                OnHold = @{ Condition = { $_.Status -eq "On Hold" }; FG = "Warning" }
            }
        } else {
            Write-Host "`n  No projects defined." -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
        }
        
        $templateData = @()
        if ($script:Data.Settings.TimeTrackerTemplates -and $script:Data.Settings.TimeTrackerTemplates.Count -gt 0) {
            foreach ($tmpl in $script:Data.Settings.TimeTrackerTemplates.GetEnumerator()) {
                $templateData += [PSCustomObject]@{
                    Key = $tmpl.Key
                    Name = $tmpl.Value.Name
                    Department = if ($tmpl.Value.Department) { $tmpl.Value.Department } else { "-" }
                    Type = "Template"
                    Notes = if ($tmpl.Value.Notes) { ($tmpl.Value.Notes.Substring(0, [Math]::Min(30, $tmpl.Value.Notes.Length))) + "..." } else { "-" }
                }
            }
        }
        
        if ($templateData.Count -gt 0) {
            Write-Host ""
            $templateData | Format-TableUnicode -Columns @(
                @{Name="Key"; Title="Key"; Width=10}
                @{Name="Name"; Title="Template Name"; Width=25}
                @{Name="Department"; Title="Department"; Width=20}
                @{Name="Type"; Title="Type"; Width=10; AlignData="Center"}
                @{Name="Notes"; Title="Notes"; Width=35}
            ) -Title "Time Tracking Templates" -BorderStyle "Single"
        } else {
            Write-Host "`n  No templates defined." -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
        }
    }
}

function global:Show-ProjectDetail {
    Write-Header "Project Details"
    
    $projectKey = Select-ProjectOrTemplate -Title "Select Project/Template for Details"
    if (-not $projectKey) { 
        Write-Info "Selection cancelled."
        return 
    }
    
    $project = Get-ProjectOrTemplate $projectKey
    if ($project) {
        Clear-Host
        Write-Header "Details for: $($project.Name) (Key: $projectKey)"
        if ($script:Data.Projects.ContainsKey($projectKey)) {
            Update-ProjectStatistics -ProjectKey $projectKey
            $project = $script:Data.Projects[$projectKey]
        }
        $properties = $project.PSObject.Properties | Select-Object Name, Value | Where-Object { $_.Name -notin @("PSParentPath", "PSChildName") }
        foreach ($prop in $properties) {
            if ($prop.Name -eq "Notes" -and [string]::IsNullOrEmpty($prop.Value)) { continue }
            Write-Host "  $($prop.Name.PadRight(18)): $($prop.Value)"
        }
        if ($project.BillingType -eq "Billable" -and $project.Budget -gt 0) {
            Write-Host "`nBudget Status:" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG"))
            $percentUsed = ($project.TotalHours / $project.Budget) * 100
            Write-Host "  Budget: $($project.Budget) hours, Used: $($project.TotalHours) hours ($([Math]::Round($percentUsed, 1))% used)"
        }
        Write-Host "`nPress any key to continue..."
        $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
    } else {
        Write-Error "Project or Template '$projectKey' not found."
    }
}

function global:Import-ProjectFromExcel {
    Write-Header "Import Project from Excel Form"
    Write-Warning "Excel import feature is not yet fully implemented in this version."
    $selectedFile = Start-TerminalFileBrowser -SelectFileMode
    if (-not $selectedFile) {
        Write-Info "File selection cancelled."
        return
    }
    Write-Info "Selected file: $selectedFile. (Implementation pending)."
    Write-Host "`nPress any key to continue..."
    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
}

function global:Configure-ExcelForm {
    Write-Header "Configure Excel Form Import Mapping"
    Write-Warning "Excel configuration for import mapping is not yet fully implemented."
    Write-Info "This feature is under development."
    Write-Host "`nPress any key to continue..."
    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
}

function global:Add-Project {
    Write-Header "Add New Project"
    $projectKeyInput = Read-Host "Project Key (short identifier)"
    if ([string]::IsNullOrEmpty($projectKeyInput)) { Write-Error "Project key cannot be empty."; return }
    if ($script:Data.Projects.ContainsKey($projectKeyInput) -or $script:Data.Settings.TimeTrackerTemplates.ContainsKey($projectKeyInput.ToUpper())) {
        Write-Error "Project key '$projectKeyInput' already exists as a project or template."
        return
    }
    Write-Host "`nBasic Information:" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG"))
    $projectName = Read-Host "Project Name"
    if ([string]::IsNullOrEmpty($projectName)) { Write-Error "Project name cannot be empty."; return }
    $id1 = Read-Host "ID1 (custom identifier, optional)"
    $id2 = Read-Host "ID2 (max 9 chars, optional)"
    Write-Host "`nClient & Department:" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG"))
    $client = Read-Host "Client Name (optional)"
    $department = Read-Host "Department (optional)"
    Write-Host "`nBilling Information:" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG"))
    Write-Host "Billing Type: [B]illable, [N]on-Billable, [F]ixed Price (default: Non-Billable)"
    $billingChoice = Read-Host "Choice (B/N/F)"
    $billingType = switch ($billingChoice.ToUpper()) { "B" { "Billable" } "F" { "Fixed Price" } default { "Non-Billable" } }
    $rate = 0.0
    $budget = 0.0
    if ($billingType -ne "Non-Billable") {
        $rateInput = Read-Host "Hourly Rate (default: $($script:Data.Settings.DefaultRate))"
        if (-not [string]::IsNullOrWhiteSpace($rateInput)) {
            try { $rate = [double]$rateInput } catch { Write-Warning "Invalid rate format, using 0.0."; $rate = 0.0 }
        } else { $rate = $script:Data.Settings.DefaultRate }
        $budgetInput = Read-Host "Budget Hours (0 for unlimited, optional)"
        if (-not [string]::IsNullOrWhiteSpace($budgetInput)) {
            try { $budget = [double]$budgetInput } catch { Write-Warning "Invalid budget format, using 0.0."; $budget = 0.0 }
        }
    }
    Write-Host "`nProject Status:" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG"))
    Write-Host "[A]ctive, [O]n Hold, [C]ompleted (default: Active)"
    $statusChoice = Read-Host "Status (A/O/C)"
    $status = switch ($statusChoice.ToUpper()) { "O" { "On Hold" } "C" { "Completed" } default { "Active" } }
    $notes = Read-Host "`nProject Notes (optional)"
    $startDate = (Get-Date).ToString("yyyy-MM-dd")
    $script:Data.Projects[$projectKeyInput] = @{
        Name = $projectName; Id1 = $id1; Id2 = $id2; Client = $client; Department = $department
        BillingType = $billingType; Rate = $rate; Budget = $budget; Status = $status; Notes = $notes
        StartDate = $startDate; TotalHours = 0.0; TotalBilled = 0.0; CompletedTasks = 0; ActiveTasks = 0
        Manager = ""; Priority = "Medium"; DueDate = $null; CreatedDate = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
    }
    Save-UnifiedData
    Write-Success "Project added: $projectKeyInput - $projectName"
}

function global:Edit-Project {
    Show-ProjectsAndTemplates -Simple
    Write-Host ""
    $projectKeyToEdit = Read-Host "Enter project key to edit"
    if([string]::IsNullOrWhiteSpace($projectKeyToEdit)) { Write-Info "Edit cancelled."; return }
    if (-not $script:Data.Projects.ContainsKey($projectKeyToEdit)) {
        Write-Error "Project '$projectKeyToEdit' not found or cannot edit templates this way."
        return
    }
    $project = $script:Data.Projects[$projectKeyToEdit]
    Write-Header "Edit Project: $projectKeyToEdit ($($project.Name))"
    Write-Host "Leave field empty to keep current value." -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
    $fieldPrompts = @(
        @{Prop="Name"; Prompt="New Name"; Current=$project.Name}
        @{Prop="Client"; Prompt="New Client"; Current=$project.Client}
        @{Prop="Department"; Prompt="New Department"; Current=$project.Department}
        @{Prop="Id1"; Prompt="New ID1"; Current=$project.Id1}
        @{Prop="Id2"; Prompt="New ID2 (max 9 chars)"; Current=$project.Id2}
        @{Prop="Status"; Prompt="New Status ([A]ctive, [O]n Hold, [C]ompleted)"; Current=$project.Status; Type="Status"}
        @{Prop="BillingType"; Prompt="New Billing Type ([B]illable, [N]on-Billable, [F]ixed Price)"; Current=$project.BillingType; Type="BillingType"}
        @{Prop="Rate"; Prompt="New Rate"; Current=$project.Rate; Type="Double"; Condition={$project.BillingType -ne "Non-Billable"}}
        @{Prop="Budget"; Prompt="New Budget Hours"; Current=$project.Budget; Type="Double"; Condition={$project.BillingType -ne "Non-Billable"}}
        @{Prop="Notes"; Prompt="New Notes (enter 'clear' to empty)"; Current=$project.Notes; Type="StringAllowClear"}
        @{Prop="StartDate"; Prompt="New Start Date (YYYY-MM-DD)"; Current=$project.StartDate; Type="Date"}
        @{Prop="DueDate"; Prompt="New Due Date (YYYY-MM-DD, or 'clear')"; Current=$project.DueDate; Type="DateAllowClear"}
        @{Prop="Manager"; Prompt="New Project Manager"; Current=$project.Manager}
        @{Prop="Priority"; Prompt="New Project Priority ([C]ritical, [H]igh, [M]edium, [L]ow)"; Current=$project.Priority; Type="ProjectPriority"}
    )
    $changesMade = $false
    foreach($field in $fieldPrompts) {
        if ($field.Condition -and -not (& $field.Condition)) { continue }
        Write-Host "`nCurrent $($field.Prop): $($field.Current)" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
        $newValue = Read-Host $field.Prompt
        if (-not [string]::IsNullOrWhiteSpace($newValue)) {
            $validUpdate = $true; $oldFieldValue = $project.($field.Prop)
            switch ($field.Type) {
                "Double" { try { $project.($field.Prop) = [double]$newValue } catch { Write-Warning "Invalid number for $($field.Prop). Not changed."; $validUpdate = $false } }
                "Status" { $project.($field.Prop) = switch ($newValue.ToUpper()) { "A" { "Active" } "O" { "On Hold" } "C" { "Completed" } default { $project.($field.Prop) } }; if ($project.($field.Prop) -eq $field.Current -and $newValue.ToUpper() -notin @("A","O","C")) {$validUpdate = $false; Write-Warning "Invalid status. Not changed."} }
                "BillingType" { $project.($field.Prop) = switch ($newValue.ToUpper()) { "B" { "Billable" } "N" { "Non-Billable" } "F" { "Fixed Price"} default { $project.($field.Prop) } }; if ($project.($field.($field.Prop)) -eq $field.Current -and $newValue.ToUpper() -notin @("B","N","F")) {$validUpdate = $false; Write-Warning "Invalid billing type. Not changed."} }
                "Date" { try { $project.($field.Prop) = ([datetime]::Parse($newValue)).ToString("yyyy-MM-dd") } catch { Write-Warning "Invalid date for $($field.Prop). Not changed."; $validUpdate = $false } }
                "DateAllowClear" { if ($newValue.ToLower() -eq 'clear') { $project.($field.Prop) = $null } else { try { $project.($field.Prop) = ([datetime]::Parse($newValue)).ToString("yyyy-MM-dd") } catch { Write-Warning "Invalid date for $($field.Prop). Not changed."; $validUpdate = $false } } }
                "StringAllowClear" { if ($newValue.ToLower() -eq 'clear') { $project.($field.Prop) = "" } else { $project.($field.Prop) = $newValue } }
                "ProjectPriority" { $project.($field.Prop) = switch ($newValue.ToUpper()) { "C" { "Critical" } "H" { "High" } "M" { "Medium" } "L" { "Low" } default { $project.($field.Prop) } }; if ($project.($field.Prop) -eq $field.Current -and $newValue.ToUpper() -notin @("C","H","M","L")) {$validUpdate = $false; Write-Warning "Invalid priority. Not changed."} }
                default { $project.($field.Prop) = $newValue }
            }
            if ($validUpdate -and $project.($field.Prop) -ne $oldFieldValue) { $changesMade = $true }
        }
    }
    if ($changesMade) { Save-UnifiedData; Write-Success "Project '$projectKeyToEdit' updated!" } else { Write-Info "No changes made to project '$projectKeyToEdit'." }
}

function global:Update-ProjectStatistics {
    param([string]$ProjectKey)
    if (-not $script:Data.Projects.ContainsKey($ProjectKey)) { return }
    $project = $script:Data.Projects[$ProjectKey]
    $projectEntries = $script:Data.TimeEntries | Where-Object { $_.ProjectKey -eq $ProjectKey }
    $project.TotalHours = [Math]::Round(($projectEntries | Measure-Object -Property Hours -Sum).Sum, 2)
    $projectTasks = $script:Data.Tasks | Where-Object { $_.ProjectKey -eq $ProjectKey -and ($_.IsCommand -ne $true) }
    $project.CompletedTasks = ($projectTasks | Where-Object { $_.Completed }).Count
    $project.ActiveTasks = ($projectTasks | Where-Object { -not $_.Completed }).Count
}

function global:Export-Projects {
    Write-Header "Export Projects"
    if (-not $script:Data.Projects -or $script:Data.Projects.Count -eq 0) { Write-Warning "No projects to export."; return }
    $exportData = @()
    foreach ($projEnum in $script:Data.Projects.GetEnumerator()) {
        $projValue = $projEnum.Value
        $exportData += [PSCustomObject]@{
            Key = $projEnum.Key; Name = $projValue.Name; Id1 = $projValue.Id1; Id2 = $projValue.Id2
            Client = $projValue.Client; Department = $projValue.Department; Status = $projValue.Status
            BillingType = $projValue.BillingType; Rate = $projValue.Rate; Budget = $projValue.Budget
            TotalHours = $projValue.TotalHours; ActiveTasks = $projValue.ActiveTasks; CompletedTasks = $projValue.CompletedTasks
            StartDate = $projValue.StartDate; DueDate = $projValue.DueDate; Manager = $projValue.Manager
            ProjectPriority = $projValue.Priority; Notes = $projValue.Notes; CreatedDate = $projValue.CreatedDate
        }
    }
    $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
    $exportFile = Join-Path ([Environment]::GetFolderPath("Desktop")) "Projects_Export_$timestamp.csv"
    try {
        $exportData | Export-Csv $exportFile -NoTypeInformation -Encoding UTF8
        Write-Success "Projects exported to: $exportFile"
        if ((Read-Host "Open file now? (Y/N)").ToUpper() -eq 'Y') { Start-Process $exportFile }
    } catch { Write-Error "Failed to export projects: $_" }
}

function global:Batch-ImportProjects {
    Write-Warning "Batch Import Projects feature not yet implemented."
    $selectedFile = Start-TerminalFileBrowser -SelectFileMode
    if (-not $selectedFile) {
        Write-Info "File selection cancelled."
        return
    }
    Write-Info "Selected file for batch import: $selectedFile. (Implementation pending)."
}

function global:Show-ProjectSummary {
    Write-Header "Project Summary Report"
    if (-not $script:Data.Projects -or $script:Data.Projects.Count -eq 0) { Write-Warning "No projects available to summarize."; return }
    $projectSummaryData = @()
    foreach ($key in ($script:Data.Projects.Keys | Sort-Object)) {
        Update-ProjectStatistics -ProjectKey $key
        $p = $script:Data.Projects[$key]
        $projectSummaryData += [PSCustomObject]@{
            Key = $key; Name = $p.Name; Client = $p.Client; Status = $p.Status; Budget = $p.Budget; TotalHours = $p.TotalHours
            RemainingHours = if ($p.Budget -gt 0) { [Math]::Round($p.Budget - $p.TotalHours, 2) } else { "N/A" }
            Progress = if ($p.Budget -gt 0 -and $p.TotalHours -ge 0) {
                           if ($p.TotalHours -eq 0 -and $p.Budget -gt 0) { "0%" }
                           elseif ($p.TotalHours -gt 0) { "$([Math]::Round(($p.TotalHours / $p.Budget) * 100, 1))%" }
                           else { "N/A" }
                       } else { "N/A" }
            ActiveTasks = $p.ActiveTasks
        }
    }
    $projectSummaryData | Format-TableUnicode -Columns @(
        @{Name="Key"; Title="Key"; Width=10}, @{Name="Name"; Title="Project Name"; Width=25}
        @{Name="Client"; Title="Client"; Width=15}, @{Name="Status"; Title="Status"; Width=12}
        @{Name="Budget"; Title="Budget (h)"; Width=10; Align="Right"}, @{Name="TotalHours"; Title="Used (h)"; Width=10; Align="Right"}
        @{Name="RemainingHours"; Title="Rem (h)"; Width=10; Align="Right"}, @{Name="Progress"; Title="Progress %"; Width=12; Align="Right"}
        @{Name="ActiveTasks"; Title="Active Tasks"; Width=12; Align="Right"}
    ) -Title "Project Summary" -BorderStyle "Rounded"
}

#endregion

#region Command Snippets System

function global:Add-CommandSnippet {
    Write-Header "Add Command Snippet"
    $snippetName = Read-Host "Command name/description"
    if ([string]::IsNullOrEmpty($snippetName)) { Write-Error "Command name cannot be empty!"; return }
    
    Write-Host "`nEnter command content (press Esc when finished):" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
    $commandText = Read-MultilineText
    
    if ([string]::IsNullOrWhiteSpace($commandText)) { Write-Error "Command cannot be empty!"; return }
    
    $existingCategories = $script:Data.Tasks | Where-Object { $_.IsCommand -eq $true -and (-not [string]::IsNullOrEmpty($_.Category)) } | Select-Object -ExpandProperty Category -Unique | Sort-Object
    if ($existingCategories) { Write-Host "`nExisting categories: $($existingCategories -join ', ')" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.AccentFG")) }
    $category = Read-Host "Category (default: $($script:Data.Settings.CommandSnippets.DefaultCategory))"
    if ([string]::IsNullOrEmpty($category)) { $category = $script:Data.Settings.CommandSnippets.DefaultCategory }
    Write-Host "`nTags (comma-separated, optional):" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
    $tagsInput = Read-Host "Tags"
    $tags = if (-not [string]::IsNullOrWhiteSpace($tagsInput)) { $tagsInput -split ',' | ForEach-Object { $_.Trim() } | Where-Object { -not [string]::IsNullOrWhiteSpace($_) } } else { @() }
    $hotkey = ""
    if ($script:Data.Settings.CommandSnippets.EnableHotkeys) {
        Write-Host "`nAssign hotkey (optional, e.g., 'ctrl+1'):" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
        $hotkey = Read-Host "Hotkey"
    }
    $snippet = @{
        Id = New-TodoId; Description = $snippetName; Priority = "Low"; Category = $category; ProjectKey = $null
        StartDate = $null; DueDate = $null; Tags = $tags; Progress = 0; Completed = $false
        CreatedDate = [datetime]::Now.ToString("yyyy-MM-dd HH:mm:ss"); CompletedDate = $null; EstimatedTime = 0
        TimeSpent = 0; Subtasks = @(); Notes = $commandText; LastModified = [datetime]::Now.ToString("yyyy-MM-dd HH:mm:ss")
        IsCommand = $true; Hotkey = $hotkey; LastUsed = $null; UseCount = 0
    }
    $script:Data.Tasks += $snippet
    Save-UnifiedData
    Write-Success "Command snippet added: $snippetName"
    if ($script:Data.Settings.CommandSnippets.AutoCopyToClipboard) { if (Copy-ToClipboard $commandText) { Write-Info "Command copied to clipboard!" } }
}

function global:Get-CommandSnippet {
    param([string]$Id, [string]$SearchTerm, [string]$CategoryFilter, [string[]]$TagsFilter)
    $snippets = $script:Data.Tasks | Where-Object { $_.IsCommand -eq $true }
    if ($Id) { return $snippets | Where-Object { $_.Id -like "$Id*" } | Select-Object -First 1 }
    if ($SearchTerm) { $snippets = $snippets | Where-Object { $_.Description -like "*$SearchTerm*" -or $_.Notes -like "*$SearchTerm*" -or ($_.Tags -and ($_.Tags -join " ") -like "*$SearchTerm*") } }
    if ($CategoryFilter) { $snippets = $snippets | Where-Object { $_.Category -eq $CategoryFilter } }
    if ($TagsFilter -and $TagsFilter.Count -gt 0) { $snippets = $snippets | Where-Object { $snippetTags = $_.Tags; if (-not $snippetTags) { return $false } $foundAll = $true; foreach ($tagToFind in $TagsFilter) { if ($tagToFind -notin $snippetTags) { $foundAll = $false; break } } $foundAll } }
    return $snippets
}

function global:Search-CommandSnippets {
    Write-Header "Search Command Snippets"
    $searchTerm = Read-Host "Search term (name, content, tags; leave empty for all)"
    $categoryFilter = Read-Host "Filter by category (optional, exact match)"
    $tagsInput = Read-Host "Filter by tags (comma-separated, AND logic; optional)"
    $tagsFilter = if (-not [string]::IsNullOrWhiteSpace($tagsInput)) { $tagsInput -split ',' | ForEach-Object {$_.Trim()} | Where-Object { -not [string]::IsNullOrWhiteSpace($_)} } else { $null }
    $unsortedSnippets = Get-CommandSnippet -SearchTerm $searchTerm -CategoryFilter $categoryFilter -TagsFilter $tagsFilter
    $snippets = $unsortedSnippets | Sort-Object @{Expression="UseCount"; Descending=$true}, @{Expression="Description"; Descending=$false}
    if ($snippets.Count -eq 0) { Write-Host "No snippets found matching your criteria." -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")); return }
    $tableData = $snippets | ForEach-Object { [PSCustomObject]@{ ID = $_.Id.Substring(0, 6); Name = $_.Description; Category = $_.Category; Tags = if ($_.Tags) { ($_.Tags -join ", ") } else { "" }; Used = $_.UseCount; Hotkey = if ($_.Hotkey) { $_.Hotkey } else { "-" } } }
    $tableData | Format-TableUnicode -Columns @( @{Name="ID"; Title="ID"; Width=8}, @{Name="Name"; Title="Name"; Width=30}, @{Name="Category"; Title="Category"; Width=15}, @{Name="Tags"; Title="Tags"; Width=20}, @{Name="Used"; Title="Used"; Width=6; Align="Right"}, @{Name="Hotkey"; Title="Hotkey"; Width=10} ) -Title "Command Snippets"
    Write-Host "`nEnter snippet ID to copy/execute, or press Enter to cancel."
    $selectedId = Read-Host
    if (-not [string]::IsNullOrWhiteSpace($selectedId)) { Execute-CommandSnippet -Id $selectedId }
}

function global:Execute-CommandSnippet {
    param([string]$Id)
    $snippet = Get-CommandSnippet -Id $Id
    if (-not $snippet) { Write-Error "Snippet with ID starting '$Id' not found!"; return }
    Write-Host "`nCommand: $($snippet.Description)" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.AccentFG"))
    Write-Host "Category: $($snippet.Category)" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
    if ($snippet.Tags -and $snippet.Tags.Count -gt 0) { Write-Host "Tags: $($snippet.Tags -join ', ')" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")) }
    Write-Host "`nCommand content:" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG"))
    Write-Host $snippet.Notes -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.PrimaryFG"))
    $snippet.LastUsed = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
    $snippet.UseCount = [int]$snippet.UseCount + 1
    Save-UnifiedData
    Write-Host "`n[C]opy to clipboard, [E]xecute (PowerShell), [B]oth, or [Enter] to cancel"
    $actionChoice = Read-Host
    switch ($actionChoice.ToUpper()) {
        "C" { if (Copy-ToClipboard $snippet.Notes) { Write-Success "Command copied to clipboard!" } }
        "E" { Write-Warning "Are you sure you want to execute this command?"; $confirmExecution = Read-Host "Type 'yes' to confirm"; if ($confirmExecution -eq 'yes') { try { Invoke-Expression $snippet.Notes; Write-Success "Command executed!" } catch { Write-Error "Execution failed: $_" } } else { Write-Info "Execution cancelled."} }
        "B" { if (Copy-ToClipboard $snippet.Notes) { Write-Success "Command copied!" }; Write-Warning "Are you sure you want to execute?"; $confirmExecuteBoth = Read-Host "Type 'yes' to confirm"; if ($confirmExecuteBoth -eq 'yes') { try { Invoke-Expression $snippet.Notes; Write-Success "Command executed!" } catch { Write-Error "Execution failed: $_" } } else { Write-Info "Execution cancelled."} }
        default { Write-Info "Action cancelled."}
    }
}

function global:Remove-CommandSnippet {
    param([string]$IdInput)
    $idToRemove = $IdInput
    if (-not $idToRemove) { Search-CommandSnippets; $idToRemove = Read-Host "`nEnter snippet ID to delete, or Enter to cancel"; if ([string]::IsNullOrWhiteSpace($idToRemove)) { Write-Info "Deletion cancelled."; return } }
    $snippet = Get-CommandSnippet -Id $idToRemove
    if (-not $snippet) { Write-Error "Snippet with ID starting '$idToRemove' not found!"; return }
    Write-Warning "Delete snippet: '$($snippet.Description)' (ID: $($snippet.Id.Substring(0,6)))?"
    if ((Read-Host "Type 'yes' to confirm") -eq 'yes') {
        $script:Data.Tasks = $script:Data.Tasks | Where-Object { $_.Id -ne $snippet.Id }
        Save-UnifiedData
        Write-Success "Snippet deleted!"
    } else { Write-Info "Deletion cancelled."}
}

function global:Manage-CommandSnippets {
    while ($true) {
        Write-Header "Command Snippets"
        $snippetCount = ($script:Data.Tasks | Where-Object { $_.IsCommand -eq $true }).Count
        Write-Host "Total snippets: $snippetCount" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
        $recentSnippets = Get-RecentCommandSnippets -Count 5
        if ($recentSnippets.Count -gt 0) {
            Write-Host "`nRecent snippets:" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG"))
            foreach ($snippet in $recentSnippets) {
                Write-Host "  [$($snippet.Id.Substring(0,6))] $($snippet.Description)" -NoNewline
                if ($snippet.Hotkey) { Write-Host " ($($snippet.Hotkey))" -NoNewline -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.AccentFG")) }
                Write-Host " - Used: $($snippet.UseCount)" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
            }
        }
        Write-Host "`n[A]dd snippet"; Write-Host "[S]earch/Browse snippets"; Write-Host "[E]xecute by ID"
        Write-Host "[D]elete by ID"; Write-Host "[L]ist Categories"; Write-Host "List [H]otkeys"; Write-Host "[B]ack to Tools Menu"
        $choice = Read-Host "`nChoice"
        $actionTaken = $true
        switch ($choice.ToLower()) {
            "a" { Add-CommandSnippet }
            "s" { Search-CommandSnippets }
            "e" { $idToExecute = Read-Host "Snippet ID to execute"; if (-not [string]::IsNullOrWhiteSpace($idToExecute)) { Execute-CommandSnippet -Id $idToExecute } else { $actionTaken = $false } }
            "d" { $idToDelete = Read-Host "Snippet ID to delete"; if (-not [string]::IsNullOrWhiteSpace($idToDelete)) { Remove-CommandSnippet -IdInput $idToDelete } else { $actionTaken = $false } }
            "l" { Show-SnippetCategories }
            "h" { Show-SnippetHotkeys }
            "b" { return }
            default { if (-not [string]::IsNullOrEmpty($choice)) { Write-Warning "Unknown command." }; $actionTaken = $false }
        }
        if ($actionTaken) { Write-Host "`nPress Enter to continue..."; Read-Host }
    }
}

function global:Get-RecentCommandSnippets {
    param([int]$Count = 10)
    $snippets = $script:Data.Tasks | Where-Object { $_.IsCommand -eq $true }
    $sortedSnippets = $snippets | Sort-Object @{Expression = { $_.UseCount }; Descending = $true}, @{Expression = { if ($_.LastUsed) { try {[DateTime]::Parse($_.LastUsed)} catch {[DateTime]::MinValue} } else { [DateTime]::MinValue } }; Descending = $true}, Description
    return $sortedSnippets | Select-Object -First $Count
}

function global:Show-SnippetCategories {
    Write-Header "Snippet Categories"
    $snippets = $script:Data.Tasks | Where-Object { $_.IsCommand -eq $true }
    if ($snippets.Count -eq 0) { Write-Host "No snippets found to categorize." -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")); return }
    $categories = $snippets | Group-Object Category | Sort-Object Count -Descending
    if ($categories.Count -eq 0) { Write-Host "No categories assigned to snippets." -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")); return }
    Write-Host "Category usage:" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG"))
    foreach ($catGroup in $categories) {
        $categoryName = if ([string]::IsNullOrEmpty($catGroup.Name)) {"[Uncategorized]"} else {$catGroup.Name}
        Write-Host "  $categoryName $($catGroup.Count) snippet(s)"
        $topInCategory = $catGroup.Group | Sort-Object UseCount -Descending | Sort-Object Description | Select-Object -First 3
        foreach ($snippet in $topInCategory) { Write-Host "    - $($snippet.Description) (Used: $($snippet.UseCount))" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")) }
    }
}

function global:Show-SnippetHotkeys {
    Write-Header "Snippet Hotkeys"
    $snippetsWithHotkeys = $script:Data.Tasks | Where-Object { $_.IsCommand -eq $true -and (-not [string]::IsNullOrEmpty($_.Hotkey)) }
    if ($snippetsWithHotkeys.Count -eq 0) { Write-Host "No hotkeys assigned to any snippets." -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")); return }
    Write-Host "Assigned hotkeys:" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG"))
    foreach ($snippet in $snippetsWithHotkeys | Sort-Object Hotkey) { Write-Host "  $($snippet.Hotkey): $($snippet.Description) (ID: $($snippet.Id.Substring(0,6)))" }
    Write-Warning "`nNote: Actual hotkey binding requires an external keyboard hook implementation."
}

function global:Edit-CommandSnippetSettings {
    Write-Header "Command Snippet Settings"
    if (-not $script:Data.Settings.CommandSnippets) { $script:Data.Settings.CommandSnippets = (Get-DefaultSettings).CommandSnippets }
    $csSettings = $script:Data.Settings.CommandSnippets
    Write-Host "Current settings:" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG"))
    Write-Host "  Enable Hotkeys:       $(if ($csSettings.EnableHotkeys) { 'Yes' } else { 'No' }) (Note: actual binding is external)"
    Write-Host "  Auto-Copy on Add:     $(if ($csSettings.AutoCopyToClipboard) { 'Yes' } else { 'No' })"
    Write-Host "  Show in Task List:   $(if ($csSettings.ShowInTaskList) { 'Yes' } else { 'No' })"
    Write-Host "  Default Category:    $($csSettings.DefaultCategory)"
    Write-Host "  Recent Snippets Limit: $($csSettings.RecentLimit)"
    Write-Host "`nLeave empty to keep current value." -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
    $enableHotkeysInput = Read-Host "`nEnable hotkeys? (Y/N)"; if (-not [string]::IsNullOrWhiteSpace($enableHotkeysInput)) { $csSettings.EnableHotkeys = ($enableHotkeysInput.ToUpper() -eq 'Y') }
    $autoCopyInput = Read-Host "`nAuto-copy to clipboard when adding a new snippet? (Y/N)"; if (-not [string]::IsNullOrWhiteSpace($autoCopyInput)) { $csSettings.AutoCopyToClipboard = ($autoCopyInput.ToUpper() -eq 'Y') }
    $showInTasksInput = Read-Host "`nShow command snippets in the main task list views? (Y/N)"; if (-not [string]::IsNullOrWhiteSpace($showInTasksInput)) { $csSettings.ShowInTaskList = ($showInTasksInput.ToUpper() -eq 'Y') }
    $newDefaultCategory = Read-Host "`nDefault category for new snippets (current: $($csSettings.DefaultCategory))"; if (-not [string]::IsNullOrWhiteSpace($newDefaultCategory)) { $csSettings.DefaultCategory = $newDefaultCategory }
    $newRecentLimitStr = Read-Host "`nNumber of recent snippets to show (current: $($csSettings.RecentLimit))"
    if (-not [string]::IsNullOrWhiteSpace($newRecentLimitStr)) { try { $limit = [int]$newRecentLimitStr; if ($limit -ge 0) { $csSettings.RecentLimit = $limit } else { Write-Warning "Limit must be non-negative."} } catch { Write-Warning "Invalid number format for limit." } }
    Save-UnifiedData
    Write-Success "Command Snippet settings updated!"
}

#endregion

#region Task Management Functions

function global:Add-TodoTask {
    Write-Header "Add New Task"
    $description = Read-Host "`nTask description"
    if ([string]::IsNullOrEmpty($description)) { Write-Error "Task description cannot be empty!"; return }
    Write-Host "`nPriority: [C]ritical, [H]igh, [M]edium, [L]ow (default: $($script:Data.Settings.DefaultPriority))" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
    $priorityInput = Read-Host "Priority"
    $priority = switch ($priorityInput.ToUpper()) { "C" { "Critical" } "H" { "High" } "L" { "Low" } "M" { "Medium" } default { $script:Data.Settings.DefaultPriority } }
    $existingCategories = $script:Data.Tasks | Where-Object { ($_.IsCommand -ne $true) -and (-not [string]::IsNullOrEmpty($_.Category)) } | Select-Object -ExpandProperty Category -Unique | Sort-Object
    if ($existingCategories) { Write-Host "`nExisting categories: $($existingCategories -join ', ')" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.AccentFG")) }
    $category = Read-Host "Category (default: $($script:Data.Settings.DefaultCategory))"
    if ([string]::IsNullOrEmpty($category)) { $category = $script:Data.Settings.DefaultCategory }
    Write-Host "`nLink to project? (Y/N)"
    $linkProjectChoice = Read-Host
    $projectKey = $null
    if ($linkProjectChoice.ToUpper() -eq 'Y') {
        Show-ProjectsAndTemplates -Simple
        $projectKeyInput = Read-Host "`nProject key (leave empty if none)"
        if (-not [string]::IsNullOrWhiteSpace($projectKeyInput)) { if (Get-ProjectOrTemplate $projectKeyInput) { $projectKey = $projectKeyInput } else { Write-Warning "Project '$projectKeyInput' not found." } }
    }
    Write-Host "`nStart date (optional): Enter date (YYYY-MM-DD), 'today', 'tomorrow', or '+X' for X days from now" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
    $startDateInput = Read-Host "Start date"
    $startDate = $null
    if (-not [string]::IsNullOrWhiteSpace($startDateInput)) { try { $parsedDate = switch -Regex ($startDateInput.ToLower()) { '^today$' { [datetime]::Today } '^tomorrow$' { [datetime]::Today.AddDays(1) } '^\+(\d+)$' { [datetime]::Today.AddDays([int]$Matches[1]) } default { [datetime]::Parse($startDateInput) } }; $startDate = $parsedDate.ToString("yyyy-MM-dd") } catch { Write-Warning "Invalid start date format." } }
    Write-Host "`nDue date (optional): Enter date (YYYY-MM-DD), 'today', 'tomorrow', or '+X' for X days from now" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
    $dueDateInput = Read-Host "Due date"
    $dueDate = $null
    if (-not [string]::IsNullOrWhiteSpace($dueDateInput)) { try { $parsedDueDate = switch -Regex ($dueDateInput.ToLower()) { '^today$' { [datetime]::Today } '^tomorrow$' { [datetime]::Today.AddDays(1) } '^\+(\d+)$' { [datetime]::Today.AddDays([int]$Matches[1]) } default { [datetime]::Parse($dueDateInput) } }; $dueDate = $parsedDueDate.ToString("yyyy-MM-dd") } catch { Write-Warning "Invalid due date format." } }
    Write-Host "`nTags (comma-separated, optional):" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
    $tagsInput = Read-Host "Tags"
    $tags = if (-not [string]::IsNullOrWhiteSpace($tagsInput)) { $tagsInput -split ',' | ForEach-Object { $_.Trim() } | Where-Object { -not [string]::IsNullOrWhiteSpace($_) } } else { @() }
    $estimatedTimeInput = Read-Host "`nEstimated time in hours (optional, e.g., 2.5)"
    $estimatedTime = 0.0
    if (-not [string]::IsNullOrWhiteSpace($estimatedTimeInput)) { try { $estimatedTime = [double]$estimatedTimeInput } catch { Write-Warning "Invalid estimate format." } }
    $subtasks = @()
    Write-Host "`nAdd subtasks? (Y/N)" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
    $addSubtasksChoice = Read-Host
    if ($addSubtasksChoice.ToUpper() -eq 'Y') {
        Write-Host "Enter subtasks (empty line to finish):" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
        while ($true) { $subtaskDesc = Read-Host "  Subtask"; if ([string]::IsNullOrEmpty($subtaskDesc)) { break }; $subtasks += @{ Description = $subtaskDesc; Completed = $false; CompletedDate = $null } }
    }
    $newTask = @{
        Id = New-TodoId; Description = $description; Priority = $priority; Category = $category; ProjectKey = $projectKey
        StartDate = $startDate; DueDate = $dueDate; Tags = $tags; Progress = 0; Completed = $false
        CreatedDate = [datetime]::Now.ToString("yyyy-MM-dd HH:mm:ss"); CompletedDate = $null; EstimatedTime = $estimatedTime
        TimeSpent = 0.0; Subtasks = $subtasks; Notes = ""; LastModified = [datetime]::Now.ToString("yyyy-MM-dd HH:mm:ss"); IsCommand = $false
    }
    $script:Data.Tasks += $newTask
    if ($projectKey) { Update-ProjectStatistics -ProjectKey $projectKey }
    Save-UnifiedData
    Write-Success "Task added successfully!"; Write-Host "ID: $($newTask.Id)" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
    if ($script:Data.Settings.EnableTimeTracking -and $projectKey) { if ((Read-Host "`nStart timer for this task? (Y/N)").ToUpper() -eq 'Y') { Start-Timer -ProjectKeyParam $projectKey -TaskIdParam $newTask.Id } }
}

function global:Quick-AddTask {
    param([string]$InputString)
    if (-not $InputString) { $InputString = Read-Host "Quick add task (e.g., 'My new task #work @urgent !High due:tomorrow project:PROJ1 est:2.5')"; if([string]::IsNullOrWhiteSpace($InputString)) { Write-Info "Quick add cancelled."; return } }
    $description = $InputString; $category = $script:Data.Settings.DefaultCategory; $tags = @(); $priority = $script:Data.Settings.DefaultPriority; $dueDate = $null; $startDate = $null; $projectKey = $null; $estimatedTime = 0.0
    if ($description -match '#(\S+)') { $category = $Matches[1]; $description = $description -replace ('#' + [regex]::Escape($Matches[1])), '' }
    $tagMatches = [regex]::Matches($description, '@(\S+)'); foreach ($match in $tagMatches) { $tags += $match.Groups[1].Value; $description = $description -replace ('@' + [regex]::Escape($match.Groups[1].Value)), '' }
    if ($description -match '!(critical|high|medium|low|c|h|m|l)\b') { $priority = switch ($Matches[1].ToLower()) { "c" { "Critical" } "critical" { "Critical" } "h" { "High" } "high" { "High" } "l" { "Low" } "low" { "Low" } default { "Medium" } }; $description = $description -replace ('!' + [regex]::Escape($Matches[1])), '' }
    if ($description -match 'project:(\S+)') { $extractedProjectKey = $Matches[1]; if (Get-ProjectOrTemplate $extractedProjectKey) { $projectKey = $extractedProjectKey } else { Write-Warning "Unknown project: $extractedProjectKey" }; $description = $description -replace ('project:' + [regex]::Escape($Matches[1])), '' }
    if ($description -match 'est:(\d+\.?\d*)') { try { $estimatedTime = [double]$Matches[1] } catch { $estimatedTime = 0.0 }; $description = $description -replace ('est:' + [regex]::Escape($Matches[1])), '' }
    if ($description -match 'due:(\S+)') { $dueDateStr = $Matches[1]; try { $parsedDueDate = switch -Regex ($dueDateStr.ToLower()) { '^today$' { [datetime]::Today } '^tomorrow$' { [datetime]::Today.AddDays(1) } '^mon(day)?$' { Get-NextWeekday 1 } '^tue(sday)?$' { Get-NextWeekday 2 } '^wed(nesday)?$' { Get-NextWeekday 3 } '^thu(rsday)?$' { Get-NextWeekday 4 } '^fri(day)?$' { Get-NextWeekday 5 } '^sat(urday)?$' { Get-NextWeekday 6 } '^sun(day)?$' { Get-NextWeekday 0 } '^\+(\d+)$' { [datetime]::Today.AddDays([int]$Matches[1]) } default { [datetime]::Parse($dueDateStr) } }; $dueDate = $parsedDueDate.ToString("yyyy-MM-dd") } catch { Write-Warning "Invalid due date format '$dueDateStr'." }; $description = $description -replace ('due:' + [regex]::Escape($Matches[1])), '' }
    $description = $description.Trim() -replace '\s+', ' '; if ([string]::IsNullOrEmpty($description)) { Write-Error "Task description cannot be empty!"; return }
    $newTask = @{ Id = New-TodoId; Description = $description; Priority = $priority; Category = $category; ProjectKey = $projectKey; StartDate = $startDate; DueDate = $dueDate; Tags = $tags; Progress = 0; Completed = $false; CreatedDate = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss"); CompletedDate = $null; EstimatedTime = $estimatedTime; TimeSpent = 0.0; Subtasks = @(); Notes = ""; LastModified = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss"); IsCommand = $false }
    $script:Data.Tasks += $newTask; if ($projectKey) { Update-ProjectStatistics -ProjectKey $projectKey }; Save-UnifiedData
    Write-Success "Quick added: '$description'"; if ($priority -ne $script:Data.Settings.DefaultPriority) { Write-Host "   Priority: $priority" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")) }; if ($dueDate) { Write-Host "   Due: $(Format-TodoDate $dueDate)" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")) }; if ($projectKey) { Write-Host "   Project: $((Get-ProjectOrTemplate $projectKey).Name)" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")) }; if ($tags.Count -gt 0) { Write-Host "   Tags: $($tags -join ', ')" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")) }; if ($estimatedTime -gt 0) { Write-Host "   Est. Time: ${estimatedTime}h" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")) }
}

function global:Complete-Task {
    param([string]$TaskIdInput)
    $idToComplete = $TaskIdInput; if (-not $idToComplete) { Show-TasksView; $idToComplete = Read-Host "`nEnter task ID to complete"; if ([string]::IsNullOrWhiteSpace($idToComplete)) { Write-Info "Cancelled."; return } }
    $task = $script:Data.Tasks | Where-Object { $_.Id -like "$idToComplete*" -and ($_.IsCommand -ne $true) } | Select-Object -First 1
    if (-not $task) { Write-Error "Task with ID starting '$idToComplete' not found!"; return }; if ($task.Completed) { Write-Info "Task '$($task.Description)' is already completed!"; return }
    if ($task.Subtasks -and ($task.Subtasks | Where-Object { -not $_.Completed }).Count -gt 0) { $uncompletedCount = ($task.Subtasks | Where-Object { -not $_.Completed }).Count; Write-Warning "Task has $uncompletedCount uncompleted subtask(s)."; if ((Read-Host "Complete anyway? (Y/N)").ToUpper() -ne 'Y') { Write-Info "Cancelled."; return } }
    $task.Completed = $true; $task.Progress = 100; $task.CompletedDate = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss"); $task.LastModified = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
    if ($task.ProjectKey) { Update-ProjectStatistics -ProjectKey $task.ProjectKey }; Save-UnifiedData
    Write-Success "Completed: $($task.Description)"
    if ($task.TimeSpent -gt 0) { Write-Host "   Time spent: $($task.TimeSpent) hours" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")); if ($task.EstimatedTime -gt 0 -and $task.TimeSpent -gt 0) { $efficiency = [Math]::Round(($task.EstimatedTime / $task.TimeSpent) * 100, 0); Write-Host "   Efficiency: $efficiency% of estimate" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")) } }
}

function global:Update-TaskProgress {
    param([string]$TaskIdInput)
    $idToUpdate = $TaskIdInput; if (-not $idToUpdate) { Show-TasksView; $idToUpdate = Read-Host "`nEnter task ID to update progress"; if ([string]::IsNullOrWhiteSpace($idToUpdate)) { Write-Info "Cancelled."; return } }
    $task = $script:Data.Tasks | Where-Object { $_.Id -like "$idToUpdate*" -and ($_.IsCommand -ne $true) } | Select-Object -First 1
    if (-not $task) { Write-Error "Task with ID starting '$idToUpdate' not found!"; return }
    Write-Host "`nTask: $($task.Description) (ID: $($task.Id.Substring(0,6)))" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.AccentFG")); Write-Host "Current progress: $($task.Progress)%"; Draw-ProgressBar -Percent $task.Progress; Write-Host ""
    if ($task.Subtasks -and $task.Subtasks.Count -gt 0) { $completedSubtasks = ($task.Subtasks | Where-Object { -not $_.Completed }).Count; $calculatedProgress = [Math]::Round(($completedSubtasks / $task.Subtasks.Count) * 100, 0); Write-Host "Progress based on subtasks: $calculatedProgress%" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")); if ((Read-Host "`nUpdate based on: [S]ubtasks, or [M]anual entry? (S/M)").ToUpper() -eq 'S') { $task.Progress = $calculatedProgress; if ($task.Progress -eq 100 -and (-not $task.Completed)) { $task.Completed = $true; $task.CompletedDate = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss"); Write-Info "Task auto-completed." } elseif ($task.Progress -lt 100 -and $task.Completed) { $task.Completed = $false; $task.CompletedDate = $null; Write-Info "Task re-opened." }; $task.LastModified = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss"); Save-UnifiedData; Write-Success "Progress updated to $calculatedProgress%!"; return } }
    $newProgressInput = Read-Host "New progress percentage (0-100)"; try { $progressValue = [int]$newProgressInput; if ($progressValue -lt 0 -or $progressValue -gt 100) { throw "Out of range." }; $task.Progress = $progressValue; if ($progressValue -eq 100 -and (-not $task.Completed)) { $task.Completed = $true; $task.CompletedDate = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss"); Write-Info "Task marked as completed." } elseif ($progressValue -lt 100 -and $task.Completed) { $task.Completed = $false; $task.CompletedDate = $null; Write-Info "Task marked as not completed." }; $task.LastModified = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss"); Save-UnifiedData; Write-Success "Progress updated to $progressValue%!" } catch { Write-Error "Invalid progress value! $_" }
}

function global:Edit-Task {
    param([string]$TaskIdInput)
    $idToEdit = $TaskIdInput; if (-not $idToEdit) { Show-TasksView; $idToEdit = Read-Host "`nEnter task ID to edit"; if ([string]::IsNullOrWhiteSpace($idToEdit)) { Write-Info "Edit cancelled."; return } }
    $task = $script:Data.Tasks | Where-Object { $_.Id -like "$idToEdit*" -and ($_.IsCommand -ne $true) } | Select-Object -First 1
    if (-not $task) { Write-Error "Task with ID starting '$idToEdit' not found!"; return }
    Write-Header "Edit Task: $($task.Id.Substring(0,6)) - $($task.Description)"; Write-Host "Leave field empty to keep current value." -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
    $originalTaskSnapshot = $task.PSObject.Copy(); $changesMade = $false
    $newDesc = Read-Host "Description (current: $($task.Description))"; if (-not [string]::IsNullOrWhiteSpace($newDesc) -and $newDesc -ne $task.Description) { $task.Description = $newDesc }
    $newPriorityInput = Read-Host "Priority (current: $($task.Priority)) - [C]ritical, [H]igh, [M]edium, [L]ow"; if (-not [string]::IsNullOrWhiteSpace($newPriorityInput)) { $task.Priority = switch ($newPriorityInput.ToUpper()) { "C" { "Critical" } "H" { "High" } "M" { "Medium" } "L" { "Low" } default { $task.Priority } } }
    $newCategory = Read-Host "Category (current: $($task.Category))"; if (-not [string]::IsNullOrWhiteSpace($newCategory) -and $newCategory -ne $task.Category) { $task.Category = $newCategory }
    $currentProjectName = if ($task.ProjectKey) { (Get-ProjectOrTemplate $task.ProjectKey).Name } else { 'None' }; Write-Host "Project (current: $currentProjectName - key: $($task.ProjectKey))"; Show-ProjectsAndTemplates -Simple; $newProjectKeyInput = Read-Host "New project key (or 'none' to remove)"; if (-not [string]::IsNullOrWhiteSpace($newProjectKeyInput)) { if ($newProjectKeyInput.ToLower() -in @('none', 'clear')) { $task.ProjectKey = $null } elseif (Get-ProjectOrTemplate $newProjectKeyInput) { $task.ProjectKey = $newProjectKeyInput } else { Write-Warning "Project key '$newProjectKeyInput' not found." } }
    $currentDueDateDisplay = if ($task.DueDate) { Format-TodoDate $task.DueDate } else { 'None' }; $newDueDateInput = Read-Host "Due Date (current: $currentDueDateDisplay) - YYYY-MM-DD, today, +X, or 'clear'"; if (-not [string]::IsNullOrWhiteSpace($newDueDateInput)) { if ($newDueDateInput.ToLower() -eq 'clear') { $task.DueDate = $null } else { try { $parsedDueDate = switch -Regex ($newDueDateInput.ToLower()) { '^today$' { [datetime]::Today } '^tomorrow$' { [datetime]::Today.AddDays(1) } '^\+(\d+)$' { [datetime]::Today.AddDays([int]$Matches[1]) } default { [datetime]::Parse($newDueDateInput) } }; $task.DueDate = $parsedDueDate.ToString("yyyy-MM-dd") } catch { Write-Warning "Invalid date format." } } }
    $newEstimateInput = Read-Host "Estimated Time (current: $($task.EstimatedTime)h)"; if (-not [string]::IsNullOrWhiteSpace($newEstimateInput)) { try { $task.EstimatedTime = [double]$newEstimateInput } catch { Write-Warning "Invalid number for estimate." } }
    $currentTagsDisplay = if ($task.Tags -and $task.Tags.Count -gt 0) { $task.Tags -join ', ' } else { "None" }; $newTagsInput = Read-Host "Tags (current: $currentTagsDisplay) - comma-separated, or 'clear'"; if ($newTagsInput -ne $null) { if ($newTagsInput.ToLower() -eq 'clear' -or [string]::IsNullOrWhiteSpace($newTagsInput)) { $task.Tags = @() } else { $task.Tags = $newTagsInput -split ',' | ForEach-Object { $_.Trim() } | Where-Object { -not [string]::IsNullOrWhiteSpace($_) } } }
    
    $editNotesChoice = Read-Host "Edit notes? Current: $(if ([string]::IsNullOrWhiteSpace($task.Notes)) { 'No notes' } else { 'Has notes' }) (Y/N)"; if ($editNotesChoice.ToUpper() -eq 'Y') { Write-Host "Current notes:"; Write-Host $task.Notes -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")); Write-Host "`nEnter new notes (press Esc when finished, or type 'clear' on first line and Esc to empty):"; $newNotes = Read-MultilineText; $firstLine = ($newNotes -split "`n")[0].Trim(); if ($firstLine.ToLower() -eq 'clear') { $task.Notes = "" } elseif ($newNotes -ne $task.Notes) { $task.Notes = $newNotes } }
    
    foreach($prop in $originalTaskSnapshot.PSObject.Properties.Name){ if($task.$prop -ne $originalTaskSnapshot.$prop){ $changesMade = $true; break } }; if (($task.Tags | ConvertTo-Json) -ne ($originalTaskSnapshot.Tags | ConvertTo-Json)) { $changesMade = $true }
    if ($changesMade) { $task.LastModified = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss"); if ($originalTaskSnapshot.ProjectKey -and $originalTaskSnapshot.ProjectKey -ne $task.ProjectKey) { Update-ProjectStatistics -ProjectKey $originalTaskSnapshot.ProjectKey }; if ($task.ProjectKey) { Update-ProjectStatistics -ProjectKey $task.ProjectKey }; Save-UnifiedData; Write-Success "Task '$($task.Description)' updated!" } else { Write-Info "No changes made." }
}

function global:Manage-Subtasks {
    param([string]$TaskIdInput)
    
    $idForSubtasks = $TaskIdInput
    if (-not $idForSubtasks) {
        Show-TasksView
        $idForSubtasks = Read-Host "`nEnter task ID to manage subtasks (or Enter to cancel)"
        if ([string]::IsNullOrWhiteSpace($idForSubtasks)) { Write-Info "Subtask management cancelled."; return }
    }
   
    $task = $script:Data.Tasks | Where-Object { $_.Id -like "$idForSubtasks*" -and ($_.IsCommand -ne $true) } | Select-Object -First 1
   
    if (-not $task) { Write-Error "Task with ID starting '$idForSubtasks' not found!"; return }
    if ($null -eq $task.Subtasks -or -not ($task.Subtasks -is [System.Array])) { $task.Subtasks = @() }
 
    while ($true) {
        Clear-Host
        Write-Header "Manage Subtasks for: $($task.Description) (ID: $($task.Id.Substring(0,6)))"
       
        if ($task.Subtasks.Count -eq 0) { Write-Host "`nNo subtasks yet." -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")) }
        else {
            Write-Host "`nSubtasks:"
            for ($i = 0; $i -lt $task.Subtasks.Count; $i++) {
                $subtask = $task.Subtasks[$i]
                $icon = if ($subtask.Completed) { Apply-PSStyle -Text "âœ“" -FG (Get-ThemeProperty "Palette.SuccessFG") } else { "â—‹" }
                $color = if ($subtask.Completed) { (Get-ThemeProperty "Palette.SubtleFG") } else { (Get-ThemeProperty "Palette.PrimaryFG") }
                Write-Host "  [$i] $(Apply-PSStyle -Text "$icon $($subtask.Description)" -FG $color)"
            }
            $completedCount = ($task.Subtasks | Where-Object { $_.Completed }).Count
            Write-Host "`nProgress from subtasks: $completedCount/$($task.Subtasks.Count) completed" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SuccessFG"))
        }
       
        Write-Host "`n[A]dd subtask, [T]oggle complete, [E]dit subtask, [D]elete subtask, [B]ack"
        $choice = Read-Host "Choice"
        $actionTaken = $true
 
        switch ($choice.ToLower()) {
            "a" {
                $desc = Read-Host "New subtask description"
                if (-not [string]::IsNullOrWhiteSpace($desc)) {
                    $task.Subtasks += @{ Description = $desc; Completed = $false; CompletedDate = $null }
                    Write-Success "Subtask added!"
                } else { Write-Info "Subtask not added (empty description)."; $actionTaken = $false }
            }
            "t" {
                if ($task.Subtasks.Count -eq 0) { Write-Error "No subtasks to toggle!"; $actionTaken = $false; break }
                $indexInput = Read-Host "Subtask number to toggle"
                try {
                    $idx = [int]$indexInput
                    if ($idx -ge 0 -and $idx -lt $task.Subtasks.Count) {
                        $task.Subtasks[$idx].Completed = -not $task.Subtasks[$idx].Completed
                        $task.Subtasks[$idx].CompletedDate = if ($task.Subtasks[$idx].Completed) { (Get-Date).ToString("yyyy-MM-dd HH:mm:ss") } else { $null }
                        Write-Success "Subtask completion toggled!"
                    } else { Write-Error "Invalid index!"; $actionTaken = $false }
                } catch { Write-Error "Invalid index format!"; $actionTaken = $false }
            }
            "e" {
                 if ($task.Subtasks.Count -eq 0) { Write-Error "No subtasks to edit!"; $actionTaken = $false; break }
                 $indexInput = Read-Host "Subtask number to edit"
                 try {
                    $idx = [int]$indexInput
                    if ($idx -ge 0 -and $idx -lt $task.Subtasks.Count) {
                        $newSubDesc = Read-Host "New description for '$($task.Subtasks[$idx].Description)'"
                        if(-not [string]::IsNullOrWhiteSpace($newSubDesc)){
                            $task.Subtasks[$idx].Description = $newSubDesc
                            Write-Success "Subtask description updated."
                        } else { Write-Info "Description not changed (empty input)."; $actionTaken = $false}
                    } else { Write-Error "Invalid index!"; $actionTaken = $false }
                 } catch { Write-Error "Invalid index format!"; $actionTaken = $false }
            }
            "d" {
                if ($task.Subtasks.Count -eq 0) { Write-Error "No subtasks to delete!"; $actionTaken = $false; break }
                $indexToDelete = Read-Host "Subtask number to delete"
                try {
                    $idx = [int]$indexToDelete
                    if ($idx -ge 0 -and $idx -lt $task.Subtasks.Count) {
                        Write-Warning "Delete subtask '$($task.Subtasks[$idx].Description)'?"
                        if((Read-Host "Confirm (Y/N)").ToUpper() -eq 'Y'){
                            $task.Subtasks = @($task.Subtasks | Select-Object -Index (0..($task.Subtasks.Count-1) | Where-Object { $_ -ne $idx }))
                            Write-Success "Subtask deleted!"
                        } else { Write-Info "Deletion cancelled."; $actionTaken = $false}
                    } else { Write-Error "Invalid index!"; $actionTaken = $false }
                } catch { Write-Error "Invalid index format!"; $actionTaken = $false }
            }
            "b" { return }
            default {
                if (-not [string]::IsNullOrEmpty($choice)) { Write-Warning "Unknown command." }
                $actionTaken = $false
            }
        }
        if ($actionTaken) {
            if ($task.Subtasks.Count -gt 0) {
                $completedSubtasksCount = ($task.Subtasks | Where-Object { $_.Completed }).Count
                $task.Progress = [Math]::Round(($completedSubtasksCount / $task.Subtasks.Count) * 100, 0)
            } else {
                 if (-not $task.Completed -and $task.Progress -ne 100) { $task.Progress = 0 }
            }
            if ($task.Progress -eq 100 -and (-not $task.Completed)) {
                 $task.Completed = $true; $task.CompletedDate = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
            } elseif ($task.Progress -lt 100 -and $task.Completed) {
                 $task.Completed = $false; $task.CompletedDate = $null
            }
            $task.LastModified = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
            Save-UnifiedData
            if ($choice.ToLower() -ne "b") { Start-Sleep -Seconds 1 }
        }
    }
}
 
function global:Remove-Task {
    param([string]$TaskIdInput)
    
    $idToRemove = $TaskIdInput
    if (-not $idToRemove) {
        Show-TasksView
        $idToRemove = Read-Host "`nEnter task ID to delete (or Enter to cancel)"
        if ([string]::IsNullOrWhiteSpace($idToRemove)) { Write-Info "Deletion cancelled."; return }
    }
   
    $task = $script:Data.Tasks | Where-Object { $_.Id -like "$idToRemove*" -and ($_.IsCommand -ne $true) } | Select-Object -First 1
   
    if (-not $task) { Write-Error "Task with ID starting '$idToRemove' not found!"; return }
   
    Write-Warning "Permanently delete task: '$($task.Description)' (ID: $($task.Id.Substring(0,6)))?"
    if ($task.TimeSpent -gt 0) { Write-Warning "This task has $($task.TimeSpent) hours logged! This time will NOT be deleted from project totals unless manually adjusted." }
    if ($task.Subtasks -and $task.Subtasks.Count -gt 0) { Write-Warning "This task has $($task.Subtasks.Count) subtask(s) which will also be deleted."}
   
    if ((Read-Host "Type 'yes' to confirm deletion").ToLower() -eq 'yes') {
        $originalProjectKey = $task.ProjectKey
        $script:Data.Tasks = $script:Data.Tasks | Where-Object { $_.Id -ne $task.Id }
       
        if ($originalProjectKey) { Update-ProjectStatistics -ProjectKey $originalProjectKey }
        Save-UnifiedData
        Write-Success "Task '$($task.Description)' deleted!"
    } else {
        Write-Info "Deletion cancelled."
    }
}
 
function global:Archive-CompletedTasks {
    $completedTasks = $script:Data.Tasks | Where-Object { $_.Completed -and ($_.IsCommand -ne $true) }
    
    if ($completedTasks.Count -eq 0) { Write-Info "No completed tasks to archive."; return }
 
    $cutoffDate = [datetime]::Today.AddDays(-$script:Data.Settings.AutoArchiveDays)
    $tasksToAutoArchive = $completedTasks | Where-Object {
        (-not [string]::IsNullOrEmpty($_.CompletedDate)) -and ([datetime]::Parse($_.CompletedDate).Date -lt $cutoffDate.Date)
    }
   
    $tasksToConsider = $tasksToAutoArchive
    $archiveMode = "automatic"
 
    if ($tasksToAutoArchive.Count -eq 0) {
        Write-Info "No tasks old enough for automatic archiving (older than $($script:Data.Settings.AutoArchiveDays) days)."
        if ((Read-Host "`nArchive all $($completedTasks.Count) completed task(s) manually now? (Y/N)").ToUpper() -eq 'Y') {
            $tasksToConsider = $completedTasks
            $archiveMode = "manual"
        } else {
            Write-Info "Archive operation cancelled."; return
        }
    } else {
        if ((Read-Host "Archive $($tasksToAutoArchive.Count) task(s) older than $($script:Data.Settings.AutoArchiveDays) days? (Y/N)").ToUpper() -ne 'Y') {
            Write-Info "Automatic archive cancelled."; return
        }
    }
   
    if ($tasksToConsider.Count -eq 0) { Write-Info "No tasks selected for archiving."; return }
 
    if ($null -eq $script:Data.ArchivedTasks) { $script:Data.ArchivedTasks = @() }
    $script:Data.ArchivedTasks += $tasksToConsider
 
    $idsToArchive = $tasksToConsider | ForEach-Object {$_.Id}
    $script:Data.Tasks = $script:Data.Tasks | Where-Object { $_.Id -notin $idsToArchive }
   
    $affectedProjects = $tasksToConsider | Where-Object { -not [string]::IsNullOrEmpty($_.ProjectKey) } | Select-Object -ExpandProperty ProjectKey -Unique
    foreach ($projectKey in $affectedProjects) { Update-ProjectStatistics -ProjectKey $projectKey }
   
    Save-UnifiedData
    Write-Success "Archived $($tasksToConsider.Count) task(s) ($archiveMode)."
}
 
function global:View-TaskArchive {
    Clear-Host
    Write-Header "Archived Tasks"
   
    if (-not $script:Data.ArchivedTasks -or $script:Data.ArchivedTasks.Count -eq 0) {
        Write-Host "`n  ğŸ“­ No archived tasks." -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
        return
    }
   
    $groupedByMonth = $script:Data.ArchivedTasks |
        Where-Object {-not [string]::IsNullOrEmpty($_.CompletedDate)} |
        Group-Object { try { [datetime]::Parse($_.CompletedDate).ToString("yyyy-MM") } catch { "InvalidDate" } } |
        Sort-Object Name -Descending
   
    foreach ($monthGroup in $groupedByMonth) {
        $monthYearDisplay = if ($monthGroup.Name -eq "InvalidDate") { "[Tasks with Invalid Completion Dates]" }
                           else { try { [datetime]::ParseExact($monthGroup.Name, "yyyy-MM", $null).ToString("MMMM yyyy") } catch { $monthGroup.Name } }
        Write-Host "`n  ğŸ“… $monthYearDisplay ($($monthGroup.Count) items)" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG"))
       
        foreach ($task in $monthGroup.Group | Sort-Object @{Expression={if([string]::IsNullOrEmpty($_.CompletedDate)) {[DateTime]::MinValue} else {[DateTime]::Parse($_.CompletedDate)}}; Descending=$true}) {
            Write-Host "     âœ“ $($task.Description) (ID: $($task.Id.Substring(0,6)))" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
            $completedDateDisplay = if ($task.CompletedDate) { try {([datetime]::Parse($task.CompletedDate)).ToString('MMM dd, yyyy HH:mm')} catch{"N/A"}} else { "N/A" }
            Write-Host "       Completed: $completedDateDisplay" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
           
            if ($task.TimeSpent -gt 0) {
                Write-Host "       Time Spent: $($task.TimeSpent)h" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")) -NoNewline
                if ($task.EstimatedTime -gt 0) { Write-Host " (Est: $($task.EstimatedTime)h)" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")) }
                else { Write-Host }
            }
            if ($task.ProjectKey) {
                $project = Get-ProjectOrTemplate $task.ProjectKey
                if ($project) { Write-Host "       Project: $($project.Name) (Key: $($task.ProjectKey))" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")) }
            }
        }
    }
   
    $totalArchived = $script:Data.ArchivedTasks.Count
    $totalTimeSpent = ($script:Data.ArchivedTasks | Measure-Object -Property TimeSpent -Sum).Sum
    $totalEstimatedTime = ($script:Data.ArchivedTasks | Measure-Object -Property EstimatedTime -Sum).Sum
    
    Write-Host "`n" ("=" * 60) -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
    Write-Host "  Total archived: $totalArchived tasks" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SuccessFG"))
    if ($totalTimeSpent -gt 0) {
        Write-Host "  Total time spent on archived: $totalTimeSpent hours" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SuccessFG"))
        if ($totalEstimatedTime -gt 0 -and $totalTimeSpent -gt 0) {
            $efficiency = [Math]::Round(($totalEstimatedTime / $totalTimeSpent) * 100, 0)
            Write-Host "  Average efficiency (archived): $efficiency% of estimates" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SuccessFG"))
        }
    }
   
    Write-Host "`nPress any key to continue..." -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
}
 
function global:Edit-TaskSettings {
    Write-Header "Task Settings"
    Write-Host "Leave empty to keep current value." -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
 
    $settings = $script:Data.Settings
    
    $newPriorityInput = Read-Host "`nDefault Priority (current: $($settings.DefaultPriority)) - [C]ritical, [H]igh, [M]edium, [L]ow"
    if (-not [string]::IsNullOrWhiteSpace($newPriorityInput)) {
        $settings.DefaultPriority = switch ($newPriorityInput.ToUpper()) {
            "C" { "Critical" } "H" { "High" } "M" { "Medium" } "L" { "Low" }
            default { $settings.DefaultPriority }
        }
    }
 
    $newCategoryInput = Read-Host "`nDefault Category (current: $($settings.DefaultCategory))"
    if (-not [string]::IsNullOrWhiteSpace($newCategoryInput)) {
        $settings.DefaultCategory = $newCategoryInput
    }
 
    $newShowDaysInput = Read-Host "`nDays to show completed tasks in active views (current: $($settings.ShowCompletedDays))"
    if (-not [string]::IsNullOrWhiteSpace($newShowDaysInput)) {
        try {
            $days = [int]$newShowDaysInput
            if ($days -ge 0) { $settings.ShowCompletedDays = $days }
            else { Write-Warning "Days must be non-negative. Not changed."}
        }
        catch { Write-Warning "Invalid number for ShowCompletedDays. Not changed." }
    }
   
    $newArchiveDaysInput = Read-Host "`nDays until completed tasks are auto-archived (current: $($settings.AutoArchiveDays))"
    if (-not [string]::IsNullOrWhiteSpace($newArchiveDaysInput)) {
        try {
            $days = [int]$newArchiveDaysInput
            if ($days -ge 0) { $settings.AutoArchiveDays = $days }
            else { Write-Warning "Days must be non-negative. Not changed."}
        }
        catch { Write-Warning "Invalid number for AutoArchiveDays. Not changed." }
    }
 
    $enableTimeTrackingInput = Read-Host "`nEnable time tracking integration for tasks (Y/N) (current: $(if($settings.EnableTimeTracking){'Yes'}else{'No'}))"
    if(-not [string]::IsNullOrWhiteSpace($enableTimeTrackingInput)){
        $settings.EnableTimeTracking = $enableTimeTrackingInput.ToUpper() -eq 'Y'
    }
 
    Save-UnifiedData
    Write-Success "Task settings updated!"
}
 
#endregion
 
#region Task Status Functions
 
function global:Get-TaskStatus {
    param($Task)
   
    if ($Task.Completed) { return "Completed" }
    if ($Task.Progress -ge 100) { return "Done (Pending Confirmation)" }
    if ($Task.Progress -gt 0) { return "In Progress" }
 
    if (-not [string]::IsNullOrEmpty($Task.DueDate)) {
        try {
            $dueDate = [datetime]::Parse($Task.DueDate).Date
            $today = [datetime]::Today.Date
            $daysUntil = ($dueDate - $today).Days
            if ($daysUntil -lt 0) { return "Overdue" }
            if ($daysUntil -eq 0) { return "Due Today" }
            if ($daysUntil -gt 0 -and $daysUntil -le 3) { return "Due Soon" }
        } catch { }
    }
    if (-not [string]::IsNullOrEmpty($Task.StartDate)) {
         try {
            $startDate = [datetime]::Parse($Task.StartDate).Date
            $today = [datetime]::Today.Date
            if ($startDate -gt $today) { return "Scheduled" }
        } catch { }
    }
    return "Pending"
}
 
function global:Get-PriorityInfo {
    param($Priority)
    switch ($Priority) {
        "Critical" { return @{ Color = (Get-ThemeProperty "Palette.ErrorFG"); Icon = "ğŸ”¥" } }
        "High" { return @{ Color = (Get-ThemeProperty "Palette.ErrorFG"); Icon = "ğŸ”´" } }
        "Medium" { return @{ Color = (Get-ThemeProperty "Palette.WarningFG"); Icon = "ğŸŸ¡" } }
        "Low" { return @{ Color = (Get-ThemeProperty "Palette.SuccessFG"); Icon = "ğŸŸ¢" } }
        default { return @{ Color = (Get-ThemeProperty "Palette.SubtleFG"); Icon = "âšª" } }
    }
}
 
#endregion
 
#region Display Functions (Task Specific Views)
 
function global:Show-TasksView {
    param(
        [string]$Filter = "",
        [string]$SortBy = "Smart",
        [switch]$ShowCompleted,
        [string]$View = "Default" 
    )
   
    $tasksToDisplay = $script:Data.Tasks
    if (-not $script:Data.Settings.CommandSnippets.ShowInTaskList) {
        $tasksToDisplay = $tasksToDisplay | Where-Object { $_.IsCommand -ne $true }
    }
 
    if ($Filter) {
        $tasksToDisplay = $tasksToDisplay | Where-Object {
            $_.Description -like "*$Filter*" -or
            $_.Category -like "*$Filter*" -or
            ($_.Tags -and ($_.Tags -join ' ') -like "*$Filter*") -or
            ($_.ProjectKey -and (Get-ProjectOrTemplate $_.ProjectKey) -and (Get-ProjectOrTemplate $_.ProjectKey).Name -like "*$Filter*") -or
            $_.Id -like "*$Filter*"
        }
    }
   
    if (-not $ShowCompleted) {
        $cutoffDate = [datetime]::Today.AddDays(-$script:Data.Settings.ShowCompletedDays)
        $tasksToDisplay = $tasksToDisplay | Where-Object {
            (-not $_.Completed) -or
            ((-not [string]::IsNullOrEmpty($_.CompletedDate)) -and ([datetime]::Parse($_.CompletedDate).Date -ge $cutoffDate.Date))
        }
    }
    
    $sortedTasks = switch ($SortBy.ToLower()) {
        "smart" {
            $tasksToDisplay | Sort-Object @{Expression={
                $status = Get-TaskStatus $_
                switch($status) {
                    "Overdue" { 1 } "Due Today" { 2 } "Due Soon" { 3 }
                    "In Progress" { 4 } "Done (Pending Confirmation)" {4} "Pending" { 5 } "Scheduled" { 6 }
                    "Completed" { 7 } default { 8 }
                }
            }}, @{Expression={
                switch($_.Priority) {
                    "Critical" { 1 } "High" { 2 } "Medium" { 3 } "Low" { 4 } default { 5 }
                }
            }}, @{Expression={
                if([string]::IsNullOrEmpty($_.DueDate)) {
                    [DateTime]::MaxValue
                } else {
                    try { [DateTime]::Parse($_.DueDate) } catch { [DateTime]::MaxValue }
                }
            }}, @{Expression={
                if([string]::IsNullOrEmpty($_.CreatedDate)) {
                    [DateTime]::MinValue
                } else {
                    try { [DateTime]::Parse($_.CreatedDate) } catch { [DateTime]::MinValue }
                }
            }}
        }
        "priority" {
            $tasksToDisplay | Sort-Object @{Expression={
                switch($_.Priority) {
                    "Critical" { 1 } "High" { 2 } "Medium" { 3 } "Low" { 4 } default { 5 }
                }
            }}, @{Expression={
                if([string]::IsNullOrEmpty($_.DueDate)) {
                    [DateTime]::MaxValue
                } else {
                    try { [DateTime]::Parse($_.DueDate) } catch { [DateTime]::MaxValue }
                }
            }}, @{Expression={
                if([string]::IsNullOrEmpty($_.CreatedDate)) {
                    [DateTime]::MinValue
                } else {
                    try { [DateTime]::Parse($_.CreatedDate) } catch { [DateTime]::MinValue }
                }
            }}
        }
        "duedate" {
            $tasksToDisplay | Sort-Object @{Expression={
                if([string]::IsNullOrEmpty($_.DueDate)) {
                    [DateTime]::MaxValue
                } else {
                    try { [DateTime]::Parse($_.DueDate) } catch { [DateTime]::MaxValue }
                }
            }}, @{Expression={
                switch($_.Priority) {
                    "Critical" { 1 } "High" { 2 } "Medium" { 3 } "Low" { 4 } default { 5 }
                }
            }}
        }
        "created" {
            $tasksToDisplay | Sort-Object @{Expression={
                if([string]::IsNullOrEmpty($_.CreatedDate)) {
                    [DateTime]::MinValue
                } else {
                    try { [DateTime]::Parse($_.CreatedDate) } catch { [DateTime]::MinValue }
                }
            }; Descending = $true}
        }
        "category" {
            $tasksToDisplay | Sort-Object @{Expression={
                if([string]::IsNullOrEmpty($_.Category)) { "zzz" } else { $_.Category }
            }}, @{Expression={
                switch($_.Priority) {
                    "Critical" { 1 } "High" { 2 } "Medium" { 3 } "Low" { 4 } default { 5 }
                }
            }}
        }
        "project" {
            $tasksToDisplay | Sort-Object @{Expression={
                if([string]::IsNullOrEmpty($_.ProjectKey)) { "zzz" } else { $_.ProjectKey }
            }}, @{Expression={
                switch($_.Priority) {
                    "Critical" { 1 } "High" { 2 } "Medium" { 3 } "Low" { 4 } default { 5 }
                }
            }}
        }
        default { $tasksToDisplay }
    }
   
    if ($sortedTasks.Count -eq 0) {
        Write-Host "`n  ğŸ“­ No tasks found matching current filters." -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG"))
        Show-TaskStatistics $tasksToDisplay
        return
    }
   
    switch ($View.ToLower()) {
        "kanban" { Show-KanbanView $sortedTasks }
        "timeline" { Show-TimelineView $sortedTasks }
        "project" { Show-ProjectTaskView $sortedTasks }
        default { Show-TaskListView $sortedTasks }
    }
   
    Show-TaskStatistics $sortedTasks
}
 
function global:Show-TaskListView {
    param($TasksToDisplay)
    
    $groups = $TasksToDisplay | Group-Object Category | Sort-Object Name
   
    foreach ($group in $groups) {
        $categoryName = if ([string]::IsNullOrEmpty($group.Name)) { "[Uncategorized]" } else { $group.Name }
        Write-Host "`n  ğŸ“ $categoryName ($($group.Count) tasks)" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.AccentFG"))
        Write-Host "  " ("-" * ($categoryName.Length + 15)) -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
        
        foreach ($task in $group.Group) { Show-TaskItem $task }
    }
}
 
function global:Show-TaskItem {
    param($Task)
   
    $icon = if ($Task.Completed) { Apply-PSStyle -Text "âœ…" -FG (Get-ThemeProperty "Palette.SuccessFG") } else { "â¬œ" }
    $priorityInfo = Get-PriorityInfo $Task.Priority
    $id = $Task.Id.Substring(0, 6)
    $status = Get-TaskStatus $Task
    
    Write-Host "  $icon [$id] " -NoNewline
    Write-Host (Apply-PSStyle -Text $priorityInfo.Icon -FG $priorityInfo.Color) -NoNewline
    Write-Host " " -NoNewline
   
    $descriptionText = $Task.Description
    if ($Task.Completed) {
        Write-Host (Apply-PSStyle -Text $descriptionText -FG (Get-ThemeProperty "Palette.SubtleFG"))
    } else {
        $statusColor = switch ($status) {
            "Overdue" { Get-ThemeProperty "Palette.ErrorFG" }
            "Due Today" { Get-ThemeProperty "Palette.WarningFG" }
            "Due Soon" { Get-ThemeProperty "Palette.InfoFG" }
            "In Progress" { Get-ThemeProperty "Palette.InfoFG" }
            "Done (Pending Confirmation)" { Get-ThemeProperty "Palette.SuccessFG"}
            default { Get-ThemeProperty "Palette.PrimaryFG" }
        }
        Write-Host (Apply-PSStyle -Text $descriptionText -FG $statusColor)
    }
   
    Write-Host "      " -NoNewline
    $detailsParts = @()
 
    if ($status -notin @("Pending", "Completed", "Done (Pending Confirmation)")) {
        $badgeColor = switch ($status) {
            "Overdue" { Get-ThemeProperty "Palette.ErrorFG" }
            "Due Today" { Get-ThemeProperty "Palette.WarningFG" }
            "Due Soon" { Get-ThemeProperty "Palette.InfoFG" }
            "In Progress" { Get-ThemeProperty "Palette.InfoFG" }
            "Scheduled" { Get-ThemeProperty "Palette.AccentFG" }
            default { Get-ThemeProperty "Palette.SubtleFG" }
        }
        $detailsParts += Apply-PSStyle -Text "[$status]" -FG $badgeColor
    }
   
    if (-not [string]::IsNullOrEmpty($Task.DueDate)) {
        $dueDateObj = try {[datetime]::Parse($Task.DueDate)} catch {$null}
        if($dueDateObj){
            $dueDateStr = Format-TodoDate $Task.DueDate
            $daysUntil = ($dueDateObj.Date - [datetime]::Today.Date).Days
            $dateColor = if ($daysUntil -lt 0 -and !$Task.Completed) { Get-ThemeProperty "Palette.ErrorFG" }
                        elseif ($daysUntil -eq 0 -and !$Task.Completed) { Get-ThemeProperty "Palette.WarningFG" }
                        elseif ($daysUntil -gt 0 -and $daysUntil -le 3 -and !$Task.Completed) { Get-ThemeProperty "Palette.InfoFG" }
                        else { Get-ThemeProperty "Palette.SubtleFG" }
            $detailsParts += Apply-PSStyle -Text "ğŸ“… $dueDateStr" -FG $dateColor
        }
    }
   
    if ($Task.ProjectKey) {
        $project = Get-ProjectOrTemplate $Task.ProjectKey
        if ($project) {
            $detailsParts += Apply-PSStyle -Text "ğŸ—ï¸  $($project.Name)" -FG (Get-ThemeProperty "Palette.AccentFG")
        }
    }
   
    if ($Task.Tags -and $Task.Tags.Count -gt 0) {
        $detailsParts += Apply-PSStyle -Text "ğŸ·ï¸  $($Task.Tags -join ', ')" -FG (Get-ThemeProperty "Palette.InfoFG")
    }
   
    if ($Task.Progress -gt 0 -and -not $Task.Completed) {
        $detailsParts += Apply-PSStyle -Text "ğŸ“ˆ $($Task.Progress)%" -FG (Get-ThemeProperty "Palette.SuccessFG")
    }
   
    if ($Task.TimeSpent -gt 0) {
        $detailsParts += Apply-PSStyle -Text "â±ï¸  $($Task.TimeSpent)h" -FG (Get-ThemeProperty "Palette.InfoFG")
    }
   
    if ($detailsParts.Count -gt 0) {
        Write-Host ($detailsParts -join (Apply-PSStyle -Text " | " -FG (Get-ThemeProperty "Palette.SubtleFG")))
    } else { Write-Host }
 
    if ($Task.Subtasks -and $Task.Subtasks.Count -gt 0) {
        $completedSubtasks = ($Task.Subtasks | Where-Object { $_.Completed }).Count
        Write-Host "      ğŸ“Œ Subtasks: $completedSubtasks/$($Task.Subtasks.Count) completed" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.InfoFG"))
    }
}
 
function global:Show-KanbanView {
    param($TasksToDisplay)
    
    $columns = @{
        "To Do" = $TasksToDisplay | Where-Object { (-not $_.Completed) -and ($_.Progress -eq 0) -and (Get-TaskStatus $_) -notin @("Scheduled", "Overdue", "Due Today", "Due Soon") }
        "Scheduled/Due" = $TasksToDisplay | Where-Object { (-not $_.Completed) -and ($_.Progress -eq 0) -and (Get-TaskStatus $_) -in @("Scheduled", "Overdue", "Due Today", "Due Soon") }
        "In Progress" = $TasksToDisplay | Where-Object { (-not $_.Completed) -and ($_.Progress -gt 0) -and ($_.Progress -lt 100) }
        "Done" = $TasksToDisplay | Where-Object { $_.Completed -or ($_.Progress -eq 100) }
    }
    $columnOrder = @("To Do", "Scheduled/Due", "In Progress", "Done")
    $columnColors = @{
        "To Do" = (Get-ThemeProperty "Palette.PrimaryFG")
        "Scheduled/Due" = (Get-ThemeProperty "Palette.WarningFG")
        "In Progress" = (Get-ThemeProperty "Palette.InfoFG")
        "Done" = (Get-ThemeProperty "Palette.SuccessFG")
    }
 
    Write-Host "`n  KANBAN BOARD" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.InfoFG"))
    Write-Host "  " ("=" * (($columnOrder.Count * 22) + $columnOrder.Count -1)) -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
    
    $maxItems = 0
    if ($columns.Values.Count -gt 0) {
        $maxItems = ($columns.Values | ForEach-Object { $_.Count } | Measure-Object -Maximum).Maximum
        if ($null -eq $maxItems) {$maxItems = 0}
    }
    if ($maxItems -eq 0) { Write-Host "  No tasks to display in Kanban view." ; return}
 
    $colWidth = 20
    $border = Get-BorderStyleChars
    
    $headerTopLine = "  $($border.TopLeft)"
    $headerTextLine = "  $($border.Vertical)"
    $headerSeparatorLine = "  $($border.TLeft)"
    foreach($colName in $columnOrder){
        $headerTopLine += ($border.Horizontal * $colWidth) + $border.TTop
        $headerTextLine += " $(Apply-PSStyle -Text $colName.ToUpper().PadRight($colWidth -1) -FG $columnColors[$colName])$($border.Vertical)"
        $headerSeparatorLine += ($border.Horizontal * $colWidth) + $border.Cross
    }
    Write-Host ($headerTopLine.Substring(0, $headerTopLine.Length-1) + $border.TopRight)
    Write-Host $headerTextLine
    Write-Host ($headerSeparatorLine.Substring(0, $headerSeparatorLine.Length-1) + $border.TRight)
    
    for ($i = 0; $i -lt $maxItems; $i++) {
        Write-Host "  $($border.Vertical)" -NoNewline
        foreach ($columnName in $columnOrder) {
            $itemsInColumn = $columns[$columnName]
            if ($i -lt $itemsInColumn.Count) {
                $item = $itemsInColumn[$i]
                $text = "$($item.Id.Substring(0,4)): $($item.Description)"
                if ($text.Length -gt ($colWidth - 2)) {
                    $text = $text.Substring(0, $colWidth - 3) + "â€¦"
                }
                $priorityInfo = Get-PriorityInfo $item.Priority
                Write-Host " $(Apply-PSStyle -Text $priorityInfo.Icon -FG $priorityInfo.Color)$($text.PadRight($colWidth - 2))" -NoNewline
            } else {
                Write-Host (" ".PadRight($colWidth)) -NoNewline
            }
            Write-Host "$($border.Vertical)" -NoNewline
        }
        Write-Host
    }
   
    $footerLine = "  $($border.BottomLeft)"
    foreach($colName in $columnOrder){
        $footerLine += ($border.Horizontal * $colWidth) + $border.TBottom
    }
    Write-Host ($footerLine.Substring(0, $footerLine.Length-1) + $border.BottomRight)
}
 
function global:Show-TimelineView {
    param($TasksToDisplay)
    
    Write-Host "`n  ğŸ“… TIMELINE VIEW" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.InfoFG"))
    Write-Host "  " ("=" * 60) -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
    
    $today = [datetime]::Today.Date
    $groups = @{
        "Overdue" = $TasksToDisplay | Where-Object { (-not [string]::IsNullOrEmpty($_.DueDate)) -and ([datetime]::Parse($_.DueDate).Date -lt $today) -and (-not $_.Completed) }
        "Today" = $TasksToDisplay | Where-Object { (-not [string]::IsNullOrEmpty($_.DueDate)) -and ([datetime]::Parse($_.DueDate).Date -eq $today) -and (-not $_.Completed) }
        "This Week" = $TasksToDisplay | Where-Object {
            (-not [string]::IsNullOrEmpty($_.DueDate)) -and
            ([datetime]::Parse($_.DueDate).Date -gt $today) -and
            ([datetime]::Parse($_.DueDate).Date -le $today.AddDays(6)) -and
            (-not $_.Completed)
        }
        "Next Week" = $TasksToDisplay | Where-Object {
            (-not [string]::IsNullOrEmpty($_.DueDate)) -and
            ([datetime]::Parse($_.DueDate).Date -gt $today.AddDays(6)) -and
            ([datetime]::Parse($_.DueDate).Date -le $today.AddDays(13)) -and
            (-not $_.Completed)
        }
        "Later" = $TasksToDisplay | Where-Object {
            (-not [string]::IsNullOrEmpty($_.DueDate)) -and
            ([datetime]::Parse($_.DueDate).Date -gt $today.AddDays(13)) -and
            (-not $_.Completed)
        }
        "No Date" = $TasksToDisplay | Where-Object { [string]::IsNullOrEmpty($_.DueDate) -and (-not $_.Completed) }
        "Completed" = $TasksToDisplay | Where-Object {$_.Completed}
    }
   
    foreach ($period in @("Overdue", "Today", "This Week", "Next Week", "Later", "No Date", "Completed")) {
        $itemsInPeriod = $groups[$period]
        if ($itemsInPeriod.Count -eq 0) { continue }
       
        $color = switch ($period) {
            "Overdue" { Get-ThemeProperty "Palette.ErrorFG" } "Today" { Get-ThemeProperty "Palette.WarningFG" }
            "This Week" { Get-ThemeProperty "Palette.InfoFG" } "Next Week" { Get-ThemeProperty "Palette.AccentFG" }
            "Later" { Get-ThemeProperty "Palette.AccentFG" } "No Date" { Get-ThemeProperty "Palette.SubtleFG" }
            "Completed" { Get-ThemeProperty "Palette.SuccessFG"}
        }
       
        Write-Host "`n  â° $period ($($itemsInPeriod.Count))" -ForegroundColor (Get-LegacyColor $color)
       
        foreach ($task in $itemsInPeriod | Sort-Object @{Expression={if([string]::IsNullOrEmpty($_.DueDate)) {[DateTime]::MaxValue} else {[DateTime]::Parse($_.DueDate)}}}, Priority) {
            $priorityInfo = Get-PriorityInfo $task.Priority
            Write-Host "     $(Apply-PSStyle -Text $priorityInfo.Icon -FG $priorityInfo.Color) " -NoNewline
           
            if ((-not [string]::IsNullOrEmpty($task.DueDate)) -and $period -ne "No Date" -and $period -ne "Completed") {
                $date = try {[datetime]::Parse($task.DueDate)} catch {$null}
                if($date) {Write-Host "$($date.ToString('MMM dd')) - " -NoNewline -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))}
            }
           
            $taskDescColor = if ($task.Completed) { (Get-ThemeProperty "Palette.SubtleFG") } else { $color }
            Write-Host (Apply-PSStyle -Text "$($task.Id.Substring(0,4)): $($task.Description)" -FG $taskDescColor) -NoNewline
           
            if ($task.ProjectKey) {
                $project = Get-ProjectOrTemplate $task.ProjectKey
                if ($project) { Write-Host (Apply-PSStyle -Text " [$($project.Name)]" -FG (Get-ThemeProperty "Palette.AccentFG")) -NoNewline }
            }
            Write-Host
        }
    }
}
 
function global:Show-ProjectTaskView {
    param($TasksToDisplay)
    
    Write-Host "`n  ğŸ—ï¸  PROJECT VIEW" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.InfoFG"))
    Write-Host "  " ("=" * 60) -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
    
    $groups = $TasksToDisplay | Group-Object ProjectKey | Sort-Object @{ Expression = { if ([string]::IsNullOrEmpty($_.Name)) { "zzz_NoProject" } else { (Get-ProjectOrTemplate $_.Name).Name } } }
    
    foreach ($group in $groups) {
        $projectKey = $group.Name
        $project = if ($projectKey) { Get-ProjectOrTemplate $projectKey } else { $null }
        $projectName = if ($project) { $project.Name } else { "[No Project]" }
       
        $activeCount = ($group.Group | Where-Object { -not $_.Completed }).Count
        $completedCount = ($group.Group | Where-Object { $_.Completed }).Count
        
        Write-Host "`n  ğŸ“‚ $projectName " -NoNewline -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.AccentFG"))
        Write-Host "($activeCount active, $completedCount completed)" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
        
        $totalTasksInGroup = $group.Group.Count
        $progressPercent = 0
        if ($totalTasksInGroup -gt 0) {
            $progressPercent = [Math]::Round(($completedCount / $totalTasksInGroup) * 100, 0)
        }
       
        Draw-ProgressBar -Percent $progressPercent; Write-Host ""
       
        foreach ($task in $group.Group | Sort-Object Completed, @{Expression={if([string]::IsNullOrEmpty($_.DueDate)) {[DateTime]::MaxValue} else {[DateTime]::Parse($_.DueDate)}}}, Priority) {
            Show-TaskItem $task
        }
       
        $totalEstimated = ($group.Group | Measure-Object -Property EstimatedTime -Sum).Sum
        $totalSpent = ($group.Group | Measure-Object -Property TimeSpent -Sum).Sum
       
        if ($totalEstimated -gt 0 -or $totalSpent -gt 0) {
            Write-Host "  " ("-" * 40) -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
            if ($totalEstimated -gt 0) { Write-Host "  Est. for these tasks: $totalEstimated hours" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")) }
            if ($totalSpent -gt 0) {
                Write-Host "  Spent on these tasks: $totalSpent hours" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
                if ($totalEstimated -gt 0 -and $totalSpent -gt 0) {
                    $efficiency = [Math]::Round(($totalEstimated / $totalSpent) * 100, 0)
                    Write-Host "  Efficiency for these: $efficiency%" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
                }
            }
        }
    }
}
 
function global:Show-TaskStatistics {
    param($TasksToDisplay)
    if(-not $TasksToDisplay -or $TasksToDisplay.Count -eq 0) {
        Write-Host "`nNo tasks to show statistics for." -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
        return
    }
   
    $stats = @{
        Total = $TasksToDisplay.Count
        Completed = ($TasksToDisplay | Where-Object { $_.Completed }).Count
        Critical = ($TasksToDisplay | Where-Object { $_.Priority -eq "Critical" -and -not $_.Completed }).Count
        High = ($TasksToDisplay | Where-Object { $_.Priority -eq "High" -and -not $_.Completed }).Count
        Medium = ($TasksToDisplay | Where-Object { $_.Priority -eq "Medium" -and -not $_.Completed }).Count
        Low = ($TasksToDisplay | Where-Object { $_.Priority -eq "Low" -and -not $_.Completed }).Count
        Overdue = ($TasksToDisplay | Where-Object {
            (-not [string]::IsNullOrEmpty($_.DueDate)) -and ([datetime]::Parse($_.DueDate).Date -lt [datetime]::Today.Date) -and (-not $_.Completed)
        }).Count
        DueToday = ($TasksToDisplay | Where-Object {
            (-not [string]::IsNullOrEmpty($_.DueDate)) -and ([datetime]::Parse($_.DueDate).Date -eq [datetime]::Today.Date) -and (-not $_.Completed)
        }).Count
        InProgress = ($TasksToDisplay | Where-Object { $_.Progress -gt 0 -and $_.Progress -lt 100 -and (-not $_.Completed) }).Count
    }
   
    Write-Host "`n" ("=" * 70) -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
    $statLine = @("  ğŸ“Š Total: $($stats.Total)")
    $statLine += Apply-PSStyle -Text "âœ… Done: $($stats.Completed)" -FG (Get-ThemeProperty "Palette.SuccessFG")
    if ($stats.Critical -gt 0) { $statLine += Apply-PSStyle -Text "ğŸ”¥ Critical: $($stats.Critical)" -FG (Get-ThemeProperty "Palette.ErrorFG") }
    if ($stats.High -gt 0) { $statLine += Apply-PSStyle -Text "ğŸ”´ High: $($stats.High)" -FG (Get-ThemeProperty "Palette.ErrorFG") }
    if ($stats.Medium -gt 0) { $statLine += Apply-PSStyle -Text "ğŸŸ¡ Med: $($stats.Medium)" -FG (Get-ThemeProperty "Palette.WarningFG") }
    if ($stats.Low -gt 0) { $statLine += Apply-PSStyle -Text "ğŸŸ¢ Low: $($stats.Low)" -FG (Get-ThemeProperty "Palette.SuccessFG") }
    if ($stats.InProgress -gt 0) { $statLine += Apply-PSStyle -Text "ğŸ”„ In Progress: $($stats.InProgress)" -FG (Get-ThemeProperty "Palette.InfoFG") }
    if ($stats.DueToday -gt 0) { $statLine += Apply-PSStyle -Text "ğŸ“… Due Today: $($stats.DueToday)" -FG (Get-ThemeProperty "Palette.WarningFG") }
    if ($stats.Overdue -gt 0) { $statLine += Apply-PSStyle -Text "âš ï¸  Overdue: $($stats.Overdue)" -FG (Get-ThemeProperty "Palette.ErrorFG") }
   
    Write-Host ($statLine -join (" " + (Apply-PSStyle -Text "|" -FG (Get-ThemeProperty "Palette.SubtleFG")) + " "))
}
 
function global:Show-TaskManagementMenu {
    $filterString = ""
    $sortByOption = "Smart"
    $showCompletedTasks = $false
    $viewModeOption = "Default"
    
    while ($true) {
        Clear-Host
        Write-Header "Task Management"
       
        Show-TasksView -Filter $filterString -SortBy $sortByOption -ShowCompleted:$showCompletedTasks -View $viewModeOption
       
        Write-Host "`n" ("=" * 70) -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
        $statusLine = "ğŸ“ "
        if ($filterString) { $statusLine += Apply-PSStyle -Text "Filter: '$filterString' | " -FG (Get-ThemeProperty "Palette.InfoFG") }
        $statusLine += "Sort: $sortByOption | View: $viewModeOption | "
        $statusLine += if ($showCompletedTasks) { "Showing: All (inc. all completed)" } else { "Showing: Active / Recent Completed (last $($script:Data.Settings.ShowCompletedDays) days)" }
        Write-Host $statusLine
       
        Write-Host "`nActions: [A]dd, [C]omplete, [E]dit, [D]elete, [P]rogress, [ST]Subtasks"
        Write-Host "Display: [F]ilter, [S]ort, [V]iew Mode, [T]oggle Completed Visibility"
        Write-Host "Archive: View [AR]chived, [ARC]hive Now"
        Write-Host "Quick Entry: 'qa <task details>', 'c <id>', 'e <id>', 'd <id>'"
        Write-Host "`n[B] Back to Dashboard"
       
        $choice = Read-Host "`nCommand"
       
        if ($choice -match '^qa\s+(.+)') { Quick-AddTask -InputString $Matches[1]; continue }
        if ($choice -match '^([cde]|st|p)\s+(.+)') {
            $cmd = $Matches[1].ToLower(); $id = $Matches[2]
            switch ($cmd) {
                "c" { Complete-Task -TaskIdInput $id } "d" { Remove-Task -TaskIdInput $id }
                "e" { Edit-Task -TaskIdInput $id } "p" { Update-TaskProgress -TaskIdInput $id }
                "st" { Manage-Subtasks -TaskIdInput $id }
            }
            Write-Host "`nPress Enter to continue..." ; Read-Host; continue
        }
       
        $actionProcessed = $true
        switch ($choice.ToLower()) {
            "a" { Add-TodoTask } "c" { Complete-Task } "e" { Edit-Task } "d" { Remove-Task }
            "p" { Update-TaskProgress } "st" { Manage-Subtasks }
            "f" { $filterString = Read-Host "Filter (empty to clear)"; if ([string]::IsNullOrEmpty($filterString)) { $filterString = "" } }
            "s" {
                Write-Host "Sort by: [S]mart, [P]riority, [D]ue date, [C]reated, c[A]tegory, p[R]oject"
                $sortChoice = Read-Host "Choice"; $sortByOption = switch ($sortChoice.ToLower()) {
                    "p" { "Priority" } "d" { "DueDate" } "c" { "Created" } "a" { "Category" }
                    "r" { "Project" } default { "Smart" }
                }
            }
            "v" {
                Write-Host "View mode: [D]efault List, [K]anban, [T]imeline, [P]roject-grouped"
                $viewChoice = Read-Host "Choice"; $viewModeOption = switch ($viewChoice.ToLower()) {
                    "k" { "Kanban" } "t" { "Timeline" } "p" { "Project" } default { "Default" }
                }
            }
            "t" { $showCompletedTasks = -not $showCompletedTasks }
            "arc" { Archive-CompletedTasks } "ar" { View-TaskArchive }
            "b" { return }
            default {
                if (-not [string]::IsNullOrEmpty($choice)) { Write-Warning "Unknown command." }
                $actionProcessed = $false
            }
        }
        if ($actionProcessed -and $choice.ToLower() -ne "b") { Write-Host "`nPress Enter to continue..."; Read-Host }
    }
}
 
function global:Show-TaskAnalytics {
    Write-Header "Task Analytics"
 
    $allTasks = $script:Data.Tasks | Where-Object { $_.IsCommand -ne $true }
    if ($allTasks.Count -eq 0) { Write-Warning "No tasks available for analytics."; return }
 
    $completedTasks = $allTasks | Where-Object { $_.Completed }
    $activeTasks = $allTasks | Where-Object { -not $_.Completed }
   
    Write-Host "Overall:" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG"))
    Write-Host "  Total Tasks: $($allTasks.Count)"
    Write-Host "  Active Tasks: $(Apply-PSStyle -Text $activeTasks.Count -FG (Get-ThemeProperty "Palette.WarningFG"))"
    Write-Host "  Completed Tasks: $(Apply-PSStyle -Text $completedTasks.Count -FG (Get-ThemeProperty "Palette.SuccessFG"))"
 
    if ($allTasks.Count -gt 0) {
        $completionRate = [Math]::Round(($completedTasks.Count / $allTasks.Count) * 100, 1)
        Write-Host "  Completion Rate: $completionRate%"
        Draw-ProgressBar -Percent $completionRate -Width 40
    }
 
    $today = [DateTime]::Today.Date
    $startOfWeek = Get-WeekStart $today
    $startOfMonth = $today.AddDays(-($today.Day - 1))
 
    $completedThisWeek = $completedTasks | Where-Object { (-not [string]::IsNullOrEmpty($_.CompletedDate)) -and ([datetime]::Parse($_.CompletedDate).Date -ge $startOfWeek.Date) }
    $completedThisMonth = $completedTasks | Where-Object { (-not [string]::IsNullOrEmpty($_.CompletedDate)) -and ([datetime]::Parse($_.CompletedDate).Date -ge $startOfMonth.Date) }
 
    Write-Host "`nCompletion Trends:" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG"))
    Write-Host "  Completed this Week (since $($startOfWeek.ToString('MMM dd'))): $($completedThisWeek.Count)"
    Write-Host "  Completed this Month ($($startOfMonth.ToString('MMMM'))): $($completedThisMonth.Count)"
 
    Write-Host "`nActive Tasks by Priority:" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG"))
    $activeTasks | Group-Object Priority | Sort-Object @{Expression={@{"Critical"=1;"High"=2;"Medium"=3;"Low"=4}[$_.Name]}} | ForEach-Object {
        $priorityInfo = Get-PriorityInfo $_.Name
        Write-Host "  $(Apply-PSStyle -Text "$($priorityInfo.Icon) $($_.Name):" -FG $priorityInfo.Color) $($_.Count)"
    }
 
    Write-Host "`nActive Tasks by Category:" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG"))
    $activeTasks | Group-Object Category | Sort-Object Name | ForEach-Object {
        $catName = if ([string]::IsNullOrEmpty($_.Name)) {"[Uncategorized]"} else {$_.Name}
        Write-Host "  $catName $($_.Count)"
    }
   
    $overdueTasks = $activeTasks | Where-Object { (-not [string]::IsNullOrEmpty($_.DueDate)) -and ([datetime]::Parse($_.DueDate).Date -lt $today.Date) }
    if ($overdueTasks.Count -gt 0) {
        Write-Host "`nOverdue Tasks: $(Apply-PSStyle -Text $($overdueTasks.Count) -FG (Get-ThemeProperty "Palette.ErrorFG"))" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.ErrorFG"))
        $avgOverdueDays = $overdueTasks | ForEach-Object { ($today.Date - ([datetime]::Parse($_.DueDate).Date)).Days } | Measure-Object -Average
        if ($avgOverdueDays.Average -and $avgOverdueDays.Average -gt 0) {
            Write-Host "  Average Overdue by: $([Math]::Round($avgOverdueDays.Average,1)) days"
        }
    }

    Write-Host "`nEstimated vs. Spent Time (Completed Tasks):" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG"))
    $completedWithTime = $completedTasks | Where-Object {$_.TimeSpent -gt 0 -and $_.EstimatedTime -gt 0}
    if($completedWithTime.Count -gt 0){
        $totalEst = ($completedWithTime | Measure-Object EstimatedTime -Sum).Sum
        $totalSpent = ($completedWithTime | Measure-Object TimeSpent -Sum).Sum
        Write-Host "  Total Estimated (completed w/ time): $totalEst hours"
        Write-Host "  Total Spent (completed w/ time): $totalSpent hours"
        if($totalSpent -gt 0) {
            $overallEfficiency = [Math]::Round(($totalEst / $totalSpent) * 100, 1)
            Write-Host "  Overall Efficiency: $overallEfficiency%"
        }
    } else { Write-Host "  Not enough data for efficiency calculation."}
}

#endregion
```

---
### **File 6: `enhanced-selection.ps1`**
*This is the advanced selection module from `CURRENT`. It provides a rich, interactive list selection experience with arrow keys, searching, and details. It is used by the new architecture to handle all list-based selections.*

```powershell
# Enhanced Selection System
# Provides arrow key navigation, numbered lists, and visual highlighting for selections

function global:Show-EnhancedSelection {
    param(
        [Parameter(Mandatory=$true)]
        [array]$Items,                    # Array of items to select from
        [string]$Title = "Select Item",   # Title to display
        [string]$DisplayProperty = "",    # Property to display (for objects)
        [string]$ValueProperty = "",      # Property to return (for objects)
        [switch]$AllowMultiple,           # Allow multiple selections
        [switch]$ShowDetails,             # Show additional details
        [hashtable]$DetailProperties = @{}, # Properties to show as details
        [int]$PageSize = 15,              # Items per page
        [switch]$ReturnIndex              # Return index instead of item
    )
    
    if ($Items.Count -eq 0) {
        Write-Warning "No items to select from."
        return $null
    }
    
    # Initialize variables
    $selectedIndex = 0
    $selectedItems = @()
    $pageStart = 0
    $searchFilter = ""
    
    while ($true) {
        Clear-Host
        Write-Header $Title
        
        # Show search filter if active
        if ($searchFilter) {
            Write-Host "Filter: " -NoNewline -ForegroundColor Yellow
            Write-Host $searchFilter -ForegroundColor Cyan
            Write-Host ""
        }
        
        # Filter items based on search
        $filteredItems = if ($searchFilter) {
            $Items | Where-Object {
                $displayText = if ($DisplayProperty -and $_ -is [PSObject]) {
                    $_.$DisplayProperty
                } else {
                    $_.ToString()
                }
                $displayText -like "*$searchFilter*"
            }
        } else {
            $Items
        }
        
        if ($filteredItems.Count -eq 0) {
            Write-Host "  No items match the filter." -ForegroundColor Gray
            Write-Host "`n[ESC] Clear filter | [BACKSPACE] Edit filter"
            $key = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
            
            switch ($key.VirtualKeyCode) {
                27 { $searchFilter = ""; $selectedIndex = 0 } # ESC
                8 { # Backspace
                    if ($searchFilter.Length -gt 0) {
                        $searchFilter = $searchFilter.Substring(0, $searchFilter.Length - 1)
                    }
                }
            }
            continue
        }
        
        # Calculate page boundaries
        $totalItems = $filteredItems.Count
        $pageEnd = [Math]::Min($pageStart + $PageSize, $totalItems) - 1
        
        # Ensure selected index is within bounds
        if ($selectedIndex -ge $totalItems) {
            $selectedIndex = $totalItems - 1
        }
        
        # Adjust page if selected item is outside current page
        if ($selectedIndex -lt $pageStart) {
            $pageStart = $selectedIndex
            $pageEnd = [Math]::Min($pageStart + $PageSize, $totalItems) - 1
        }
        elseif ($selectedIndex -gt $pageEnd) {
            $pageEnd = $selectedIndex
            $pageStart = [Math]::Max(0, $pageEnd - $PageSize + 1)
        }
        
        # Display items
        for ($i = $pageStart; $i -le $pageEnd; $i++) {
            $item = $filteredItems[$i]
            $displayText = if ($DisplayProperty -and $item -is [PSObject]) {
                $item.$DisplayProperty
            } else {
                $item.ToString()
            }
            
            $quickKey = if ($i - $pageStart -lt 9) {
                ($i - $pageStart + 1).ToString()
            } elseif ($i - $pageStart -lt 35) {
                [char](97 + ($i - $pageStart - 9))
            } else {
                " "
            }
            
            if ($AllowMultiple) {
                $isSelected = $selectedItems -contains $i
                $indicator = if ($isSelected) { "[âœ“]" } else { "[ ]" }
                $indicatorColor = if ($isSelected) { "Green" } else { "DarkGray" }
                Write-Host "  " -NoNewline
                Write-Host $indicator -ForegroundColor $indicatorColor -NoNewline
            } else {
                $indicator = if ($i -eq $selectedIndex) { "â†’" } else { " " }
                $indicatorColor = if ($i -eq $selectedIndex) { "Cyan" } else { "DarkGray" }
                Write-Host " " -NoNewline
                Write-Host $indicator -ForegroundColor $indicatorColor -NoNewline
            }
            
            Write-Host " [$quickKey]" -ForegroundColor DarkCyan -NoNewline
            
            $itemColor = if ($i -eq $selectedIndex) { "White" } else { "Gray" }
            Write-Host " $displayText" -ForegroundColor $itemColor
            
            if ($ShowDetails -and $DetailProperties.Count -gt 0 -and $i -eq $selectedIndex) {
                foreach ($detailKey in $DetailProperties.Keys) {
                    $detailValue = if ($item -is [PSObject] -and $item.PSObject.Properties[$DetailProperties[$detailKey]]) {
                        $item.($DetailProperties[$detailKey])
                    } else { "" }
                    if ($detailValue) {
                        Write-Host "       $detailKey`: $detailValue" -ForegroundColor DarkGray
                    }
                }
            }
        }
        
        if ($totalItems -gt $PageSize) {
            Write-Host "`n  Page $([Math]::Floor($selectedIndex / $PageSize) + 1) of $([Math]::Ceiling($totalItems / $PageSize))" -ForegroundColor DarkGray
            Write-Host "  â†‘â†“ Navigate | PgUp/PgDn Change page" -ForegroundColor DarkGray
        }
        
        Write-Host "`nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" -ForegroundColor DarkGray
        
        if ($AllowMultiple) {
            Write-Host "  [SPACE] Toggle | [A] All | [N] None | [ENTER] Confirm | [ESC] Cancel" -ForegroundColor Yellow
        } else {
            Write-Host "  [ENTER] Select | [ESC] Cancel | [1-9,a-z] Quick select" -ForegroundColor Yellow
        }
        Write-Host "  [/] Search filter | [BACKSPACE] Clear character" -ForegroundColor DarkGray
        
        $key = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
        
        switch ($key.VirtualKeyCode) {
            38 { if ($selectedIndex -gt 0) { $selectedIndex-- } else { $selectedIndex = $totalItems - 1 } }
            40 { if ($selectedIndex -lt $totalItems - 1) { $selectedIndex++ } else { $selectedIndex = 0 } }
            33 { $selectedIndex = [Math]::Max(0, $selectedIndex - $PageSize) }
            34 { $selectedIndex = [Math]::Min($totalItems - 1, $selectedIndex + $PageSize) }
            36 { $selectedIndex = 0 }
            35 { $selectedIndex = $totalItems - 1 }
            32 { if ($AllowMultiple) { if ($selectedItems -contains $selectedIndex) { $selectedItems = $selectedItems | Where-Object { $_ -ne $selectedIndex } } else { $selectedItems += $selectedIndex } } }
            13 {
                if ($AllowMultiple) {
                    if ($selectedItems.Count -eq 0) { Write-Warning "`nNo items selected."; Start-Sleep -Seconds 1; continue }
                    $result = @(); foreach ($idx in $selectedItems) { $item = $filteredItems[$idx]; if ($ReturnIndex) { $result += $idx } elseif ($ValueProperty -and $item -is [PSObject]) { $result += $item.$ValueProperty } else { $result += $item } }; return $result
                } else {
                    $item = $filteredItems[$selectedIndex]; if ($ReturnIndex) { return $selectedIndex } elseif ($ValueProperty -and $item -is [PSObject]) { return $item.$ValueProperty } else { return $item }
                }
            }
            27 { if ($searchFilter) { $searchFilter = ""; $selectedIndex = 0 } else { return $null } }
            8 { if ($searchFilter.Length -gt 0) { $searchFilter = $searchFilter.Substring(0, $searchFilter.Length - 1) } }
            65 { if ($AllowMultiple -and $key.Character -eq 'a') { $selectedItems = 0..($totalItems - 1) } }
            78 { if ($AllowMultiple -and $key.Character -eq 'n') { $selectedItems = @() } }
            191 { $searchFilter = ""; Write-Host "`n  Start typing to filter..." -ForegroundColor Gray }
            default {
                if ($key.Character -ge '1' -and $key.Character -le '9') {
                    $quickIndex = [int]$key.Character.ToString() - 1 + $pageStart
                    if ($quickIndex -lt $totalItems) {
                        if ($AllowMultiple) { if ($selectedItems -contains $quickIndex) { $selectedItems = $selectedItems | Where-Object { $_ -ne $quickIndex } } else { $selectedItems += $quickIndex } }
                        else { $selectedIndex = $quickIndex; $item = $filteredItems[$selectedIndex]; if ($ReturnIndex) { return $selectedIndex } elseif ($ValueProperty -and $item -is [PSObject]) { return $item.$ValueProperty } else { return $item } }
                    }
                }
                elseif ($key.Character -ge 'a' -and $key.Character -le 'z') {
                    $quickIndex = [int]($key.Character) - [int]('a') + 9 + $pageStart
                    if ($quickIndex -lt $totalItems) {
                        if ($AllowMultiple) { if ($selectedItems -contains $quickIndex) { $selectedItems = $selectedItems | Where-Object { $_ -ne $quickIndex } } else { $selectedItems += $quickIndex } }
                        else { $selectedIndex = $quickIndex; $item = $filteredItems[$selectedIndex]; if ($ReturnIndex) { return $selectedIndex } elseif ($ValueProperty -and $item -is [PSObject]) { return $item.$ValueProperty } else { return $item } }
                    }
                }
                elseif ($key.Character -and -not [char]::IsControl($key.Character) -and $key.Character -ne "`0") {
                    $searchFilter += $key.Character
                }
            }
        }
    }
}

function global:Select-ProjectOrTemplate {
    param(
        [string]$Title = "Select Project or Template",
        [switch]$IncludeNone,
        [switch]$ProjectsOnly,
        [switch]$TemplatesOnly
    )
    
    $items = @()
    
    if ($IncludeNone) {
        $items += [PSCustomObject]@{ Key = $null; Name = "[None - No Project]"; Type = "None"; Client = ""; Status = "" }
    }
    
    if (-not $TemplatesOnly -and $script:Data.Projects -and $script:Data.Projects.Count -gt 0) {
        foreach ($proj in $script:Data.Projects.GetEnumerator() | Sort-Object {$_.Value.Name}) {
            $items += [PSCustomObject]@{ Key = $proj.Key; Name = "$($proj.Value.Name) [$($proj.Key)]"; Type = "Project"; Client = if ($proj.Value.Client) { $proj.Value.Client } else { "-" }; Status = $proj.Value.Status }
        }
    }
    
    if (-not $ProjectsOnly -and $script:Data.Settings.TimeTrackerTemplates -and $script:Data.Settings.TimeTrackerTemplates.Count -gt 0) {
        foreach ($tmpl in $script:Data.Settings.TimeTrackerTemplates.GetEnumerator()) {
            $items += [PSCustomObject]@{ Key = $tmpl.Key; Name = "$($tmpl.Value.Name) [$($tmpl.Key)]"; Type = "Template"; Client = if ($tmpl.Value.Client) { $tmpl.Value.Client } else { "-" }; Status = "Template" }
        }
    }
    
    if ($items.Count -eq 0) { Write-Warning "No projects or templates available."; return $null }
    
    return Show-EnhancedSelection -Items $items -Title $Title -DisplayProperty "Name" -ValueProperty "Key" -ShowDetails -DetailProperties @{ "Type" = "Type"; "Client" = "Client"; "Status" = "Status" }
}

function global:Select-Task {
    param(
        [string]$Title = "Select Task",
        [switch]$AllowMultiple,
        [switch]$ActiveOnly,
        [switch]$IncludeCompleted,
        [string]$ProjectFilter = ""
    )
    
    $tasks = $script:Data.Tasks | Where-Object { $_.IsCommand -ne $true }
    
    if ($ActiveOnly) {
        $tasks = $tasks | Where-Object { -not $_.Completed }
    } elseif (-not $IncludeCompleted) {
        $cutoffDate = [datetime]::Today.AddDays(-$script:Data.Settings.ShowCompletedDays)
        $tasks = $tasks | Where-Object { (-not $_.Completed) -or ((-not [string]::IsNullOrEmpty($_.CompletedDate)) -and ([datetime]::Parse($_.CompletedDate).Date -ge $cutoffDate.Date)) }
    }
    
    if ($ProjectFilter) {
        $tasks = $tasks | Where-Object { $_.ProjectKey -eq $ProjectFilter }
    }
    
    if ($tasks.Count -eq 0) { Write-Warning "No tasks available for selection."; return $null }
    
    $items = @()
    foreach ($task in $tasks | Sort-Object @{Expression={$_.Completed}}, @{Expression={Get-TaskStatus $_}}, Priority, Description) {
        $status = Get-TaskStatus $task
        $priorityInfo = Get-PriorityInfo $task.Priority
        $project = if ($task.ProjectKey) { Get-ProjectOrTemplate $task.ProjectKey } else { $null }
        $displayName = "$($priorityInfo.Icon) $($task.Description)"
        if ($task.Completed) { $displayName = "âœ“ $displayName" }
        
        $items += [PSCustomObject]@{ Id = $task.Id; DisplayName = $displayName; Status = $status; Priority = $task.Priority; Project = if ($project) { $project.Name } else { "-" }; Due = if ($task.DueDate) { Format-TodoDate $task.DueDate } else { "-" }; Progress = "$($task.Progress)%" }
    }
    
    return Show-EnhancedSelection -Items $items -Title $Title -DisplayProperty "DisplayName" -ValueProperty "Id" -AllowMultiple:$AllowMultiple -ShowDetails -DetailProperties @{ "Status" = "Status"; "Project" = "Project"; "Due" = "Due"; "Progress" = "Progress" }
}

function global:Get-EnhancedConfirmation {
    param(
        [string]$Message,
        [string]$Title = "Confirm",
        [switch]$DefaultNo
    )
    
    $options = @(
        [PSCustomObject]@{ Value = $true; Display = "Yes" },
        [PSCustomObject]@{ Value = $false; Display = "No" }
    )
    
    $defaultIndex = if ($DefaultNo) { 1 } else { 0 }
    
    Clear-Host
    Write-Header $Title
    Write-Host $Message -ForegroundColor Yellow
    Write-Host ""
    
    for ($i = 0; $i -lt $options.Count; $i++) {
        $indicator = if ($i -eq $defaultIndex) { "â†’" } else { " " }
        $color = if ($i -eq $defaultIndex) { "White" } else { "Gray" }
        Write-Host "$indicator [$($i + 1)] $($options[$i].Display)" -ForegroundColor $color
    }
    
    Write-Host "`n[ENTER] Select default | [Y/N] Quick select | [ESC] Cancel"
    
    $key = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
    
    switch ($key.VirtualKeyCode) {
        13 { return $options[$defaultIndex].Value } # Enter
        27 { return $false } # Escape
        89 { return $true }  # Y
        78 { return $false } # N
        49 { return $true }  # 1
        50 { return $false } # 2
        default { return $options[$defaultIndex].Value }
    }
}
```

---
### **File 7: `fb.ps1`**
*This is the terminal file browser from `CURRENT`. It has been reviewed to ensure it uses the new theme and helper functions correctly.*

```powershell
# Terminal File Browser for PowerShell

#region State Variables
$script:FB_CurrentPath = $null
$script:FB_SelectedItems = @{}
$script:FB_Clipboard = @{ Items = @(); Action = "Copy" }
$script:FB_SortBy = "Name"
$script:FB_ShowHidden = $false
$script:FB_ViewMode = "Details"
$script:FB_SelectedIndex = 0
#endregion

#region Main Entry Points

function global:Start-TerminalFileBrowser {
    [CmdletBinding()]
    param(
        [string]$Path = (Get-Location).Path,
        [switch]$SelectFileMode,
        [switch]$SelectFolderMode
    )
    
    $script:FB_CurrentPath = Get-Item -LiteralPath $Path
    $script:FB_SelectedItems = @{}
    $script:FB_SelectedIndex = 0

    $originalTitle = $Host.UI.RawUI.WindowTitle
    $Host.UI.RawUI.WindowTitle = "File Browser: $($script:FB_CurrentPath.FullName)"
    
    $result = $null
    try {
        if ($SelectFileMode -or $SelectFolderMode) {
            $result = FB_MainLoop -SelectFileMode:$SelectFileMode -SelectFolderMode:$SelectFolderMode
        } else {
            FB_MainLoop
        }
    }
    finally {
        $Host.UI.RawUI.WindowTitle = $originalTitle
    }
    return $result
}

function FB_MainLoop {
    param($SelectFileMode, $SelectFolderMode)

    while ($true) {
        $items = Get-ChildItem -LiteralPath $script:FB_CurrentPath.FullName -Force:$script:FB_ShowHidden -ErrorAction SilentlyContinue | FB_SortItems
        
        Clear-Host
        FB_ShowHeader -SelectMode:($SelectFileMode -or $SelectFolderMode)
        FB_ShowFileList -Items $items
        FB_ShowStatusBar -Items $items

        $action = FB_GetAction
        
        switch ($action.Type) {
            "Exit" { return $null }
            "Refresh" { continue }
            "Navigate" { $script:FB_CurrentPath = Get-Item -LiteralPath $action.Path; $script:FB_SelectedItems = @{}; $script:FB_SelectedIndex = 0 }
            "Open" {
                if ($SelectFileMode -and -not $action.Item.PSIsContainer) { return $action.Item.FullName }
                if ($SelectFolderMode -and $action.Item.PSIsContainer) { return $action.Item.FullName }
                if ($action.Item.PSIsContainer) { $script:FB_CurrentPath = $action.Item; $script:FB_SelectedItems = @{}; $script:FB_SelectedIndex = 0 }
                else { try { Start-Process -FilePath $action.Item.FullName } catch { Write-Warning "Could not open file: $_" } }
            }
            "ReturnPath" { return $action.Path }
            "Invoke" { & $action.Action; Start-Sleep -Milliseconds 500 } # Pause after action
        }
    }
}
#endregion

#region UI Display Functions

function FB_ShowHeader {
    param($SelectMode)
    $pathColor = Get-ThemeProperty 'Palette.WarningFG'
    Write-Header "File Browser"
    Write-Host " ğŸ“ Path: " -ForegroundColor (Get-LegacyColor $pathColor) -NoNewline
    Write-Host $script:FB_CurrentPath.FullName
    if($SelectMode) { Write-Host "`n ğŸ¯ SELECTION MODE: Press Enter on a file/folder to select and exit." -ForegroundColor (Get-LegacyColor (Get-ThemeProperty 'Palette.InfoFG'))}
}

function FB_ShowFileList {
    param($Items)
    switch ($script:FB_ViewMode) {
        "Details" { FB_ShowDetailView -Items $Items }
        default { FB_ShowDetailView -Items $Items }
    }
}

function FB_ShowDetailView {
    param ($Items)
    $headers = @(
        @{ T = " "; W = 1 }, # Selection
        @{ T = " "; W = 1 }, # Icon
        @{ T = "Name"; W = ($Host.UI.RawUI.WindowSize.Width - 48); Align = "Left" },
        @{ T = "Size"; W = 12; Align = "Right" },
        @{ T = "Modified"; W = 19; Align = "Left" }
    )
    $headerString = ""
    foreach ($h in $headers) { $headerString += "{0,-$($h.W)} " -f $h.T }
    Write-Host "`n$headerString" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty 'Palette.HeaderFG'))
    
    # Parent directory
    if ($script:FB_CurrentPath.Parent) {
        if ($script:FB_SelectedIndex -eq -1) { Write-Host ">" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty 'Palette.WarningFG')) -NoNewline } else { Write-Host " " -NoNewline }
        Write-Host " ğŸ“ .. " -ForegroundColor (Get-LegacyColor (Get-ThemeProperty 'Palette.AccentFG'))
    }

    for ($i = 0; $i -lt $Items.Count; $i++) {
        $item = $Items[$i]
        $isSelected = $script:FB_SelectedItems.ContainsKey($item.FullName)
        $isCurrent = ($i -eq $script:FB_SelectedIndex)

        if ($isCurrent) { Write-Host ">" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty 'Palette.WarningFG')) -NoNewline } else { Write-Host " " -NoNewline }
        if ($isSelected) { Write-Host "[âœ“] " -ForegroundColor (Get-LegacyColor (Get-ThemeProperty 'Palette.SuccessFG')) -NoNewline } else { Write-Host "[ ] " -NoNewline }
        
        $nameColor = if ($item.PSIsContainer) { Get-ThemeProperty 'Palette.InfoFG' } else { Get-ThemeProperty 'Palette.PrimaryFG' }
        $icon = if ($item.PSIsContainer) { "ğŸ“" } else { "ğŸ“„" }
        Write-Host "$icon " -NoNewline
        $name = if ($item.Name.Length -gt $headers[2].W - 3) { $item.Name.Substring(0, $headers[2].W - 3) + "..." } else { $item.Name }
        Write-Host ("{0,-$($headers[2].W - 2)}" -f $name) -ForegroundColor (Get-LegacyColor $nameColor) -NoNewline
        
        $size = if ($item.PSIsContainer) { "<DIR>" } else { "$([Math]::Round($item.Length / 1KB, 2)) KB" }
        Write-Host ("{0,12}" -f $size) -ForegroundColor (Get-LegacyColor (Get-ThemeProperty 'Palette.SubtleFG')) -NoNewline

        Write-Host "  $($item.LastWriteTime.ToString('yyyy-MM-dd HH:mm'))" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty 'Palette.SubtleFG'))
    }
}

function FB_ShowStatusBar {
    param ($Items)
    $width = $Host.UI.RawUI.WindowSize.Width
    Write-Host ("`n" + ("-" * $width)) -ForegroundColor (Get-LegacyColor (Get-ThemeProperty 'Palette.SubtleFG'))
    $status = " Items: $($Items.Count) | Selected: $($script:FB_SelectedItems.Count) | Clipboard: $($script:FB_Clipboard.Items.Count) | Sort: $($script:FB_SortBy) | Hidden: $($script:FB_ShowHidden)"
    Write-Host $status -ForegroundColor (Get-LegacyColor (Get-ThemeProperty 'Palette.SubtleFG'))
    Write-Host "[?] Help" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty 'Palette.WarningFG'))
}

#endregion

#region Actions and Logic

function FB_GetAction {
    $items = Get-ChildItem -LiteralPath $script:FB_CurrentPath.FullName -Force:$script:FB_ShowHidden -ErrorAction SilentlyContinue | FB_SortItems
    $key = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")

    switch ($key.VirtualKeyCode) {
        38 { if ($script:FB_SelectedIndex -gt 0) { $script:FB_SelectedIndex-- } elseif ($script:FB_CurrentPath.Parent) { $script:FB_SelectedIndex = -1 }; return @{ Type = "Refresh" } }
        40 { if ($script:FB_SelectedIndex -lt ($items.Count - 1)) { $script:FB_SelectedIndex++ }; return @{ Type = "Refresh" } }
        37 { if ($script:FB_CurrentPath.Parent) { return @{ Type = "Navigate"; Path = $script:FB_CurrentPath.Parent.FullName } }; return @{ Type = "Refresh" } }
        13 {
            if ($script:FB_SelectedIndex -eq -1 -and $script:FB_CurrentPath.Parent) { return @{ Type = "Navigate"; Path = $script:FB_CurrentPath.Parent.FullName } }
            if ($script:FB_SelectedIndex -ge 0 -and $script:FB_SelectedIndex -lt $items.Count) { return @{ Type = "Open"; Item = $items[$script:FB_SelectedIndex] } }
            return @{ Type = "Refresh" }
        }
        32 {
            if ($script:FB_SelectedIndex -ge 0 -and $script:FB_SelectedIndex -lt $items.Count) {
                $item = $items[$script:FB_SelectedIndex]; if ($script:FB_SelectedItems.ContainsKey($item.FullName)) { $script:FB_SelectedItems.Remove($item.FullName) } else { $script:FB_SelectedItems[$item.FullName] = $item }
            }
            if ($script:FB_SelectedIndex -lt ($items.Count - 1)) { $script:FB_SelectedIndex++ }
            return @{ Type = "Refresh" }
        }
    }

    switch ($key.Character.ToString().ToLower()) {
        "q" { return @{ Type = "Exit" } }
        "?" { return @{ Type = "Invoke"; Action = { FB_ShowHelp } } }
        "c" { return @{ Type = "Invoke"; Action = { FB_CopyItems -Items $items } } }
        "v" { return @{ Type = "Invoke"; Action = { FB_PasteItems } } }
        "n" { return @{ Type = "Invoke"; Action = { FB_NewItem } } }
        "d" { return @{ Type = "Invoke"; Action = { FB_DeleteItems -Items $items } } }
        "r" { return @{ Type = "Invoke"; Action = { FB_RenameItem -Items $items } } }
        "a" { return @{ Type = "Invoke"; Action = { foreach($item in $items) { $script:FB_SelectedItems[$item.FullName] = $item } } } }
        "s" { return @{ Type = "Invoke"; Action = { FB_ToggleSort } } }
        "h" { $script:FB_ShowHidden = -not $script:FB_ShowHidden; return @{ Type = "Refresh" } }
    }
    return @{ Type = "Refresh" }
}

function FB_CopyItems {
    param($Items)
    $selected = $script:FB_SelectedItems.Values
    if ($selected.Count -eq 0 -and $script:FB_SelectedIndex -ge 0) { $selected = @($Items[$script:FB_SelectedIndex]) }
    if ($selected.Count -gt 0) { $script:FB_Clipboard.Items = @($selected.FullName); Write-Info "Copied $($selected.Count) items." }
}

function FB_PasteItems {
    if ($script:FB_Clipboard.Items.Count -eq 0) { Write-Warning "Clipboard is empty."; return }
    foreach ($source in $script:FB_Clipboard.Items) {
        $dest = Join-Path $script:FB_CurrentPath.FullName (Split-Path $source -Leaf)
        try { Copy-Item -LiteralPath $source -Destination $dest -Recurse -Force; Write-Success "Pasted: $(Split-Path $source -Leaf)" }
        catch { Write-Error "Failed to paste $(Split-Path $source -Leaf): $_" }
    }
}

function FB_DeleteItems {
    param($Items)
    $selected = $script:FB_SelectedItems.Values
    if ($selected.Count -eq 0 -and $script:FB_SelectedIndex -ge 0) { $selected = @($Items[$script:FB_SelectedIndex]) }
    if ($selected.Count -gt 0) {
        Write-Warning "Permanently delete $($selected.Count) items?"; if ((Read-Host "Type 'yes' to confirm").ToLower() -eq 'yes') {
            foreach ($item in $selected) {
                try { Remove-Item -LiteralPath $item.FullName -Recurse -Force; Write-Success "Deleted: $($item.Name)" }
                catch { Write-Error "Failed to delete $($item.Name): $_" }
            }
            $script:FB_SelectedItems.Clear()
        }
    }
}

function FB_RenameItem {
    param($Items)
    if ($script:FB_SelectedIndex -ge 0) {
        $item = $Items[$script:FB_SelectedIndex]
        $newName = Read-Host "Rename '$($item.Name)' to"
        if (-not [string]::IsNullOrWhiteSpace($newName)) {
            try { Rename-Item -LiteralPath $item.FullName -NewName $newName; Write-Success "Renamed." } catch { Write-Error "Rename failed: $_" }
        }
    }
}

function FB_NewItem {
    $type = Read-Host "[F]ile or [D]irectory?"
    $name = Read-Host "Name?"
    if ([string]::IsNullOrWhiteSpace($name)) { return }
    $path = Join-Path $script:FB_CurrentPath.FullName $name
    $itemType = if ($type.ToLower() -eq 'd') { "Directory" } else { "File" }
    try { New-Item -Path $path -ItemType $itemType | Out-Null; Write-Success "Created $itemType '$name'." } catch { Write-Error "Failed to create: $_" }
}

function FB_ToggleSort {
    $sortOptions = @("Name", "Date", "Size", "Type")
    $current = $sortOptions.IndexOf($script:FB_SortBy)
    $next = ($current + 1) % $sortOptions.Count
    $script:FB_SortBy = $sortOptions[$next]
}

function FB_SortItems {
    param([object[]]$Items)
    switch ($script:FB_SortBy) {
        "Name" { return $Items | Sort-Object PSIsContainer -Descending, Name }
        "Date" { return $Items | Sort-Object PSIsContainer -Descending, @{Expression="LastWriteTime"; Descending=$true} }
        "Size" { return $Items | Sort-Object PSIsContainer -Descending, @{Expression="Length"; Descending=$true} }
        "Type" { return $Items | Sort-Object PSIsContainer -Descending, Extension, Name }
    }
}

function FB_ShowHelp {
    Write-Header "File Browser Help"
    Write-Host @"
Key          Action
---          ------
â†‘/â†“          Navigate files and folders
â†            Go to parent directory
Enter        Open file or enter directory
Space        Select/Deselect the current item
a            Select all items in the current folder
c            Copy selected items to clipboard
v            Paste items from clipboard
d            Delete selected items (with confirmation)
r            Rename the current item
n            Create a new file or directory
s            Cycle through sort modes (Name, Date, Size, Type)
h            Toggle visibility of hidden files and folders
?            Show this help screen
q            Quit the file browser
"@
    Read-Host "`nPress Enter to continue..." | Out-Null
}

#endregion
```

---
### **File 8: `command-palette.ps1`**
*This is the command palette module from `CURRENT`. It provides a powerful, searchable command interface. It has been reviewed to ensure it uses the new theme and helper functions correctly.*

```powershell
# Command Palette System

# Command registry to store all discoverable commands
$script:CommandRegistry = @()

function global:Register-Command {
    param(
        [string]$Name,
        [string]$Description,
        [scriptblock]$Action,
        [string[]]$Tags = @(),
        [string]$Category = "General",
        [string[]]$Aliases = @(),
        [string]$KeyBinding = ""
    )
    
    $script:CommandRegistry += [PSCustomObject]@{
        Name = $Name; Description = $Description; Action = $Action; Tags = $Tags
        Category = $Category; Aliases = $Aliases; KeyBinding = $KeyBinding
        SearchText = "$Name $Description $($Tags -join ' ') $($Aliases -join ' ')"
    }
}

function global:Initialize-CommandRegistry {
    $script:CommandRegistry = @()
    Register-Command -Name "Add Manual Time Entry" -Description "Log time manually with project and description" -Action {Add-ManualTimeEntry} -Tags "time,log,manual" -Category "Time" -KeyBinding "M"
    Register-Command -Name "Start Timer" -Description "Start a timer for a project or task" -Action {Start-Timer} -Tags "timer,start,track" -Category "Time" -KeyBinding "S"
    Register-Command -Name "Stop Timer" -Description "Stop running timer(s) and log time" -Action {Stop-Timer} -Tags "timer,stop,finish" -Category "Time"
    Register-Command -Name "Add Task" -Description "Create a new task with full details" -Action {Add-TodoTask} -Tags "task,add,todo" -Category "Task" -KeyBinding "A"
    Register-Command -Name "Quick Add Task" -Description "Fast task entry with inline syntax" -Action {Quick-AddTask} -Tags "task,quick,add" -Category "Task" -Aliases "qa"
    Register-Command -Name "Complete Task" -Description "Mark a task as completed" -Action {Complete-Task} -Tags "task,complete,done" -Category "Task"
    Register-Command -Name "Today's Overview" -Description "Show today's summary of tasks, time, and timers" -Action {Show-TodayView} -Tags "today,overview,summary" -Category "Views" -KeyBinding "T"
    Register-Command -Name "Week Report" -Description "Display week timesheet report" -Action {Show-WeekReport} -Tags "week,report,timesheet" -Category "Reports" -KeyBinding "W"
    Register-Command -Name "Calendar View" -Description "Show monthly calendar with task indicators" -Action {Show-Calendar} -Tags "calendar,month,date" -Category "Views"
    Register-Command -Name "Add Project" -Description "Create a new project" -Action {Add-Project} -Tags "project,add,client" -Category "Project"
    Register-Command -Name "Project Details" -Description "View detailed project information" -Action {Show-ProjectDetail} -Tags "project,details,info" -Category "Project" -KeyBinding "P"
    Register-Command -Name "Manage Command Snippets" -Description "Access the command snippet manager" -Action {Manage-CommandSnippets} -Tags "command,snippet,script" -Category "Tools" -Aliases "cmd"
    Register-Command -Name "Backup Now" -Description "Create immediate backup of all data" -Action {Backup-Data} -Tags "backup,save,data" -Category "Data"
    Register-Command -Name "File Browser" -Description "Launch the interactive terminal file browser" -Action {Start-TerminalFileBrowser} -Tags "file,browser,explore" -Category "File Management" -Aliases "fb"
}

function global:Show-CommandPalette {
    param(
        [string]$InitialFilter = ""
    )
    if ($script:CommandRegistry.Count -eq 0) { Initialize-CommandRegistry }
    $filter = $InitialFilter; $selectedIndex = 0; $maxDisplay = 15
    while ($true) {
        Clear-Host
        Write-Host "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• COMMAND PALETTE â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.HeaderFG"))
        Write-Host "â•‘ Type to search | â†‘â†“ Navigate | Enter: Execute | Esc: Cancel â•‘" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
        Write-Host "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.HeaderFG"))
        Write-Host "`nSearch: " -NoNewline -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG")); Write-Host "$filter" -NoNewline; Write-Host "_" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG")); Write-Host ""
        
        $filtered = @()
        if ([string]::IsNullOrWhiteSpace($filter)) {
            $filtered = $script:CommandRegistry | Sort-Object Category, Name
        } else {
            $filterWords = $filter.ToLower().Split(' ', [System.StringSplitOptions]::RemoveEmptyEntries)
            foreach ($command in $script:CommandRegistry) {
                $score = 0
                $searchText = $command.SearchText.ToLower()
                
                $allWordsMatch = $true
                foreach ($word in $filterWords) {
                    if (-not $searchText.Contains($word)) {
                        $allWordsMatch = $false
                        break
                    }
                }

                if ($allWordsMatch) {
                    $score += 50 # Base score for matching all words
                    if ($command.Name.ToLower().StartsWith($filter.ToLower())) {
                        $score += 20 # Bonus for name starting with the full term
                    }
                    if ($searchText.Contains($filter.ToLower())) {
                        $score += 10 # Bonus for exact substring match
                    }
                    $command | Add-Member -NotePropertyName Score -NotePropertyValue $score -Force
                    $filtered += $command
                }
            }
            $filtered = $filtered | Sort-Object Score -Descending
        }
        if ($selectedIndex -ge $filtered.Count) { $selectedIndex = [Math]::Max(0, $filtered.Count - 1) }
        
        $startIndex = [Math]::Max(0, $selectedIndex - [Math]::Floor($maxDisplay / 2)); $endIndex = [Math]::Min($filtered.Count - 1, $startIndex + $maxDisplay - 1)
        if ($filtered.Count -eq 0) { Write-Host "`n  No commands match '$filter'" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")) }
        else {
            $displayItems = $filtered[$startIndex..$endIndex]
            for($i = 0; $i -lt $displayItems.Count; $i++) {
                $cmd = $displayItems[$i]
                $currentDisplayIndex = $startIndex + $i
                $isSelected = ($currentDisplayIndex -eq $selectedIndex)
                if ($isSelected) { Write-Host "  â†’ " -NoNewline -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.HeaderFG")) } else { Write-Host "    " -NoNewline }
                Write-Host "$($cmd.Name)" -NoNewline -ForegroundColor $(if ($isSelected) { "White" } else { "Gray" })
                if ($cmd.KeyBinding) { Write-Host " [$($cmd.KeyBinding)]" -NoNewline -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG")) }
                Write-Host ""; Write-Host "      $($cmd.Description)" -ForegroundColor $(if ($isSelected) { "Gray" } else { "DarkGray" })
            }
            if ($startIndex -gt 0) { Write-Host "`n  â†‘ More above..." -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")) }
            if ($endIndex -lt $filtered.Count - 1) { Write-Host "  â†“ More below..." -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")) }
        }
        
        $key = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
        switch ($key.VirtualKeyCode) {
            38 { $selectedIndex = [Math]::Max(0, $selectedIndex - 1) } # Up
            40 { $selectedIndex = [Math]::Min($filtered.Count - 1, $selectedIndex + 1) } # Down
            13 { if ($filtered.Count -gt 0 -and $selectedIndex -lt $filtered.Count) { $selected = $filtered[$selectedIndex]; Clear-Host; Write-Success "Executing: $($selected.Name)"; & $selected.Action; return $selected }; break } # Enter
            27 { return $null } # Escape
            8 { if ($filter.Length -gt 0) { $filter = $filter.Substring(0, $filter.Length - 1); $selectedIndex = 0 } } # Backspace
            default { 
                if ($key.Character -and -not [char]::IsControl($key.Character) -and $key.Character -ne "`0" -and $key.VirtualKeyCode -notin @(16,17,18,91)) { 
                    $filter += $key.Character; $selectedIndex = 0 
                } 
            }
        }
    }
}

function global:Invoke-CommandPalette {
    param([switch]$AsScreen)
    if ($AsScreen) {
        Set-CurrentScreen -ScreenDefinition @{
            Name = "CommandPaletteScreen"
            OnLoad = {
                Clear-Host
                $result = Show-CommandPalette
                if ($result) { Pause-And-Redisplay }
                else { Navigate-Back }
            }
            ProcessKeyPressOverride = { param($KeyInfo) # No-op, handled by Show-CommandPalette
            }
        }
    } else {
        $result = Show-CommandPalette
        if ($result) {
            Write-Host "`nCommand completed." -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
        } else {
            Write-Info "Command palette cancelled."
        }
    }
}

function global:Find-Commands {
    param([string]$SearchTerm)
    if ($script:CommandRegistry.Count -eq 0) { Initialize-CommandRegistry }
    $results = @()
    $filterWords = $SearchTerm.ToLower().Split(' ', [System.StringSplitOptions]::RemoveEmptyEntries)
    foreach ($command in $script:CommandRegistry) {
        $score = 0
        $searchText = $command.SearchText.ToLower()
        
        $allWordsMatch = $true
        foreach ($word in $filterWords) {
            if (-not $searchText.Contains($word)) {
                $allWordsMatch = $false
                break
            }
        }

        if ($allWordsMatch) {
            $score += 50
            if ($command.Name.ToLower().StartsWith($SearchTerm.ToLower())) { $score += 20 }
            if ($searchText.Contains($SearchTerm.ToLower())) { $score += 10 }
            $command | Add-Member -NotePropertyName Similarity -NotePropertyValue $score -Force
            $results += $command
        }
    }
    return $results | Sort-Object Similarity -Descending
}
```

---
### **File 9: `core-time.ps1`**
*This is a new module created to house all time-tracking-specific logic, keeping it separate from the main data module. It includes functions for timers and time entry.*

```powershell
# core-time.ps1 - Time Tracking Logic

function global:Add-ManualTimeEntry {
    Write-Header "Manual Time Entry"
    Show-ProjectsAndTemplates -Simple
    $projectKey = Read-Host "`nProject/Template Key"
    if (-not (Get-ProjectOrTemplate $projectKey)) {
        Write-Error "Invalid project or template key."
        return
    }
    $hoursInput = Read-Host "Hours (e.g., 1.5)"
    if (-not ([double]::TryParse($hoursInput, [ref]$hours))) {
        Write-Error "Invalid hours format."
        return
    }
    $dateInput = Read-Host "Date (YYYY-MM-DD, default: Today)"
    $date = if ([string]::IsNullOrWhiteSpace($dateInput)) { (Get-Date).ToString("yyyy-MM-dd") } else { $dateInput }
    $description = Read-Host "Description"
    
    $script:Data.TimeEntries += @{
        Date = $date
        ProjectKey = $projectKey
        Hours = $hours
        Description = $description
    }
    Save-UnifiedData
    Write-Success "Time entry added."
}

function global:Start-Timer {
    param([string]$ProjectKeyParam, [string]$TaskIdParam)
    Write-Header "Start Timer"
    $projectKey = $ProjectKeyParam
    if (-not $projectKey) {
        Show-ProjectsAndTemplates -Simple
        $projectKey = Read-Host "`nProject/Template Key"
    }
    if (-not (Get-ProjectOrTemplate $projectKey)) {
        Write-Error "Invalid project or template key."
        return
    }
    if ($script:Data.ActiveTimers.ContainsKey($projectKey)) {
        Write-Warning "A timer is already running for '$projectKey'."
        return
    }
    $script:Data.ActiveTimers[$projectKey] = @{
        StartTime = Get-Date
        TaskId = $TaskIdParam
    }
    Save-UnifiedData
    Write-Success "Timer started for '$projectKey'."
}

function global:Stop-Timer {
    Write-Header "Stop Timer"
    if ($script:Data.ActiveTimers.Count -eq 0) {
        Write-Info "No active timers to stop."
        return
    }
    
    $keys = @($script:Data.ActiveTimers.Keys)
    $options = $keys | ForEach-Object {
        $project = Get-ProjectOrTemplate $_
        "$($project.Name) ($_)"
    }
    $options += "Stop ALL Timers"
    
    $choice = Show-MenuSelection -Title "Select Timer to Stop" -Options $options
    if (-not $choice) { Write-Info "Stop timer cancelled."; return }
    
    if ($choice -eq "Stop ALL Timers") {
        foreach ($key in $keys) {
            Stop-SingleTimer -Key $key
        }
    } else {
        $keyToStop = ($choice -split ' ')[-1].Trim('()')
        Stop-SingleTimer -Key $keyToStop
    }
}

function global:Stop-SingleTimer {
    param([string]$Key, [switch]$Silent)
    
    $timer = $script:Data.ActiveTimers[$Key]
    if (-not $timer) { return }
    
    $endTime = Get-Date
    $elapsed = $endTime - $timer.StartTime
    $hours = [Math]::Round($elapsed.TotalHours, 2)
    
    if (-not $Silent) {
        $description = Read-Host "Description for this time entry"
        $script:Data.TimeEntries += @{
            Date = $endTime.ToString("yyyy-MM-dd")
            ProjectKey = $Key
            Hours = $hours
            Description = $description
        }
    } else {
         $script:Data.TimeEntries += @{
            Date = $endTime.ToString("yyyy-MM-dd")
            ProjectKey = $Key
            Hours = $hours
            Description = "Timer stopped on exit"
        }
    }
    
    # If linked to a task, update time spent
    if ($timer.TaskId) {
        $task = $script:Data.Tasks | Where-Object { $_.Id -eq $timer.TaskId } | Select-Object -First 1
        if ($task) {
            $task.TimeSpent = [double]$task.TimeSpent + $hours
        }
    }

    $script:Data.ActiveTimers.Remove($Key)
    Save-UnifiedData
    if (-not $Silent) { Write-Success "Timer for '$Key' stopped. Logged $hours hours." }
}

function global:Show-ActiveTimers {
    Write-Header "Active Timers"
    if ($script:Data.ActiveTimers.Count -eq 0) {
        Write-Info "No timers are currently running."
        return
    }
    foreach ($timerEnum in $script:Data.ActiveTimers.GetEnumerator()) {
        $project = Get-ProjectOrTemplate $timerEnum.Key
        $elapsed = (Get-Date) - $timerEnum.Value.StartTime
        Write-Host "  $($project.Name) ($($timerEnum.Key)) - $($elapsed.ToString('hh\:mm\:ss'))" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.InfoFG"))
    }
}

function global:Quick-TimeEntry {
    # Placeholder for future implementation
    Write-Warning "Quick Time Entry not yet implemented."
}

function global:Edit-TimeEntry {
    # Placeholder for future implementation
    Write-Warning "Edit Time Entry not yet implemented."
}

function global:Delete-TimeEntry {
    # Placeholder for future implementation
    Write-Warning "Delete Time Entry not yet implemented."
}

function global:Show-TodayTimeLog {
    # Placeholder for future implementation
    Write-Warning "Today's Full Time Log not yet implemented."
}

function global:Export-FormattedTimesheet {
    # Placeholder for future implementation
    Write-Warning "Export Formatted Timesheet not yet implemented."
}

function global:Show-WeekReport {
    # Placeholder for future implementation
    Write-Warning "Week Report not yet implemented."
}

function global:Show-ExtendedReport {
    # Placeholder for future implementation
    Write-Warning "Extended Week Report not yet implemented."
}

function global:Show-MonthSummary {
    # Placeholder for future implementation
    Write-Warning "Month Summary Report not yet implemented."
}

function global:Show-TimeAnalytics {
    # Placeholder for future implementation
    Write-Warning "Time Analytics not yet implemented."
}

function global:Export-AllData {
    # Placeholder for future implementation
    Write-Warning "Export All Data not yet implemented."
}

function global:Edit-TimeTrackingSettings {
    # Placeholder for future implementation
    Write-Warning "Edit Time Tracking Settings not yet implemented."
}
```