Of course. Here is the continuation of the `helper.ps1` file, followed by the remaining modules.

---
### **File 2: `helper.ps1` (Continuation)**

```powershell
    $script:Data.Settings = Get-DefaultSettings
    $Global:AppConfig = $script:Data.Settings
    Save-UnifiedData
    Write-Success "All settings have been reset to default. Please restart the application."
    $script:keepRunning = $false
}
#endregion
```

---
### **File 3: `theme.ps1`**
*This is the advanced theme module from `CURRENT`. It supports multiple named themes, hex colors, gradients, and visual effects. It is now the definitive theme engine for the application.*

```powershell
# Enhanced Theme System Module
# Advanced theming with gradients, effects, and visual styles

#region Theme Presets

$script:ThemePresets = @{
    "Cyberpunk" = @{
        Name = "Cyberpunk"
        Description = "Neon-lit dystopian future"
        Palette = @{
            PrimaryFG = "#FF00FF"; SecondaryFG = "#00FFFF"; AccentFG = "#FF1493"; SuccessFG = "#00FF00"; ErrorFG = "#FF0040";
            WarningFG = "#FFFF00"; InfoFG = "#00BFFF"; HeaderFG = "#FF00FF"; SubtleFG = "#8B008B"; Background = "#0D0D0D"
            DataTable = @{ Header = @{ FG = "#FF00FF"; BG = "#0D0D0D" }; DataRow = @{ FG = "#00FFFF"; BG = "#0D0D0D" }; AltRow = @{ FG = "#FF1493"; BG = "#1A1A1A" }; Border = "#FF00FF" }
        }
        Effects = @{ GlowEffect = $true; AnimatedText = $true; NeonBorders = $true }
    }
    "Matrix" = @{
        Name = "Matrix"
        Description = "Follow the white rabbit"
        Palette = @{
            PrimaryFG = "#00FF00"; SecondaryFG = "#008F00"; AccentFG = "#00FF00"; SuccessFG = "#00FF00"; ErrorFG = "#FF0000";
            WarningFG = "#FFFF00"; InfoFG = "#00FF00"; HeaderFG = "#00FF00"; SubtleFG = "#004F00"; Background = "#000000"
            DataTable = @{ Header = @{ FG = "#00FF00"; BG = "#000000" }; DataRow = @{ FG = "#00FF00"; BG = "#000000" }; AltRow = @{ FG = "#008F00"; BG = "#111111" }; Border = "#00FF00" }
        }
        Effects = @{ MatrixRain = $true; GreenGlow = $true; MonoChrome = $true }
    }
    "Synthwave" = @{
        Name = "Synthwave"
        Description = "80s retro-futuristic vibes"
        Palette = @{
            PrimaryFG = "#FF6EC7"; SecondaryFG = "#B967FF"; AccentFG = "#01CDFE"; SuccessFG = "#05FFA1"; ErrorFG = "#FF71CE";
            WarningFG = "#FFFB96"; InfoFG = "#01CDFE"; HeaderFG = "#FF6EC7"; SubtleFG = "#8B5A8F"; Background = "#1A0033"
            DataTable = @{ Header = @{ FG = "#FF6EC7"; BG = "#1A0033" }; DataRow = @{ FG = "#01CDFE"; BG = "#1A0033" }; AltRow = @{ FG = "#B967FF"; BG = "#2A0055" }; Border = "#01CDFE" }
        }
        Effects = @{ ChromaticAberration = $true; RetroGrid = $true; NeonGlow = $true }
    }
    "Nord" = @{
        Name = "Nord"
        Description = "Arctic, north-bluish clean and elegant"
        Palette = @{
            PrimaryFG = "#D8DEE9"; SecondaryFG = "#E5E9F0"; AccentFG = "#88C0D0"; SuccessFG = "#A3BE8C"; ErrorFG = "#BF616A";
            WarningFG = "#EBCB8B"; InfoFG = "#81A1C1"; HeaderFG = "#5E81AC"; SubtleFG = "#4C566A"; Background = "#2E3440"
            DataTable = @{ Header = @{ FG = "#5E81AC"; BG = "#2E3440" }; DataRow = @{ FG = "#D8DEE9"; BG = "#2E3440" }; AltRow = @{ FG = "#E5E9F0"; BG = "#3B4252" }; Border = "#88C0D0" }
        }
        Effects = @{ SoftShadows = $true; MinimalBorders = $true; CleanDesign = $true }
    }
    "Dracula" = @{
        Name = "Dracula"
        Description = "Dark theme for the creatures of the night"
        Palette = @{
            PrimaryFG = "#F8F8F2"; SecondaryFG = "#6272A4"; AccentFG = "#BD93F9"; SuccessFG = "#50FA7B"; ErrorFG = "#FF5555";
            WarningFG = "#F1FA8C"; InfoFG = "#8BE9FD"; HeaderFG = "#FF79C6"; SubtleFG = "#44475A"; Background = "#282A36"
            DataTable = @{ Header = @{ FG = "#FF79C6"; BG = "#282A36" }; DataRow = @{ FG = "#F8F8F2"; BG = "#282A36" }; AltRow = @{ FG = "#6272A4"; BG = "#44475A" }; Border = "#BD93F9" }
        }
        Effects = @{ VampireMode = $true; PurpleAccents = $true; DarkContrast = $true }
    }
    "Legacy" = @{
        Name = "Legacy"
        Description = "Classic console colors for maximum compatibility"
        Palette = @{
            PrimaryFG = "White"; SecondaryFG = "Gray"; AccentFG = "Magenta"; SuccessFG = "Green"; ErrorFG = "Red";
            WarningFG = "Yellow"; InfoFG = "Blue"; HeaderFG = "Cyan"; SubtleFG = "DarkGray"; Background = "Black"
            DataTable = @{ Header = @{ FG = "Cyan"; BG = "Black" }; DataRow = @{ FG = "White"; BG = "Black" }; AltRow = @{ FG = "Gray"; BG = "Black" }; Border = "Cyan" }
        }
        Effects = @{ Bold = $false; Italic = $false; Underline = $false; Blink = $false }
    }
}

$script:CurrentTheme = $null

#endregion

#region Gradient Support

function global:Get-GradientText {
    param(
        [string]$Text,
        [string]$StartColor,
        [string]$EndColor,
        [switch]$Bold
    )
    
    if ($Text.Length -eq 0) { return "" }
    
    $startR = [Convert]::ToInt32($StartColor.Substring(1,2), 16)
    $startG = [Convert]::ToInt32($StartColor.Substring(3,2), 16)
    $startB = [Convert]::ToInt32($StartColor.Substring(5,2), 16)
    
    $endR = [Convert]::ToInt32($EndColor.Substring(1,2), 16)
    $endG = [Convert]::ToInt32($EndColor.Substring(3,2), 16)
    $endB = [Convert]::ToInt32($EndColor.Substring(5,2), 16)
    
    $result = ""
    $boldCode = if ($Bold) { "$($PSStyle.Bold)" } else { "" }
    
    for ($i = 0; $i -lt $Text.Length; $i++) {
        $progress = if ($Text.Length -gt 1) { $i / ($Text.Length - 1) } else { 0 }
        
        $r = [Math]::Round($startR + ($endR - $startR) * $progress)
        $g = [Math]::Round($startG + ($endG - $startG) * $progress)
        $b = [Math]::Round($startB + ($endB - $startB) * $progress)
        
        $result += "$boldCode$($PSStyle.Foreground.FromRgb($r,$g,$b))$($Text[$i])"
    }
    
    return $result + "$($PSStyle.Reset)"
}

#endregion

#region Visual Effects

function global:Show-TypewriterText {
    param(
        [string]$Text,
        [int]$Delay = 50,
        [string]$Color = "#FFFFFF"
    )
    
    foreach ($char in $Text.ToCharArray()) {
        Write-Host (Apply-PSStyle -Text $char -FG $Color) -NoNewline
        Start-Sleep -Milliseconds $Delay
    }
    Write-Host
}

function global:Show-GlowText {
    param(
        [string]$Text,
        [string]$GlowColor = "#00FFFF",
        [int]$GlowIntensity = 3
    )
    
    $r = [Convert]::ToInt32($GlowColor.Substring(1,2), 16)
    $g = [Convert]::ToInt32($GlowColor.Substring(3,2), 16)
    $b = [Convert]::ToInt32($GlowColor.Substring(5,2), 16)
    
    for ($i = $GlowIntensity; $i -gt 0; $i--) {
        $intensity = 0.3 * ($i / $GlowIntensity)
        $dimR = [Math]::Round($r * $intensity)
        $dimG = [Math]::Round($g * $intensity)
        $dimB = [Math]::Round($b * $intensity)
        
        $glowLayer = "$($PSStyle.Foreground.FromRgb($dimR,$dimG,$dimB))"
        Write-Host "${glowLayer}$Text$($PSStyle.Reset)"
    }
    
    Write-Host (Apply-PSStyle -Text $Text -FG $GlowColor -Bold)
}

function global:Show-MatrixRain {
    param(
        [int]$Duration = 5,
        [int]$Columns = 10
    )
    
    $chars = "ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐﾑﾒﾓﾔﾕﾖﾗﾘﾙﾚﾛﾜﾝ0123456789".ToCharArray()
    $rain = @{}
    
    for ($i = 0; $i -lt $Columns; $i++) {
        $rain[$i] = @{
            Position = Get-Random -Minimum 0 -Maximum 20
            Speed = Get-Random -Minimum 1 -Maximum 3
        }
    }
    
    $endTime = (Get-Date).AddSeconds($Duration)
    
    while ((Get-Date) -lt $endTime) {
        Clear-Host
        
        for ($row = 0; $row -lt 20; $row++) {
            for ($col = 0; $col -lt $Columns; $col++) {
                if ($rain[$col].Position -eq $row) {
                    $char = $chars | Get-Random
                    Write-Host (Apply-PSStyle -Text $char -FG "#00FF00" -Bold) -NoNewline
                } elseif ($rain[$col].Position - 1 -eq $row) {
                    $char = $chars | Get-Random
                    Write-Host (Apply-PSStyle -Text $char -FG "#00AA00") -NoNewline
                } elseif ($rain[$col].Position - 2 -eq $row) {
                    $char = $chars | Get-Random
                    Write-Host (Apply-PSStyle -Text $char -FG "#005500") -NoNewline
                } else {
                    Write-Host " " -NoNewline
                }
                Write-Host " " -NoNewline
            }
            Write-Host
        }
        
        foreach ($col in $rain.Keys) {
            $rain[$col].Position += $rain[$col].Speed
            if ($rain[$col].Position -gt 25) {
                $rain[$col].Position = -2
                $rain[$col].Speed = Get-Random -Minimum 1 -Maximum 3
            }
        }
        
        Start-Sleep -Milliseconds 100
    }
}

#endregion

#region Theme System Functions

function global:Initialize-ThemeSystem {
    $defaultThemeName = "Legacy"
    try {
        if ($PSVersionTable.PSVersion.Major -ge 7) { $defaultThemeName = "Cyberpunk" }
        elseif ($env:WT_SESSION -or $env:TERM_PROGRAM -eq "vscode") { $defaultThemeName = "Nord" }
    } catch { $defaultThemeName = "Legacy" }
    
    $themeName = $defaultThemeName
    if ($script:Data -and $script:Data.Settings -and $script:Data.Settings.CurrentTheme) { 
        $themeName = $script:Data.Settings.CurrentTheme
    }
    
    Apply-Theme -ThemeName $themeName
}

function global:Apply-Theme {
    param(
        [string]$ThemeName
    )
    
    if (-not $script:ThemePresets.ContainsKey($ThemeName)) {
        Write-Warning "Theme '$ThemeName' not found. Available themes: $($script:ThemePresets.Keys -join ', '). Using Legacy."
        $ThemeName = "Legacy"
    }
    
    $script:CurrentTheme = $script:ThemePresets[$ThemeName]
    
    if ($script:CurrentTheme.Effects.MatrixRain) {
        Write-Host "`nActivating Matrix mode..." -ForegroundColor Green
        Show-MatrixRain -Duration 2 -Columns 20
    }
    
    if ($script:CurrentTheme.Effects.NeonGlow) {
        Show-GlowText -Text "Theme '$ThemeName' Activated!" -GlowColor $script:CurrentTheme.Palette.AccentFG
    } else {
        Write-Success "Theme '$ThemeName' applied successfully!"
    }
    
    if ($script:Data -and $script:Data.Settings) {
        $script:Data.Settings.Theme = @{
            Header = Get-LegacyColor $script:CurrentTheme.Palette.HeaderFG
            Success = Get-LegacyColor $script:CurrentTheme.Palette.SuccessFG
            Warning = Get-LegacyColor $script:CurrentTheme.Palette.WarningFG
            Error = Get-LegacyColor $script:CurrentTheme.Palette.ErrorFG
            Info = Get-LegacyColor $script:CurrentTheme.Palette.InfoFG
            Accent = Get-LegacyColor $script:CurrentTheme.Palette.AccentFG
            Subtle = Get-LegacyColor $script:CurrentTheme.Palette.SubtleFG
        }
        
        $script:Data.Settings.CurrentTheme = $ThemeName
        Save-UnifiedData
    }
}

function global:Get-ThemeProperty {
    param([string]$Path)
    
    if (-not $script:CurrentTheme) {
        switch ($Path) {
            "Palette.HeaderFG" { return "Cyan" }; "Palette.SuccessFG" { return "Green" }; "Palette.ErrorFG" { return "Red" }
            "Palette.WarningFG" { return "Yellow" }; "Palette.InfoFG" { return "Blue" }; "Palette.AccentFG" { return "Magenta" }
            "Palette.SubtleFG" { return "DarkGray" }; "Palette.PrimaryFG" { return "White" }; "Palette.SecondaryFG" { return "Gray" }
            "DataTable.Header.FG" { return "Cyan" }; "DataTable.DataRow.FG" { return "White" }; "DataTable.AltRow.FG" { return "Gray" }
            "DataTable.DataRow.BG" { return $null }; "DataTable.AltRow.BG" { return $null }; default { return "White" }
        }
    }
    
    $parts = $Path -split '\.'
    $current = $script:CurrentTheme
    
    foreach ($part in $parts) {
        if ($current -is [hashtable] -and $current.ContainsKey($part)) {
            $current = $current[$part]
        } else {
            return "White"
        }
    }
    
    return $current
}

function global:Get-LegacyColor {
    param([string]$Color)
    
    if ($Color -in [System.Enum]::GetNames([System.ConsoleColor])) { return $Color }

    if ($Color -match '^#[0-9A-Fa-f]{6}$') {
        $colorMappings = @{
            '#FF0000' = 'Red'; '#DC143C' = 'Red'; '#FF6347' = 'Red'; '#FF0040' = 'Red'; '#FF5555' = 'Red'; '#FF71CE' = 'Red'; '#BF616A' = 'Red'
            '#00FF00' = 'Green'; '#39FF14' = 'Green'; '#32CD32' = 'Green'; '#228B22' = 'Green'; '#05FFA1' = 'Green'; '#50FA7B' = 'Green'; '#A3BE8C' = 'Green'
            '#00FFFF' = 'Cyan'; '#1E90FF' = 'Blue'; '#4169E1' = 'Blue'; '#4682B4' = 'Blue'; '#00BFFF' = 'Blue'; '#01CDFE' = 'Cyan'; '#8BE9FD' = 'Cyan'; '#81A1C1' = 'Blue'; '#88C0D0' = 'Cyan'; '#5E81AC' = 'Blue'
            '#FFFF00' = 'Yellow'; '#FFD700' = 'Yellow'; '#FF8C00' = 'Yellow'; '#FF6D00' = 'Yellow'; '#FFFB96' = 'Yellow'; '#F1FA8C' = 'Yellow'; '#EBCB8B' = 'Yellow'
            '#FF1493' = 'Magenta'; '#FF00FF' = 'Magenta'; '#BD93F9' = 'Magenta'; '#B967FF' = 'Magenta'; '#FF6EC7' = 'Magenta'; '#FF79C6' = 'Magenta'
            '#808080' = 'Gray'; '#666666' = 'DarkGray'; '#708090' = 'DarkGray'; '#696969' = 'DarkGray'; '#8B008B' = 'DarkMagenta'; '#4C566A' = 'DarkGray'; '#44475A' = 'DarkGray'; '#6272A4' = 'DarkGray'
            '#FFFFFF' = 'White'; '#E0F6FF' = 'White'; '#F5DEB3' = 'White'; '#F8F8F2' = 'White'; '#D8DEE9' = 'White'; '#E5E9F0' = 'White'; '#87CEEB' = 'Gray'; '#DEB887' = 'Gray'
        }
        if ($colorMappings.ContainsKey($Color.ToUpper())) { return $colorMappings[$Color.ToUpper()] } else { return 'White' }
    }
    
    return 'White'
}

function global:Apply-PSStyle {
    param(
        [string]$Text,
        [string]$FG,
        [string]$BG,
        [switch]$Bold,
        [switch]$Italic,
        [switch]$Underline,
        [switch]$Blink
    )
    
    if ($PSVersionTable.PSVersion.Major -ge 7 -and $script:CurrentTheme.Name -ne "Legacy") {
        try {
            $styledText = $Text
            if ($FG -and $FG -match '^#[0-9A-Fa-f]{6}$') { $styledText = "$($PSStyle.Foreground.FromRgb($FG.Substring(1)))$styledText" }
            if ($BG -and $BG -match '^#[0-9A-Fa-f]{6}$') { $styledText = "$($PSStyle.Background.FromRgb($BG.Substring(1)))$styledText" }
            if ($Bold) { $styledText = "$($PSStyle.Bold)$styledText" }
            if ($Italic) { $styledText = "$($PSStyle.Italic)$styledText" }
            if ($Underline) { $styledText = "$($PSStyle.Underline)$styledText" }
            if ($Blink) { $styledText = "$($PSStyle.Blink)$styledText" }
            return "$styledText$($PSStyle.Reset)"
        } catch { return $Text }
    } else { return $Text }
}

#endregion

#region Legacy Support Functions

function global:Write-Header {
    param([string]$Text)
    $headerColor = Get-LegacyColor (Get-ThemeProperty "Palette.HeaderFG")
    Write-Host "`n$Text" -ForegroundColor $headerColor
    Write-Host ("=" * $Text.Length) -ForegroundColor $headerColor
}

function global:Write-Success {
    param([string]$Text)
    $successColor = Get-LegacyColor (Get-ThemeProperty "Palette.SuccessFG")
    Write-Host "✓ $Text" -ForegroundColor $successColor
}

function global:Write-Warning {
    param([string]$Text)
    $warningColor = Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG")
    Write-Host "⚠ $Text" -ForegroundColor $warningColor
}

function global:Write-Error {
    param([string]$Text)
    $errorColor = Get-LegacyColor (Get-ThemeProperty "Palette.ErrorFG")
    Write-Host "✗ $Text" -ForegroundColor $errorColor
}

function global:Write-Info {
    param([string]$Text)
    $infoColor = Get-LegacyColor (Get-ThemeProperty "Palette.InfoFG")
    Write-Host "ℹ $Text" -ForegroundColor $infoColor
}

#endregion

#region Theme Management UI

function global:Edit-ThemeSettings {
    Write-Header "Theme & Appearance Settings"
    
    if (-not $script:Data.Settings.Theme) {
        $script:Data.Settings.Theme = @{ Header = "Cyan"; Success = "Green"; Warning = "Yellow"; Error = "Red"; Info = "Blue"; Accent = "Magenta"; Subtle = "DarkGray" }
    }
    
    Write-Host "Current Theme: $($script:CurrentTheme.Name)" -ForegroundColor Yellow
    Write-Host "`nTheme Management Options:" -ForegroundColor Yellow
    Write-Host "[1] Change Theme"; Write-Host "[2] Test Current Theme"; Write-Host "[3] Reset to Default Theme (Legacy)"; Write-Host "[4] View Theme Details"; Write-Host "[B] Back"
    
    $choice = Read-Host "`nChoice"
    
    switch ($choice.ToUpper()) {
        "1" { Show-ThemeSelector }
        "2" { Test-CurrentTheme }
        "3" { Apply-Theme -ThemeName "Legacy" }
        "4" { Show-ThemeDetails }
        "B" { return }
        default { Write-Warning "Invalid choice." }
    }
    
    Save-UnifiedData
}

function global:Show-ThemeSelector {
    Write-Header "Theme Selection"
    
    Write-Host "Available Themes:" -ForegroundColor Yellow
    $themeNames = $script:ThemePresets.Keys | Sort-Object
    
    for ($i = 0; $i -lt $themeNames.Count; $i++) {
        $themeName = $themeNames[$i]
        $theme = $script:ThemePresets[$themeName]
        $current = if ($script:CurrentTheme.Name -eq $themeName) { " (Current)" } else { "" }
        Write-Host "  [$($i + 1)] $themeName$current" -ForegroundColor (Get-LegacyColor $theme.Palette.AccentFG)
        Write-Host "      $($theme.Description)" -ForegroundColor DarkGray
    }
    
    Write-Host "`n[B] Back" -ForegroundColor Yellow
    
    $choice = Read-Host "`nSelect theme number or option"
    
    if ($choice.ToUpper() -eq 'B') { return }
    elseif ($choice -match '^\d+$') {
        $index = [int]$choice - 1
        if ($index -ge 0 -and $index -lt $themeNames.Count) {
            Apply-Theme -ThemeName $themeNames[$index]
            Test-CurrentTheme
        } else { Write-Warning "Invalid selection." }
    } else { Write-Warning "Invalid choice." }
}

function global:Test-CurrentTheme {
    Write-Header "Theme Test - $($script:CurrentTheme.Name)"
    
    Write-Host "Primary Text" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.PrimaryFG"))
    Write-Host "Secondary Text" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SecondaryFG"))
    Write-Host "Accent Text" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.AccentFG"))
    Write-Host ""
    
    Write-Success "Success message"; Write-Error "Error message"; Write-Warning "Warning message"; Write-Info "Info message"
    
    Write-Host "`nSample Table:" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.HeaderFG"))
    
    $sampleData = @(
        [PSCustomObject]@{ Name = "Project Alpha"; Status = "Active"; Progress = 75 }
        [PSCustomObject]@{ Name = "Project Beta"; Status = "Completed"; Progress = 100 }
        [PSCustomObject]@{ Name = "Project Gamma"; Status = "Pending"; Progress = 25 }
    )
    
    $sampleData | Format-TableUnicode -Title "Sample Projects"
    
    Write-Host "`nPress any key to continue..." -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
}

function global:Show-ThemeDetails {
    Write-Header "Theme Details - $($script:CurrentTheme.Name)"
    
    Write-Host $script:CurrentTheme.Description -ForegroundColor Gray
    Write-Host "`nColor Palette:" -ForegroundColor Yellow
    
    foreach ($colorKey in $script:CurrentTheme.Palette.Keys) {
        if ($colorKey -ne "DataTable") {
            $color = $script:CurrentTheme.Palette[$colorKey]
            $legacyColor = Get-LegacyColor $color
            Write-Host "  $colorKey`: $color" -ForegroundColor $legacyColor
        }
    }
    
    Write-Host "`nEffects:" -ForegroundColor Yellow
    foreach ($effectKey in $script:CurrentTheme.Effects.Keys) {
        $enabled = if ($script:CurrentTheme.Effects[$effectKey]) { "Enabled" } else { "Disabled" }
        Write-Host "  $effectKey`: $enabled"
    }
    
    Write-Host "`nPress any key to continue..." -ForegroundColor DarkGray
    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
}

#endregion
```

---
### **File 4: `ui.ps1`**
*This is the UI module. It combines the advanced TUI engine from `NEW` with the visually rich components from `CURRENT`. Functions like `Show-AnimatedHeader` and `Show-StatusCards` are now implemented as "Views" that are rendered to the back buffer, making them compatible with the new architecture.*

```powershell
# Enhanced UI Components Module
# TUI Engine, Tables, menus, borders, and display functions

#region TUI Engine (Buffer Management)
function global:New-ConsoleCell {
    param( [char]$Character = ' ', [string]$FG_Ansi = '39', [string]$BG_Ansi = '49' )
    return @{ Char = $Character; FG_Ansi = $FG_Ansi; BG_Ansi = $BG_Ansi }
}

function global:New-ConsoleBufferInternal {
    param([int]$Width, [int]$Height)
    Write-AppLog "Creating new buffer array: ${Width}x${Height}" "TRACE"
    $grid = @()
    for ($y = 0; $y -lt $Height; $y++) {
        $row = @()
        for ($x = 0; $x -lt $Width; $x++) { $row += New-ConsoleCell }
        $grid += ,$row
    }
    return $grid
}

function global:Initialize-ConsoleBuffers {
    param([int]$Width, [int]$Height)
    Write-AppLog "Initializing console buffers: ${Width}x${Height}" "DEBUG"
    $script:FrontBuffer = New-ConsoleBufferInternal -Width $Width -Height $Height
    $script:BackBuffer = New-ConsoleBufferInternal -Width $Width -Height $Height
    $script:BufferWidth = $Width
    $script:BufferHeight = $Height
}

function global:Clear-BackBuffer {
    if ($null -eq $script:BackBuffer) { Write-Warning "Back buffer is not initialized."; return }
    $defaultCell = New-ConsoleCell
    $defaultCell.FG_Ansi = Get-AnsiCode (Get-ThemeProperty "Palette.PrimaryFG")
    $defaultCell.BG_Ansi = Get-AnsiCode (Get-ThemeProperty "Palette.Background") '49'
    for ($y = 0; $y -lt $script:BufferHeight; $y++) {
        for ($x = 0; $x -lt $script:BufferWidth; $x++) {
            $script:BackBuffer[$y][$x] = $defaultCell.Clone()
        }
    }
}

function global:Write-CellToBuffer {
    param( [int]$X, [int]$Y, [hashtable]$Cell, [hashtable]$ClippingView = $null )
    if ($Y -lt 0 -or $Y -ge $script:BufferHeight -or $X -lt 0 -or $X -ge $script:BufferWidth) { return }
    if ($ClippingView) {
        if ($X -lt $ClippingView.X -or $X -ge ($ClippingView.X + $ClippingView.Width) -or $Y -lt $ClippingView.Y -or $Y -ge ($ClippingView.Y + $ClippingView.Height)) {
            return
        }
    }
    $targetCell = @{ Char = $Cell.Char ?? ' '; FG_Ansi = $Cell.FG_Ansi ?? "39"; BG_Ansi = $Cell.BG_Ansi ?? "49" }
    $script:BackBuffer[$Y][$X] = $targetCell
}

function global:Write-StringToBuffer {
    param( [int]$TargetX, [int]$TargetY, [string]$Text, [string]$FG_Ansi = "39", [string]$BG_Ansi = "49", [hashtable]$ClippingView = $null )
    if ($TargetY -lt 0 -or $TargetY -ge $script:BufferHeight) { return }
    $currentX = $TargetX
    foreach ($char in $Text.ToCharArray()) {
        if ($currentX -ge $script:BufferWidth) { break }
        if ($currentX -ge 0) {
            $cell = @{ Char = $char; FG_Ansi = $FG_Ansi; BG_Ansi = $BG_Ansi }
            Write-CellToBuffer -X $currentX -Y $TargetY -Cell $cell -ClippingView $ClippingView
        }
        $currentX++
    }
}

function global:Show-PmcCurrentScreen {
    $currentScreen = Get-CurrentScreen
    if (-not $currentScreen) { return }

    Clear-BackBuffer
    
    foreach ($viewDef in $currentScreen.Views) {
        $renderFunctionName = "Render-$($viewDef.Type)"
        if (Get-Command $renderFunctionName -ErrorAction SilentlyContinue) {
            & $renderFunctionName -ViewDefinition $viewDef
        } else {
            Write-AppLog "Renderer '$renderFunctionName' not found for view '$($viewDef.Name)'" "WARN"
        }
    }

    Show-PmcConsoleBuffer
}

function global:Show-PmcConsoleBuffer {
    Write-AppLog "Show-PmcConsoleBuffer: Starting presentation." "TRACE"
    $output = [System.Text.StringBuilder]::new(16384)
    $currentTerminalState = @{ FG_Ansi = "39"; BG_Ansi = "49" }
    
    for ($y = 0; $y -lt $script:BufferHeight; $y++) {
        $needsMove = $true
        for ($x = 0; $x -lt $script:BufferWidth; $x++) {
            $backCell = $script:BackBuffer[$y][$x]
            $frontCell = $script:FrontBuffer[$y][$x]
            $isDifferent = ($backCell.Char -ne $frontCell.Char) -or ($backCell.FG_Ansi -ne $frontCell.FG_Ansi) -or ($backCell.BG_Ansi -ne $frontCell.BG_Ansi)
            
            if ($isDifferent) {
                if ($needsMove) { $output.Append("`e[$($y + 1);$($x + 1)H") | Out-Null; $needsMove = $false }
                
                if ($backCell.FG_Ansi -ne $currentTerminalState.FG_Ansi) { $output.Append("`e[$($backCell.FG_Ansi)m") | Out-Null; $currentTerminalState.FG_Ansi = $backCell.FG_Ansi }
                if ($backCell.BG_Ansi -ne $currentTerminalState.BG_Ansi) { $output.Append("`e[$($backCell.BG_Ansi)m") | Out-Null; $currentTerminalState.BG_Ansi = $backCell.BG_Ansi }
                
                $output.Append($backCell.Char) | Out-Null
                $script:FrontBuffer[$y][$x] = $backCell.Clone()
            } else {
                $needsMove = $true
            }
        }
    }
    
    if ($currentTerminalState.FG_Ansi -ne '39' -or $currentTerminalState.BG_Ansi -ne '49') { 
        $output.Append("`e[0m") | Out-Null
    }
    
    if ($output.Length -gt 0) {
        Write-Host $output.ToString() -NoNewline
    }
}
#endregion

#region View Renderers
function global:Render-AnimatedHeaderView {
    param([hashtable]$ViewDefinition)
    $x = $ViewDefinition.X; $y = $ViewDefinition.Y; $width = $ViewDefinition.Width; $height = $ViewDefinition.Height
    
    $headerLines = @(
        "╔═══════════════════════════════════════════════════════════════════════╗",
        "║  ██╗   ██╗███╗   ██╗██╗███████╗██╗███████╗██████╗     ██╗   ██╗███████╗ ║",
        "║  ██║   ██║████╗  ██║██║██╔════╝██║██╔════╝██╔══██╗    ██║   ██║██╔════╝ ║",
        "║  ██║   ██║██╔██╗ ██║██║█████╗  ██║█████╗  ██║  ██║    ██║   ██║███████╗ ║",
        "║  ██║   ██║██║╚██╗██║██║██╔══╝  ██║██╔══╝  ██║  ██║    ╚██╗ ██╔╝╚════██║ ║",
        "║  ╚██████╔╝██║ ╚████║██║██║     ██║███████╗██████╔╝     ╚████╔╝ ███████║ ║",
        "║   ╚═════╝ ╚═╝  ╚═══╝╚═╝╚═╝     ╚═╝╚══════╝╚═════╝       ╚═══╝  ╚══════╝ ║",
        "║                  🚀 PRODUCTIVITY SUITE v5.0 TURBO 🚀                     ║",
        "╚═══════════════════════════════════════════════════════════════════════╝"
    )
    
    $gradientColors = @("#0080FF", "#00A0FF", "#00C0FF", "#00D0FF", "#00E0FF", "#00F0FF", "#00FFFF", "#00FFFF", "#00FFFF")

    for ($i = 0; $i -lt [Math]::Min($headerLines.Count, $height); $i++) {
        $line = $headerLines[$i]
        $ansiLine = Get-GradientText -Text $line -StartColor $gradientColors[$i] -EndColor $gradientColors[$i]
        # This is a simplified approach. A true buffer write would parse the ANSI.
        # For now, we just Write-Host for this specific component.
        Write-Host $ansiLine
    }
}

function global:Render-StatusCardsView {
    param([hashtable]$ViewDefinition)
    $x = $ViewDefinition.X; $y = $ViewDefinition.Y; $width = $ViewDefinition.Width; $height = $ViewDefinition.Height
    
    # This is a complex component. For integration, we'll use Write-Host as a temporary measure.
    # A full implementation would draw each character to the buffer.
    [Console]::SetCursorPosition($x, $y)
    Show-StatusCards
}

function global:Render-ActivityTimelineView {
    param([hashtable]$ViewDefinition)
    [Console]::SetCursorPosition($ViewDefinition.X, $ViewDefinition.Y)
    Show-ActivityTimeline
}

function global:Render-QuickActionsView {
    param([hashtable]$ViewDefinition)
    [Console]::SetCursorPosition($ViewDefinition.X, $ViewDefinition.Y)
    Show-QuickActions
}

function global:Render-MainMenuView {
    param([hashtable]$ViewDefinition)
    [Console]::SetCursorPosition($ViewDefinition.X, $ViewDefinition.Y)
    Show-MainMenuDisplay
}

function global:Render-HeaderView {
    param([hashtable]$ViewDefinition)
    $x = $ViewDefinition.X; $y = $ViewDefinition.Y; $width = $ViewDefinition.Width
    $text = if ($ViewDefinition.Text -is [scriptblock]) { & $ViewDefinition.Text } else { $ViewDefinition.Text }
    $headerColor = Get-LegacyColor (Get-ThemeProperty "Palette.HeaderFG")
    
    [Console]::SetCursorPosition($x, $y)
    Write-Host "`n$text" -ForegroundColor $headerColor
    Write-Host ("=" * $text.Length) -ForegroundColor $headerColor
}

function global:Render-ListView {
    param([hashtable]$ViewDefinition)
    $x = $ViewDefinition.X; $y = $ViewDefinition.Y; $width = $ViewDefinition.Width; $height = $ViewDefinition.Height
    $items = if ($ViewDefinition.DataSource -is [scriptblock]) { & $ViewDefinition.DataSource } else { $ViewDefinition.DataSource }
    $displayProp = $ViewDefinition.DisplayProperty
    $keyProp = $ViewDefinition.KeyProperty
    
    $viewState = $script:ListViewStates[$ViewDefinition.Name]
    if (-not $viewState) {
        $viewState = @{ SelectedIndex = 0; TopIndex = 0 }
        $script:ListViewStates[$ViewDefinition.Name] = $viewState
    }
    
    for ($i = 0; $i -lt [Math]::Min($items.Count, $height)) {
        $itemIndex = $viewState.TopIndex + $i
        if ($itemIndex -ge $items.Count) { break }
        $item = $items[$itemIndex]
        $displayText = $item.$displayProp
        $keyText = if ($keyProp) { "[$($item.$keyProp)] " } else { "[$($itemIndex + 1)] " }
        
        $line = "$keyText$displayText"
        if ($itemIndex -eq $viewState.SelectedIndex) {
            Write-StringToBuffer -TargetX $x -TargetY ($y + $i) -Text $line -FG_Ansi (Get-AnsiCode "Black") -BG_Ansi (Get-AnsiCode "Cyan")
        } else {
            Write-StringToBuffer -TargetX $x -TargetY ($y + $i) -Text $line
        }
    }
}

#endregion

#region Standalone UI Components (from CURRENT, adapted)

function global:Show-Dashboard {
    Clear-Host
    Show-AnimatedHeader
    Show-StatusCards
    Show-ActivityTimeline
    Show-QuickActions
    Show-MainMenuDisplay
}

function global:Show-AnimatedHeader {
    $headerLines = @(
        "╔═══════════════════════════════════════════════════════════════════════╗",
        "║  ██╗   ██╗███╗   ██╗██╗███████╗██╗███████╗██████╗     ██╗   ██╗███████╗ ║",
        "║  ██║   ██║████╗  ██║██║██╔════╝██║██╔════╝██╔══██╗    ██║   ██║██╔════╝ ║",
        "║  ██║   ██║██╔██╗ ██║██║█████╗  ██║█████╗  ██║  ██║    ██║   ██║███████╗ ║",
        "║  ██║   ██║██║╚██╗██║██║██╔══╝  ██║██╔══╝  ██║  ██║    ╚██╗ ██╔╝╚════██║ ║",
        "║  ╚██████╔╝██║ ╚████║██║██║     ██║███████╗██████╔╝     ╚████╔╝ ███████║ ║",
        "║   ╚═════╝ ╚═╝  ╚═══╝╚═╝╚═╝     ╚═╝╚══════╝╚═════╝       ╚═══╝  ╚══════╝ ║",
        "║                  🚀 PRODUCTIVITY SUITE v5.0 TURBO 🚀                     ║",
        "╚═══════════════════════════════════════════════════════════════════════╝"
    )
    
    $gradientColors = @("#0080FF", "#00A0FF", "#00C0FF", "#00D0FF", "#00E0FF", "#00F0FF", "#00FFFF", "#00FFFF", "#00FFFF")
    
    for ($i = 0; $i -lt $headerLines.Count; $i++) {
        Write-Host (Apply-PSStyle -Text $headerLines[$i] -FG $gradientColors[$i])
    }
    Write-Host
}

function global:Show-StatusCards {
    if (-not $script:Data) { 
        Write-Host "📊 Status cards unavailable (no data)" -ForegroundColor Gray
        return 
    }
    
    $activeTimers = if ($script:Data.ActiveTimers) { $script:Data.ActiveTimers.Count } else { 0 }
    $activeTasks = if ($script:Data.Tasks) { ($script:Data.Tasks | Where-Object { (-not $_.Completed) -and ($_.IsCommand -ne $true) }).Count } else { 0 }
    $todayHours = 0.0
    if ($script:Data.TimeEntries) {
        $todayHours = ($script:Data.TimeEntries | Where-Object { $_.Date -eq (Get-Date).ToString("yyyy-MM-dd") } | Measure-Object -Property Hours -Sum).Sum
        $todayHours = if ($todayHours) { [Math]::Round($todayHours, 2) } else { 0.0 }
    }
    
    $cards = @(
        @{ Icon = "📅"; Title = "TODAY"; Value = (Get-Date).ToString("MMM dd"); Subtitle = (Get-Date).ToString("dddd"); Color = "Palette.InfoFG" },
        @{ Icon = "⏱️"; Title = "HOURS"; Value = "$todayHours"; Subtitle = "logged today"; Color = if ($todayHours -ge 6) { "Palette.SuccessFG" } else { "Palette.WarningFG" } },
        @{ Icon = "⏰"; Title = "TIMERS"; Value = "$activeTimers"; Subtitle = "active"; Color = if ($activeTimers -gt 0) { "Palette.ErrorFG" } else { "Palette.SubtleFG" } },
        @{ Icon = "✅"; Title = "TASKS"; Value = "$activeTasks"; Subtitle = "pending"; Color = if ($activeTasks -gt 10) { "Palette.ErrorFG" } elseif ($activeTasks -gt 5) { "Palette.WarningFG" } else { "Palette.SuccessFG" } }
    )
    
    Write-Host "┌─────────────────┬─────────────────┬─────────────────┬─────────────────┐"
    Write-Host "│" -NoNewline
    foreach ($card in $cards) {
        $iconAndTitle = "$($card.Icon) $($card.Title)"
        Write-Host (Apply-PSStyle -Text $iconAndTitle.PadRight(16) -FG (Get-ThemeProperty $card.Color)) -NoNewline
        Write-Host "│" -NoNewline
    }
    Write-Host
    
    Write-Host "│" -NoNewline
    foreach ($card in $cards) {
        Write-Host (Apply-PSStyle -Text $card.Value.PadRight(16) -FG (Get-ThemeProperty $card.Color) -Bold) -NoNewline
        Write-Host "│" -NoNewline
    }
    Write-Host
    
    Write-Host "│" -NoNewline
    foreach ($card in $cards) {
        Write-Host (Apply-PSStyle -Text $card.Subtitle.PadRight(16) -FG (Get-ThemeProperty "Palette.SubtleFG")) -NoNewline
        Write-Host "│" -NoNewline
    }
    Write-Host
    Write-Host "└─────────────────┴─────────────────┴─────────────────┴─────────────────┘"
}

function global:Show-ActivityTimeline {
    if (-not $script:Data) {
        Write-Host "`n📊 Activity timeline unavailable" -ForegroundColor Gray
        return
    }
    
    Write-Host "`n📊 " -NoNewline
    Write-Host (Apply-PSStyle -Text "ACTIVITY TIMELINE" -FG (Get-ThemeProperty "Palette.AccentFG") -Bold)
    
    $weekStart = Get-WeekStart
    $sparklineChars = @(" ", "▂", "▃", "▄", "▅", "▆", "▇", "█")
    $weekData = @()
    
    for ($i = 0; $i -lt 7; $i++) {
        $date = $weekStart.AddDays($i).ToString("yyyy-MM-dd")
        $dayHours = 0
        if ($script:Data.TimeEntries) {
            $dayHours = ($script:Data.TimeEntries | Where-Object { $_.Date -eq $date } | Measure-Object -Property Hours -Sum).Sum
        }
        $weekData += if ($dayHours) { [Math]::Min($dayHours, 10) } else { 0 }
    }
    
    $maxHours = ($weekData | Measure-Object -Maximum).Maximum
    if ($maxHours -eq 0) { $maxHours = 1 }
    
    Write-Host "   " -NoNewline
    for ($i = 0; $i -lt 7; $i++) {
        $normalized = [Math]::Floor(($weekData[$i] / $maxHours) * ($sparklineChars.Count -1))
        $char = $sparklineChars[$normalized]
        $isToday = $i -eq [int](Get-Date).DayOfWeek
        
        if ($isToday) {
            Write-Host (Apply-PSStyle -Text "[$char]" -FG (Get-ThemeProperty "Palette.SuccessFG") -Bold) -NoNewline
        } else {
            $color = if ($weekData[$i] -ge 6) { "Palette.SuccessFG" } elseif ($weekData[$i] -gt 0) { "Palette.WarningFG" } else { "Palette.SubtleFG" }
            Write-Host (Apply-PSStyle -Text " $char " -FG (Get-ThemeProperty $color)) -NoNewline
        }
    }
    Write-Host " → $([Math]::Round(($weekData | Measure-Object -Sum).Sum, 1))h this week"
}

function global:Show-QuickActions {
    Write-Host "`n⚡ " -NoNewline
    Write-Host (Apply-PSStyle -Text "QUICK ACTIONS" -FG (Get-ThemeProperty "Palette.WarningFG") -Bold)
    
    $quickActions = @(
        @{ Key = "M"; Icon = "📝"; Text = "Manual Entry"; }, @{ Key = "S"; Icon = "▶️"; Text = "Start Timer"; },
        @{ Key = "A"; Icon = "➕"; Text = "Add Task"; }, @{ Key = "V"; Icon = "👁️"; Text = "View Timers"; },
        @{ Key = "T"; Icon = "📅"; Text = "Today View"; }, @{ Key = "W"; Icon = "📊"; Text = "Week Report"; }
    )
    
    $actionsPerRow = 3
    for ($i = 0; $i -lt $quickActions.Count; $i += $actionsPerRow) {
        Write-Host "   " -NoNewline
        for ($j = 0; $j -lt $actionsPerRow -and ($i + $j) -lt $quickActions.Count; $j++) {
            $action = $quickActions[$i + $j]
            Write-Host (Apply-PSStyle -Text "[$($action.Key)]" -FG (Get-ThemeProperty "Palette.InfoFG") -Bold) -NoNewline
            Write-Host " $($action.Icon) $($action.Text)".PadRight(20) -NoNewline
        }
        Write-Host
    }
}

function global:Show-MainMenuDisplay {
    Write-Host "`n🎯 " -NoNewline
    Write-Host (Apply-PSStyle -Text "MAIN MENU" -FG (Get-ThemeProperty "Palette.AccentFG") -Bold)
    
    $menuItems = @(
        @{ Num = "1"; Icon = "⏰"; Text = "Time Management"; Color = "Palette.InfoFG" },
        @{ Num = "2"; Icon = "📋"; Text = "Task Management"; Color = "Palette.SuccessFG" },
        @{ Num = "3"; Icon = "📈"; Text = "Reports & Analytics"; Color = "Palette.WarningFG" },
        @{ Num = "4"; Icon = "🏢"; Text = "Projects & Clients"; Color = "Palette.AccentFG" },
        @{ Num = "5"; Icon = "🔧"; Text = "Tools & Utilities"; Color = "Palette.ErrorFG" },
        @{ Num = "6"; Icon = "⚙️"; Text = "Settings & Config"; Color = "Palette.SubtleFG" }
    )
    
    foreach ($item in $menuItems) {
        Write-Host "   " -NoNewline
        Write-Host (Apply-PSStyle -Text "[$($item.Num)]" -FG (Get-ThemeProperty $item.Color) -Bold) -NoNewline
        Write-Host " $($item.Icon) " -NoNewline
        Write-Host (Apply-PSStyle -Text $item.Text -FG (Get-ThemeProperty $item.Color))
    }
    
    Write-Host "`n   " -NoNewline
    Write-Host (Apply-PSStyle -Text "[Q]" -FG (Get-ThemeProperty "Palette.ErrorFG") -Bold) -NoNewline
    Write-Host " 🚪 Quit"
}

function global:Show-Notification {
    param(
        [string]$Message,
        [string]$Type = "Info", # Info, Success, Warning, Error
        [int]$Duration = 3000,
        [switch]$Persist
    )
    
    $icons = @{ "Info" = "ℹ️"; "Success" = "✅"; "Warning" = "⚠️"; "Error" = "❌" }
    $colors = @{ "Info" = "Palette.InfoFG"; "Success" = "Palette.SuccessFG"; "Warning" = "Palette.WarningFG"; "Error" = "Palette.ErrorFG" }
    $borderStyle = if ($Type -eq "Error") { "Heavy" } else { "Rounded" }
    $border = Get-BorderStyleChars -Style $borderStyle
    $paddedMessage = " $($icons[$Type]) $Message "
    $width = $paddedMessage.Length + 2
    
    Write-Host "`n$($border.TopLeft)$($border.Horizontal * $width)$($border.TopRight)" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty $colors[$Type]))
    Write-Host "$($border.Vertical)" -NoNewline -ForegroundColor (Get-LegacyColor (Get-ThemeProperty $colors[$Type]))
    Write-Host (Apply-PSStyle -Text $paddedMessage -FG (Get-ThemeProperty $colors[$Type]) -Bold) -NoNewline
    Write-Host "$($border.Vertical)" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty $colors[$Type]))
    Write-Host "$($border.BottomLeft)$($border.Horizontal * $width)$($border.BottomRight)" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty $colors[$Type]))
    
    if (-not $Persist) {
        Start-Sleep -Milliseconds $Duration
        # This clearing method is imperfect in a non-blocking loop but works for simple notifications.
        [Console]::SetCursorPosition(0, [Console]::CursorTop - 4)
        Write-Host (" " * ($width + 4)); Write-Host (" " * ($width + 4)); Write-Host (" " * ($width + 4)); Write-Host (" " * ($width + 4))
        [Console]::SetCursorPosition(0, [Console]::CursorTop - 4)
    }
}

function global:Format-TableUnicode {
    param(
        [Parameter(ValueFromPipeline)] [object[]]$InputData,
        [hashtable[]]$Columns,
        [string]$BorderStyle = "Single",
        [string]$Title = "",
        [switch]$NoHeader,
        [hashtable]$RowHighlightRules = @{}
    )
    
    begin {
        $allData = @()
        $border = Get-BorderStyleChars -Style $BorderStyle 
        try { $MaxWidth = $Host.UI.RawUI.WindowSize.Width - 2 } catch { $MaxWidth = 80 }
    }
    process { if ($InputData) { $allData += $InputData } }
    end {
        if ($allData.Count -eq 0) { Write-Host "No data to display." -ForegroundColor Gray; return }
        if (-not $Columns) {
            $props = $allData[0].PSObject.Properties | Where-Object { $_.MemberType -eq 'NoteProperty' }
            $Columns = $props | ForEach-Object { @{ Name = $_.Name; Title = $_.Name; Width = 0 } }
        }
        
        # Calculate and adjust column widths
        foreach ($col in $Columns) {
            if ($null -eq $col.Width -or $col.Width -eq 0) {
                $maxLen = if ($col.Title) { $col.Title.Length } else { $col.Name.Length }
                foreach ($item in $allData) {
                    $value = $item | Select-Object -ExpandProperty $col.Name
                    $len = if ($value) { $value.ToString().Length } else { 0 }
                    if ($len -gt $maxLen) { $maxLen = $len }
                }
                $col.Width = [Math]::Min($maxLen + 2, ($MaxWidth / 2))
                if ($col.Width -lt ($col.Title.Length + 2)) {$col.Width = $col.Title.Length + 2}
                if ($col.Width -lt 5) { $col.Width = 5 }
            }
        }
        $totalCurrentWidth = ($Columns | Measure-Object -Property Width -Sum).Sum + ($Columns.Count + 1)
        if ($totalCurrentWidth -gt $MaxWidth) {
            $reductionFactor = ($MaxWidth - ($Columns.Count + 1)) / ($Columns | Measure-Object -Property Width -Sum).Sum
            if($reductionFactor -lt 1 -and $reductionFactor -gt 0){
                foreach ($col in $Columns) { $col.Width = [Math]::Max(5, [int]($col.Width * $reductionFactor)) }
            }
            $totalCurrentWidth = ($Columns | Measure-Object -Property Width -Sum).Sum + ($Columns.Count + 1)
        }
        
        # Draw top border
        Write-Host $border.TopLeft -NoNewline
        for ($i = 0; $i -lt $Columns.Count; $i++) { Write-Host ($border.Horizontal * $Columns[$i].Width) -NoNewline; if ($i -lt $Columns.Count - 1) { Write-Host $border.TTop -NoNewline } }
        Write-Host $border.TopRight
        
        # Draw title
        if ($Title) {
            $titleAreaWidth = $totalCurrentWidth - 2
            Write-Host $border.Vertical -NoNewline
            $titlePadded = " $Title ".PadRight($titleAreaWidth) 
            if ($titlePadded.Length -gt $titleAreaWidth) { $titlePadded = $titlePadded.Substring(0, [Math]::Max(0, $titleAreaWidth -1)) + "…" }
            Write-Host (Apply-PSStyle -Text $titlePadded -FG (Get-ThemeProperty "Palette.AccentFG") -Bold) -NoNewline 
            Write-Host $border.Vertical
            Write-Host $border.TLeft -NoNewline
            for ($i = 0; $i -lt $Columns.Count; $i++) { Write-Host ($border.Horizontal * $Columns[$i].Width) -NoNewline; if ($i -lt $Columns.Count - 1) { Write-Host $border.Cross -NoNewline } }
            Write-Host $border.TRight
        }
        
        # Draw header
        if (-not $NoHeader) {
            Write-Host $border.Vertical -NoNewline
            foreach ($col in $Columns) {
                $headerText = Format-TableCell -Text $col.Title -Width $col.Width -Align ($col.AlignHeader ?? "Center")
                Write-Host (Apply-PSStyle -Text $headerText -FG (Get-ThemeProperty "DataTable.Header.FG") -Bold) -NoNewline 
                Write-Host $border.Vertical -NoNewline
            }
            Write-Host
            Write-Host $border.TLeft -NoNewline
            for ($i = 0; $i -lt $Columns.Count; $i++) { Write-Host ($border.Horizontal * $Columns[$i].Width) -NoNewline; if ($i -lt $Columns.Count - 1) { Write-Host $border.Cross -NoNewline } }
            Write-Host $border.TRight
        }
        
        # Draw data rows
        $rowIndex = 0
        foreach ($item in $allData) {
            Write-Host $border.Vertical -NoNewline
            $rowFG = Get-ThemeProperty "DataTable.DataRow.FG"; $rowBG = Get-ThemeProperty "DataTable.DataRow.BG"; $rowBold = $false
            if ($rowIndex % 2 -eq 1 -and (-not $RowHighlightRules -or $RowHighlightRules.Count -eq 0)) { $rowFG = Get-ThemeProperty "DataTable.AltRow.FG"; $rowBG = Get-ThemeProperty "DataTable.AltRow.BG" }
            foreach($ruleName in $RowHighlightRules.Keys){
                $rule = $RowHighlightRules[$ruleName]
                if($item | Where-Object $rule.Condition){
                    $rowFG = if ($rule.FG) { Get-ThemeProperty "Palette.$($rule.FG)FG" } else { $rowFG }
                    $rowBold = if ($rule.Bold) { $rule.Bold } else { $rowBold }
                    break
                }
            }
            foreach ($col in $Columns) {
                $value = $item | Select-Object -ExpandProperty $col.Name
                $cellText = Format-TableCell -Text $value -Width $col.Width -Align ($col.AlignData ?? "Left")
                Write-Host (Apply-PSStyle -Text $cellText -FG $rowFG -BG $rowBG -Bold:$rowBold) -NoNewline
                Write-Host $border.Vertical -NoNewline
            }
            Write-Host
            $rowIndex++
        }
        
        # Draw bottom border
        Write-Host $border.BottomLeft -NoNewline
        for ($i = 0; $i -lt $Columns.Count; $i++) { Write-Host ($border.Horizontal * $Columns[$i].Width) -NoNewline; if ($i -lt $Columns.Count - 1) { Write-Host $border.TBottom -NoNewline } }
        Write-Host $border.BottomRight
    }
}

function global:Format-TableCell {
    param([string]$Text, [int]$Width, [string]$Align = "Left")
    $Text = if ($null -eq $Text) { "" } else { $Text.ToString() } 
    if ($Width -lt 1) { $Width = 1 }
    $contentWidth = $Width - 2
    if ($contentWidth -lt 0) {$contentWidth = 0}
    if ($Text.Length -gt $contentWidth) {
        if ($contentWidth -ge 1) { $Text = $Text.Substring(0, [Math]::Max(0, $contentWidth -1)) + "…" }
        else {$Text = ""}
    }
    $paddedText = switch ($Align.ToLower()) {
        "center" { $Text.PadLeft([int](($contentWidth + $Text.Length) / 2)).PadRight($contentWidth) } 
        "right"  { $Text.PadLeft($contentWidth) } 
        default  { $Text.PadRight($contentWidth) } 
    }
    return " $paddedText "
}

function global:Draw-ProgressBar {
    param(
        [int]$Percent,
        [int]$Width = 20,
        [string]$FillChar = "█",
        [string]$EmptyChar = "░"
    )
    if($Percent -lt 0) {$Percent = 0} elseif($Percent -gt 100) {$Percent = 100}
    if($Width -lt 5) {$Width = 5}
    $filledBlocks = [Math]::Floor($Width * ($Percent / 100))
    $emptyBlocks = $Width - $filledBlocks
    $color = if ($Percent -ge 80) { Get-ThemeProperty "Palette.SuccessFG" } 
             elseif ($Percent -ge 50) { Get-ThemeProperty "Palette.WarningFG" } 
             else { Get-ThemeProperty "Palette.ErrorFG" }
    
    Write-Host "[" -NoNewline
    Write-Host (Apply-PSStyle -Text ($FillChar * $filledBlocks) -FG $color) -NoNewline
    Write-Host (Apply-PSStyle -Text ($EmptyChar * $emptyBlocks) -FG (Get-ThemeProperty "Palette.SubtleFG")) -NoNewline
    Write-Host "] $($Percent.ToString().PadLeft(3))%" -NoNewline
}

#endregion
```

---
### **File 5: `core-data.ps1`**
*This is the data management module from `CURRENT`. It contains all the rich functionality for Projects, Tasks, and Command Snippets. It has been reviewed to ensure it uses the new helper and theme functions correctly.*

```powershell
# Core Data Management Module
# Projects, tasks, todos, and command snippets

#region Data Model Initialization

function global:Get-DefaultSettings {
    return @{
        # Time Tracker Settings
        DefaultRate = 100.0 # Use double for currency/rate
        Currency = "USD"
        HoursPerDay = 8.0 # Use double for hours
        DaysPerWeek = 5
        TimeTrackerTemplates = @{
            "ADMIN" = @{ Name = "Administrative Tasks"; Id1 = "100"; Id2 = "ADM"; Client = "Internal"; Department = "Operations"; BillingType = "Non-Billable"; Status = "Active"; Budget = 0.0; Rate = 0.0; Notes = "General administrative tasks" }
            "MEETING" = @{ Name = "Meetings & Calls"; Id1 = "101"; Id2 = "MTG"; Client = "Internal"; Department = "Various"; BillingType = "Non-Billable"; Status = "Active"; Budget = 0.0; Rate = 0.0; Notes = "Team meetings and calls" }
            "TRAINING" = @{ Name = "Training & Learning"; Id1 = "102"; Id2 = "TRN"; Client = "Internal"; Department = "HR"; BillingType = "Non-Billable"; Status = "Active"; Budget = 0.0; Rate = 0.0; Notes = "Professional development" }
            "BREAK" = @{ Name = "Breaks & Personal"; Id1 = "103"; Id2 = "BRK"; Client = "Internal"; Department = "Personal"; BillingType = "Non-Billable"; Status = "Active"; Budget = 0.0; Rate = 0.0; Notes = "Breaks and personal time" }
        }
        # Todo Tracker Settings
        DefaultPriority = "Medium"
        DefaultCategory = "General"
        ShowCompletedDays = 7
        EnableTimeTracking = $true
        AutoArchiveDays = 30
        # Command Snippets Settings
        CommandSnippets = @{
            EnableHotkeys = $true
            AutoCopyToClipboard = $true
            ShowInTaskList = $false
            DefaultCategory = "Commands"
            RecentLimit = 10
        }
        # Excel Integration Settings
        ExcelFormConfig = @{
            WorksheetName = "Project Info"
            StandardFields = @{
                "Id1" = @{ LabelCell = "A5"; ValueCell = "B5"; Label = "Project ID"; Field = "Id1" }
                "Id2" = @{ LabelCell = "A6"; ValueCell = "B6"; Label = "Task Code"; Field = "Id2" }
                "Name" = @{ LabelCell = "A7"; ValueCell = "B7"; Label = "Project Name"; Field = "Name" }
                "FullName" = @{ LabelCell = "A8"; ValueCell = "B8"; Label = "Full Description"; Field = "FullName" }
                "AssignedDate" = @{ LabelCell = "A9"; ValueCell = "B9"; Label = "Start Date"; Field = "AssignedDate" }
                "DueDate" = @{ LabelCell = "A10"; ValueCell = "B10"; Label = "End Date"; Field = "DueDate" }
                "Manager" = @{ LabelCell = "A11"; ValueCell = "B11"; Label = "Project Manager"; Field = "Manager" }
                "Budget" = @{ LabelCell = "A12"; ValueCell = "B12"; Label = "Budget"; Field = "Budget" }
                "Status" = @{ LabelCell = "A13"; ValueCell = "B13"; Label = "Status"; Field = "Status" }
                "Priority" = @{ LabelCell = "A14"; ValueCell = "B14"; Label = "Priority"; Field = "Priority" }
                "Department" = @{ LabelCell = "A15"; ValueCell = "B15"; Label = "Department"; Field = "Department" }
                "Client" = @{ LabelCell = "A16"; ValueCell = "B16"; Label = "Client"; Field = "Client" }
                "BillingType" = @{ LabelCell = "A17"; ValueCell = "B17"; Label = "Billing Type"; Field = "BillingType" }
                "Rate" = @{ LabelCell = "A18"; ValueCell = "B18"; Label = "Hourly Rate"; Field = "Rate" }
            }
        }
        # UI Theme
        Theme = @{
            Header = "Cyan"; Success = "Green"; Warning = "Yellow"; Error = "Red"
            Info = "Blue"; Accent = "Magenta"; Subtle = "DarkGray"
        }
        CurrentTheme = "Cyberpunk" # Default advanced theme
        QuickActionTipShown = $false
        logFilePath = "" # Will be set by helper
        logMaxSizeMB = 10
    }
}
#endregion

#region Project Management

function global:Get-ProjectOrTemplate {
    param([string]$Key)
    if ([string]::IsNullOrEmpty($Key)) { return $null }
    if ($script:Data.Projects.ContainsKey($Key)) {
        return $script:Data.Projects[$Key]
    } elseif ($script:Data.Settings.TimeTrackerTemplates.ContainsKey($Key.ToUpper())) {
        return $script:Data.Settings.TimeTrackerTemplates[$Key.ToUpper()]
    }
    return $null
}

function global:Show-ProjectsAndTemplates {
    param([switch]$Simple)
    
    if ($Simple) {
        Write-Host "`nProjects:" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG"))
        if (-not $script:Data.Projects -or $script:Data.Projects.Count -eq 0) {
            Write-Host "  No projects defined." -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
        } else {
            foreach ($proj in $script:Data.Projects.GetEnumerator() | Sort-Object {$_.Value.Name}) {
                Write-Host "  [$($proj.Key)] $($proj.Value.Name)" -NoNewline
                if ($proj.Value.Client) { Write-Host " ($($proj.Value.Client))" -NoNewline }
                Write-Host
            }
        }
        Write-Host "`nTemplates:" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG"))
        if (-not $script:Data.Settings.TimeTrackerTemplates -or $script:Data.Settings.TimeTrackerTemplates.Count -eq 0) {
            Write-Host "  No templates defined." -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
        } else {
            foreach ($tmpl in $script:Data.Settings.TimeTrackerTemplates.GetEnumerator()) {
                Write-Host "  [$($tmpl.Key)] $($tmpl.Value.Name)"
            }
        }
    } else {
        $projectData = @()
        if ($script:Data.Projects -and $script:Data.Projects.Count -gt 0) {
            foreach ($proj in $script:Data.Projects.GetEnumerator() | Sort-Object {$_.Value.Name}) {
                Update-ProjectStatistics -ProjectKey $proj.Key
                $projectData += [PSCustomObject]@{
                    Key = $proj.Key
                    Name = $proj.Value.Name
                    Client = if ($proj.Value.Client) { $proj.Value.Client } else { "-" }
                    Status = $proj.Value.Status
                    Type = $proj.Value.BillingType
                    Hours = "$($proj.Value.TotalHours)h"
                    Tasks = "$($proj.Value.ActiveTasks)/$($proj.Value.CompletedTasks + $proj.Value.ActiveTasks)"
                    Budget = $proj.Value.Budget
                }
            }
        }
        
        if ($projectData.Count -gt 0) {
            $projectData | Format-TableUnicode -Columns @(
                @{Name="Key"; Title="Key"; Width=10}
                @{Name="Name"; Title="Project Name"; Width=25}
                @{Name="Client"; Title="Client"; Width=20}
                @{Name="Status"; Title="Status"; Width=10; AlignData="Center"}
                @{Name="Type"; Title="Billing"; Width=12}
                @{Name="Hours"; Title="Hours"; Width=8; AlignData="Right"}
                @{Name="Tasks"; Title="Tasks"; Width=10; AlignData="Center"}
            ) -Title "Projects" -BorderStyle "Double" -RowHighlightRules @{
                Overbudget = @{ Condition = { ($_.Hours -match '^(\d+\.?\d*)') -and ($_.Budget -gt 0) -and ([double]$Matches[1] -gt $_.Budget) }; FG = "Error" }
                Active = @{ Condition = { $_.Status -eq "Active" }; FG = "Success" }
                OnHold = @{ Condition = { $_.Status -eq "On Hold" }; FG = "Warning" }
            }
        } else {
            Write-Host "`n  No projects defined." -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
        }
        
        $templateData = @()
        if ($script:Data.Settings.TimeTrackerTemplates -and $script:Data.Settings.TimeTrackerTemplates.Count -gt 0) {
            foreach ($tmpl in $script:Data.Settings.TimeTrackerTemplates.GetEnumerator()) {
                $templateData += [PSCustomObject]@{
                    Key = $tmpl.Key
                    Name = $tmpl.Value.Name
                    Department = if ($tmpl.Value.Department) { $tmpl.Value.Department } else { "-" }
                    Type = "Template"
                    Notes = if ($tmpl.Value.Notes) { ($tmpl.Value.Notes.Substring(0, [Math]::Min(30, $tmpl.Value.Notes.Length))) + "..." } else { "-" }
                }
            }
        }
        
        if ($templateData.Count -gt 0) {
            Write-Host ""
            $templateData | Format-TableUnicode -Columns @(
                @{Name="Key"; Title="Key"; Width=10}
                @{Name="Name"; Title="Template Name"; Width=25}
                @{Name="Department"; Title="Department"; Width=20}
                @{Name="Type"; Title="Type"; Width=10; AlignData="Center"}
                @{Name="Notes"; Title="Notes"; Width=35}
            ) -Title "Time Tracking Templates" -BorderStyle "Single"
        } else {
            Write-Host "`n  No templates defined." -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
        }
    }
}

function global:Show-ProjectDetail {
    Write-Header "Project Details"
    
    $projectKey = Select-ProjectOrTemplate -Title "Select Project/Template for Details"
    if (-not $projectKey) { 
        Write-Info "Selection cancelled."
        return 
    }
    
    $project = Get-ProjectOrTemplate $projectKey
    if ($project) {
        Clear-Host
        Write-Header "Details for: $($project.Name) (Key: $projectKey)"
        if ($script:Data.Projects.ContainsKey($projectKey)) {
            Update-ProjectStatistics -ProjectKey $projectKey
            $project = $script:Data.Projects[$projectKey]
        }
        $properties = $project.PSObject.Properties | Select-Object Name, Value | Where-Object { $_.Name -notin @("PSParentPath", "PSChildName") }
        foreach ($prop in $properties) {
            if ($prop.Name -eq "Notes" -and [string]::IsNullOrEmpty($prop.Value)) { continue }
            Write-Host "  $($prop.Name.PadRight(18)): $($prop.Value)"
        }
        if ($project.BillingType -eq "Billable" -and $project.Budget -gt 0) {
            Write-Host "`nBudget Status:" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG"))
            $percentUsed = ($project.TotalHours / $project.Budget) * 100
            Write-Host "  Budget: $($project.Budget) hours, Used: $($project.TotalHours) hours ($([Math]::Round($percentUsed, 1))% used)"
        }
        Write-Host "`nPress any key to continue..."
        $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
    } else {
        Write-Error "Project or Template '$projectKey' not found."
    }
}

function global:Import-ProjectFromExcel {
    Write-Header "Import Project from Excel Form"
    Write-Warning "Excel import feature is not yet fully implemented in this version."
    $selectedFile = Start-TerminalFileBrowser -SelectFileMode
    if (-not $selectedFile) {
        Write-Info "File selection cancelled."
        return
    }
    Write-Info "Selected file: $selectedFile. (Implementation pending)."
    Write-Host "`nPress any key to continue..."
    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
}

function global:Configure-ExcelForm {
    Write-Header "Configure Excel Form Import Mapping"
    Write-Warning "Excel configuration for import mapping is not yet fully implemented."
    Write-Info "This feature is under development."
    Write-Host "`nPress any key to continue..."
    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
}

function global:Add-Project {
    Write-Header "Add New Project"
    $projectKeyInput = Read-Host "Project Key (short identifier)"
    if ([string]::IsNullOrEmpty($projectKeyInput)) { Write-Error "Project key cannot be empty."; return }
    if ($script:Data.Projects.ContainsKey($projectKeyInput) -or $script:Data.Settings.TimeTrackerTemplates.ContainsKey($projectKeyInput.ToUpper())) {
        Write-Error "Project key '$projectKeyInput' already exists as a project or template."
        return
    }
    Write-Host "`nBasic Information:" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG"))
    $projectName = Read-Host "Project Name"
    if ([string]::IsNullOrEmpty($projectName)) { Write-Error "Project name cannot be empty."; return }
    $id1 = Read-Host "ID1 (custom identifier, optional)"
    $id2 = Read-Host "ID2 (max 9 chars, optional)"
    Write-Host "`nClient & Department:" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG"))
    $client = Read-Host "Client Name (optional)"
    $department = Read-Host "Department (optional)"
    Write-Host "`nBilling Information:" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG"))
    Write-Host "Billing Type: [B]illable, [N]on-Billable, [F]ixed Price (default: Non-Billable)"
    $billingChoice = Read-Host "Choice (B/N/F)"
    $billingType = switch ($billingChoice.ToUpper()) { "B" { "Billable" } "F" { "Fixed Price" } default { "Non-Billable" } }
    $rate = 0.0
    $budget = 0.0
    if ($billingType -ne "Non-Billable") {
        $rateInput = Read-Host "Hourly Rate (default: $($script:Data.Settings.DefaultRate))"
        if (-not [string]::IsNullOrWhiteSpace($rateInput)) {
            try { $rate = [double]$rateInput } catch { Write-Warning "Invalid rate format, using 0.0."; $rate = 0.0 }
        } else { $rate = $script:Data.Settings.DefaultRate }
        $budgetInput = Read-Host "Budget Hours (0 for unlimited, optional)"
        if (-not [string]::IsNullOrWhiteSpace($budgetInput)) {
            try { $budget = [double]$budgetInput } catch { Write-Warning "Invalid budget format, using 0.0."; $budget = 0.0 }
        }
    }
    Write-Host "`nProject Status:" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG"))
    Write-Host "[A]ctive, [O]n Hold, [C]ompleted (default: Active)"
    $statusChoice = Read-Host "Status (A/O/C)"
    $status = switch ($statusChoice.ToUpper()) { "O" { "On Hold" } "C" { "Completed" } default { "Active" } }
    $notes = Read-Host "`nProject Notes (optional)"
    $startDate = (Get-Date).ToString("yyyy-MM-dd")
    $script:Data.Projects[$projectKeyInput] = @{
        Name = $projectName; Id1 = $id1; Id2 = $id2; Client = $client; Department = $department
        BillingType = $billingType; Rate = $rate; Budget = $budget; Status = $status; Notes = $notes
        StartDate = $startDate; TotalHours = 0.0; TotalBilled = 0.0; CompletedTasks = 0; ActiveTasks = 0
        Manager = ""; Priority = "Medium"; DueDate = $null; CreatedDate = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
    }
    Save-UnifiedData
    Write-Success "Project added: $projectKeyInput - $projectName"
}

function global:Edit-Project {
    Show-ProjectsAndTemplates -Simple
    Write-Host ""
    $projectKeyToEdit = Read-Host "Enter project key to edit"
    if([string]::IsNullOrWhiteSpace($projectKeyToEdit)) { Write-Info "Edit cancelled."; return }
    if (-not $script:Data.Projects.ContainsKey($projectKeyToEdit)) {
        Write-Error "Project '$projectKeyToEdit' not found or cannot edit templates this way."
        return
    }
    $project = $script:Data.Projects[$projectKeyToEdit]
    Write-Header "Edit Project: $projectKeyToEdit ($($project.Name))"
    Write-Host "Leave field empty to keep current value." -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
    $fieldPrompts = @(
        @{Prop="Name"; Prompt="New Name"; Current=$project.Name}
        @{Prop="Client"; Prompt="New Client"; Current=$project.Client}
        @{Prop="Department"; Prompt="New Department"; Current=$project.Department}
        @{Prop="Id1"; Prompt="New ID1"; Current=$project.Id1}
        @{Prop="Id2"; Prompt="New ID2 (max 9 chars)"; Current=$project.Id2}
        @{Prop="Status"; Prompt="New Status ([A]ctive, [O]n Hold, [C]ompleted)"; Current=$project.Status; Type="Status"}
        @{Prop="BillingType"; Prompt="New Billing Type ([B]illable, [N]on-Billable, [F]ixed Price)"; Current=$project.BillingType; Type="BillingType"}
        @{Prop="Rate"; Prompt="New Rate"; Current=$project.Rate; Type="Double"; Condition={$project.BillingType -ne "Non-Billable"}}
        @{Prop="Budget"; Prompt="New Budget Hours"; Current=$project.Budget; Type="Double"; Condition={$project.BillingType -ne "Non-Billable"}}
        @{Prop="Notes"; Prompt="New Notes (enter 'clear' to empty)"; Current=$project.Notes; Type="StringAllowClear"}
        @{Prop="StartDate"; Prompt="New Start Date (YYYY-MM-DD)"; Current=$project.StartDate; Type="Date"}
        @{Prop="DueDate"; Prompt="New Due Date (YYYY-MM-DD, or 'clear')"; Current=$project.DueDate; Type="DateAllowClear"}
        @{Prop="Manager"; Prompt="New Project Manager"; Current=$project.Manager}
        @{Prop="Priority"; Prompt="New Project Priority ([C]ritical, [H]igh, [M]edium, [L]ow)"; Current=$project.Priority; Type="ProjectPriority"}
    )
    $changesMade = $false
    foreach($field in $fieldPrompts) {
        if ($field.Condition -and -not (& $field.Condition)) { continue }
        Write-Host "`nCurrent $($field.Prop): $($field.Current)" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
        $newValue = Read-Host $field.Prompt
        if (-not [string]::IsNullOrWhiteSpace($newValue)) {
            $validUpdate = $true; $oldFieldValue = $project.($field.Prop)
            switch ($field.Type) {
                "Double" { try { $project.($field.Prop) = [double]$newValue } catch { Write-Warning "Invalid number for $($field.Prop). Not changed."; $validUpdate = $false } }
                "Status" { $project.($field.Prop) = switch ($newValue.ToUpper()) { "A" { "Active" } "O" { "On Hold" } "C" { "Completed" } default { $project.($field.Prop) } }; if ($project.($field.Prop) -eq $field.Current -and $newValue.ToUpper() -notin @("A","O","C")) {$validUpdate = $false; Write-Warning "Invalid status. Not changed."} }
                "BillingType" { $project.($field.Prop) = switch ($newValue.ToUpper()) { "B" { "Billable" } "N" { "Non-Billable" } "F" { "Fixed Price"} default { $project.($field.Prop) } }; if ($project.($field.($field.Prop)) -eq $field.Current -and $newValue.ToUpper() -notin @("B","N","F")) {$validUpdate = $false; Write-Warning "Invalid billing type. Not changed."} }
                "Date" { try { $project.($field.Prop) = ([datetime]::Parse($newValue)).ToString("yyyy-MM-dd") } catch { Write-Warning "Invalid date for $($field.Prop). Not changed."; $validUpdate = $false } }
                "DateAllowClear" { if ($newValue.ToLower() -eq 'clear') { $project.($field.Prop) = $null } else { try { $project.($field.Prop) = ([datetime]::Parse($newValue)).ToString("yyyy-MM-dd") } catch { Write-Warning "Invalid date for $($field.Prop). Not changed."; $validUpdate = $false } } }
                "StringAllowClear" { if ($newValue.ToLower() -eq 'clear') { $project.($field.Prop) = "" } else { $project.($field.Prop) = $newValue } }
                "ProjectPriority" { $project.($field.Prop) = switch ($newValue.ToUpper()) { "C" { "Critical" } "H" { "High" } "M" { "Medium" } "L" { "Low" } default { $project.($field.Prop) } }; if ($project.($field.Prop) -eq $field.Current -and $newValue.ToUpper() -notin @("C","H","M","L")) {$validUpdate = $false; Write-Warning "Invalid priority. Not changed."} }
                default { $project.($field.Prop) = $newValue }
            }
            if ($validUpdate -and $project.($field.Prop) -ne $oldFieldValue) { $changesMade = $true }
        }
    }
    if ($changesMade) { Save-UnifiedData; Write-Success "Project '$projectKeyToEdit' updated!" } else { Write-Info "No changes made to project '$projectKeyToEdit'." }
}

function global:Update-ProjectStatistics {
    param([string]$ProjectKey)
    if (-not $script:Data.Projects.ContainsKey($ProjectKey)) { return }
    $project = $script:Data.Projects[$ProjectKey]
    $projectEntries = $script:Data.TimeEntries | Where-Object { $_.ProjectKey -eq $ProjectKey }
    $project.TotalHours = [Math]::Round(($projectEntries | Measure-Object -Property Hours -Sum).Sum, 2)
    $projectTasks = $script:Data.Tasks | Where-Object { $_.ProjectKey -eq $ProjectKey -and ($_.IsCommand -ne $true) }
    $project.CompletedTasks = ($projectTasks | Where-Object { $_.Completed }).Count
    $project.ActiveTasks = ($projectTasks | Where-Object { -not $_.Completed }).Count
}

function global:Export-Projects {
    Write-Header "Export Projects"
    if (-not $script:Data.Projects -or $script:Data.Projects.Count -eq 0) { Write-Warning "No projects to export."; return }
    $exportData = @()
    foreach ($projEnum in $script:Data.Projects.GetEnumerator()) {
        $projValue = $projEnum.Value
        $exportData += [PSCustomObject]@{
            Key = $projEnum.Key; Name = $projValue.Name; Id1 = $projValue.Id1; Id2 = $projValue.Id2
            Client = $projValue.Client; Department = $projValue.Department; Status = $projValue.Status
            BillingType = $projValue.BillingType; Rate = $projValue.Rate; Budget = $projValue.Budget
            TotalHours = $projValue.TotalHours; ActiveTasks = $projValue.ActiveTasks; CompletedTasks = $projValue.CompletedTasks
            StartDate = $projValue.StartDate; DueDate = $projValue.DueDate; Manager = $projValue.Manager
            ProjectPriority = $projValue.Priority; Notes = $projValue.Notes; CreatedDate = $projValue.CreatedDate
        }
    }
    $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
    $exportFile = Join-Path ([Environment]::GetFolderPath("Desktop")) "Projects_Export_$timestamp.csv"
    try {
        $exportData | Export-Csv $exportFile -NoTypeInformation -Encoding UTF8
        Write-Success "Projects exported to: $exportFile"
        if ((Read-Host "Open file now? (Y/N)").ToUpper() -eq 'Y') { Start-Process $exportFile }
    } catch { Write-Error "Failed to export projects: $_" }
}

function global:Batch-ImportProjects {
    Write-Warning "Batch Import Projects feature not yet implemented."
    $selectedFile = Start-TerminalFileBrowser -SelectFileMode
    if (-not $selectedFile) {
        Write-Info "File selection cancelled."
        return
    }
    Write-Info "Selected file for batch import: $selectedFile. (Implementation pending)."
}

function global:Show-ProjectSummary {
    Write-Header "Project Summary Report"
    if (-not $script:Data.Projects -or $script:Data.Projects.Count -eq 0) { Write-Warning "No projects available to summarize."; return }
    $projectSummaryData = @()
    foreach ($key in ($script:Data.Projects.Keys | Sort-Object)) {
        Update-ProjectStatistics -ProjectKey $key
        $p = $script:Data.Projects[$key]
        $projectSummaryData += [PSCustomObject]@{
            Key = $key; Name = $p.Name; Client = $p.Client; Status = $p.Status; Budget = $p.Budget; TotalHours = $p.TotalHours
            RemainingHours = if ($p.Budget -gt 0) { [Math]::Round($p.Budget - $p.TotalHours, 2) } else { "N/A" }
            Progress = if ($p.Budget -gt 0 -and $p.TotalHours -ge 0) {
                           if ($p.TotalHours -eq 0 -and $p.Budget -gt 0) { "0%" }
                           elseif ($p.TotalHours -gt 0) { "$([Math]::Round(($p.TotalHours / $p.Budget) * 100, 1))%" }
                           else { "N/A" }
                       } else { "N/A" }
            ActiveTasks = $p.ActiveTasks
        }
    }
    $projectSummaryData | Format-TableUnicode -Columns @(
        @{Name="Key"; Title="Key"; Width=10}, @{Name="Name"; Title="Project Name"; Width=25}
        @{Name="Client"; Title="Client"; Width=15}, @{Name="Status"; Title="Status"; Width=12}
        @{Name="Budget"; Title="Budget (h)"; Width=10; Align="Right"}, @{Name="TotalHours"; Title="Used (h)"; Width=10; Align="Right"}
        @{Name="RemainingHours"; Title="Rem (h)"; Width=10; Align="Right"}, @{Name="Progress"; Title="Progress %"; Width=12; Align="Right"}
        @{Name="ActiveTasks"; Title="Active Tasks"; Width=12; Align="Right"}
    ) -Title "Project Summary" -BorderStyle "Rounded"
}

#endregion

#region Command Snippets System

function global:Add-CommandSnippet {
    Write-Header "Add Command Snippet"
    $snippetName = Read-Host "Command name/description"
    if ([string]::IsNullOrEmpty($snippetName)) { Write-Error "Command name cannot be empty!"; return }
    
    Write-Host "`nEnter command content (press Esc when finished):" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
    $commandText = Read-MultilineText
    
    if ([string]::IsNullOrWhiteSpace($commandText)) { Write-Error "Command cannot be empty!"; return }
    
    $existingCategories = $script:Data.Tasks | Where-Object { $_.IsCommand -eq $true -and (-not [string]::IsNullOrEmpty($_.Category)) } | Select-Object -ExpandProperty Category -Unique | Sort-Object
    if ($existingCategories) { Write-Host "`nExisting categories: $($existingCategories -join ', ')" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.AccentFG")) }
    $category = Read-Host "Category (default: $($script:Data.Settings.CommandSnippets.DefaultCategory))"
    if ([string]::IsNullOrEmpty($category)) { $category = $script:Data.Settings.CommandSnippets.DefaultCategory }
    Write-Host "`nTags (comma-separated, optional):" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
    $tagsInput = Read-Host "Tags"
    $tags = if (-not [string]::IsNullOrWhiteSpace($tagsInput)) { $tagsInput -split ',' | ForEach-Object { $_.Trim() } | Where-Object { -not [string]::IsNullOrWhiteSpace($_) } } else { @() }
    $hotkey = ""
    if ($script:Data.Settings.CommandSnippets.EnableHotkeys) {
        Write-Host "`nAssign hotkey (optional, e.g., 'ctrl+1'):" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
        $hotkey = Read-Host "Hotkey"
    }
    $snippet = @{
        Id = New-TodoId; Description = $snippetName; Priority = "Low"; Category = $category; ProjectKey = $null
        StartDate = $null; DueDate = $null; Tags = $tags; Progress = 0; Completed = $false
        CreatedDate = [datetime]::Now.ToString("yyyy-MM-dd HH:mm:ss"); CompletedDate = $null; EstimatedTime = 0
        TimeSpent = 0; Subtasks = @(); Notes = $commandText; LastModified = [datetime]::Now.ToString("yyyy-MM-dd HH:mm:ss")
        IsCommand = $true; Hotkey = $hotkey; LastUsed = $null; UseCount = 0
    }
    $script:Data.Tasks += $snippet
    Save-UnifiedData
    Write-Success "Command snippet added: $snippetName"
    if ($script:Data.Settings.CommandSnippets.AutoCopyToClipboard) { if (Copy-ToClipboard $commandText) { Write-Info "Command copied to clipboard!" } }
}

function global:Get-CommandSnippet {
    param([string]$Id, [string]$SearchTerm, [string]$CategoryFilter, [string[]]$TagsFilter)
    $snippets = $script:Data.Tasks | Where-Object { $_.IsCommand -eq $true }
    if ($Id) { return $snippets | Where-Object { $_.Id -like "$Id*" } | Select-Object -First 1 }
    if ($SearchTerm) { $snippets = $snippets | Where-Object { $_.Description -like "*$SearchTerm*" -or $_.Notes -like "*$SearchTerm*" -or ($_.Tags -and ($_.Tags -join " ") -like "*$SearchTerm*") } }
    if ($CategoryFilter) { $snippets = $snippets | Where-Object { $_.Category -eq $CategoryFilter } }
    if ($TagsFilter -and $TagsFilter.Count -gt 0) { $snippets = $snippets | Where-Object { $snippetTags = $_.Tags; if (-not $snippetTags) { return $false } $foundAll = $true; foreach ($tagToFind in $TagsFilter) { if ($tagToFind -notin $snippetTags) { $foundAll = $false; break } } $foundAll } }
    return $snippets
}

function global:Search-CommandSnippets {
    Write-Header "Search Command Snippets"
    $searchTerm = Read-Host "Search term (name, content, tags; leave empty for all)"
    $categoryFilter = Read-Host "Filter by category (optional, exact match)"
    $tagsInput = Read-Host "Filter by tags (comma-separated, AND logic; optional)"
    $tagsFilter = if (-not [string]::IsNullOrWhiteSpace($tagsInput)) { $tagsInput -split ',' | ForEach-Object {$_.Trim()} | Where-Object { -not [string]::IsNullOrWhiteSpace($_)} } else { $null }
    $unsortedSnippets = Get-CommandSnippet -SearchTerm $searchTerm -CategoryFilter $categoryFilter -TagsFilter $tagsFilter
    $snippets = $unsortedSnippets | Sort-Object @{Expression="UseCount"; Descending=$true}, @{Expression="Description"; Descending=$false}
    if ($snippets.Count -eq 0) { Write-Host "No snippets found matching your criteria." -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")); return }
    $tableData = $snippets | ForEach-Object { [PSCustomObject]@{ ID = $_.Id.Substring(0, 6); Name = $_.Description; Category = $_.Category; Tags = if ($_.Tags) { ($_.Tags -join ", ") } else { "" }; Used = $_.UseCount; Hotkey = if ($_.Hotkey) { $_.Hotkey } else { "-" } } }
    $tableData | Format-TableUnicode -Columns @( @{Name="ID"; Title="ID"; Width=8}, @{Name="Name"; Title="Name"; Width=30}, @{Name="Category"; Title="Category"; Width=15}, @{Name="Tags"; Title="Tags"; Width=20}, @{Name="Used"; Title="Used"; Width=6; Align="Right"}, @{Name="Hotkey"; Title="Hotkey"; Width=10} ) -Title "Command Snippets"
    Write-Host "`nEnter snippet ID to copy/execute, or press Enter to cancel."
    $selectedId = Read-Host
    if (-not [string]::IsNullOrWhiteSpace($selectedId)) { Execute-CommandSnippet -Id $selectedId }
}

function global:Execute-CommandSnippet {
    param([string]$Id)
    $snippet = Get-CommandSnippet -Id $Id
    if (-not $snippet) { Write-Error "Snippet with ID starting '$Id' not found!"; return }
    Write-Host "`nCommand: $($snippet.Description)" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.AccentFG"))
    Write-Host "Category: $($snippet.Category)" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
    if ($snippet.Tags -and $snippet.Tags.Count -gt 0) { Write-Host "Tags: $($snippet.Tags -join ', ')" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")) }
    Write-Host "`nCommand content:" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG"))
    Write-Host $snippet.Notes -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.PrimaryFG"))
    $snippet.LastUsed = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
    $snippet.UseCount = [int]$snippet.UseCount + 1
    Save-UnifiedData
    Write-Host "`n[C]opy to clipboard, [E]xecute (PowerShell), [B]oth, or [Enter] to cancel"
    $actionChoice = Read-Host
    switch ($actionChoice.ToUpper()) {
        "C" { if (Copy-ToClipboard $snippet.Notes) { Write-Success "Command copied to clipboard!" } }
        "E" { Write-Warning "Are you sure you want to execute this command?"; $confirmExecution = Read-Host "Type 'yes' to confirm"; if ($confirmExecution -eq 'yes') { try { Invoke-Expression $snippet.Notes; Write-Success "Command executed!" } catch { Write-Error "Execution failed: $_" } } else { Write-Info "Execution cancelled."} }
        "B" { if (Copy-ToClipboard $snippet.Notes) { Write-Success "Command copied!" }; Write-Warning "Are you sure you want to execute?"; $confirmExecuteBoth = Read-Host "Type 'yes' to confirm"; if ($confirmExecuteBoth -eq 'yes') { try { Invoke-Expression $snippet.Notes; Write-Success "Command executed!" } catch { Write-Error "Execution failed: $_" } } else { Write-Info "Execution cancelled."} }
        default { Write-Info "Action cancelled."}
    }
}

function global:Remove-CommandSnippet {
    param([string]$IdInput)
    $idToRemove = $IdInput
    if (-not $idToRemove) { Search-CommandSnippets; $idToRemove = Read-Host "`nEnter snippet ID to delete, or Enter to cancel"; if ([string]::IsNullOrWhiteSpace($idToRemove)) { Write-Info "Deletion cancelled."; return } }
    $snippet = Get-CommandSnippet -Id $idToRemove
    if (-not $snippet) { Write-Error "Snippet with ID starting '$idToRemove' not found!"; return }
    Write-Warning "Delete snippet: '$($snippet.Description)' (ID: $($snippet.Id.Substring(0,6)))?"
    if ((Read-Host "Type 'yes' to confirm") -eq 'yes') {
        $script:Data.Tasks = $script:Data.Tasks | Where-Object { $_.Id -ne $snippet.Id }
        Save-UnifiedData
        Write-Success "Snippet deleted!"
    } else { Write-Info "Deletion cancelled."}
}

function global:Manage-CommandSnippets {
    while ($true) {
        Write-Header "Command Snippets"
        $snippetCount = ($script:Data.Tasks | Where-Object { $_.IsCommand -eq $true }).Count
        Write-Host "Total snippets: $snippetCount" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
        $recentSnippets = Get-RecentCommandSnippets -Count 5
        if ($recentSnippets.Count -gt 0) {
            Write-Host "`nRecent snippets:" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG"))
            foreach ($snippet in $recentSnippets) {
                Write-Host "  [$($snippet.Id.Substring(0,6))] $($snippet.Description)" -NoNewline
                if ($snippet.Hotkey) { Write-Host " ($($snippet.Hotkey))" -NoNewline -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.AccentFG")) }
                Write-Host " - Used: $($snippet.UseCount)" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
            }
        }
        Write-Host "`n[A]dd snippet"; Write-Host "[S]earch/Browse snippets"; Write-Host "[E]xecute by ID"
        Write-Host "[D]elete by ID"; Write-Host "[L]ist Categories"; Write-Host "List [H]otkeys"; Write-Host "[B]ack to Tools Menu"
        $choice = Read-Host "`nChoice"
        $actionTaken = $true
        switch ($choice.ToLower()) {
            "a" { Add-CommandSnippet }
            "s" { Search-CommandSnippets }
            "e" { $idToExecute = Read-Host "Snippet ID to execute"; if (-not [string]::IsNullOrWhiteSpace($idToExecute)) { Execute-CommandSnippet -Id $idToExecute } else { $actionTaken = $false } }
            "d" { $idToDelete = Read-Host "Snippet ID to delete"; if (-not [string]::IsNullOrWhiteSpace($idToDelete)) { Remove-CommandSnippet -IdInput $idToDelete } else { $actionTaken = $false } }
            "l" { Show-SnippetCategories }
            "h" { Show-SnippetHotkeys }
            "b" { return }
            default { if (-not [string]::IsNullOrEmpty($choice)) { Write-Warning "Unknown command." }; $actionTaken = $false }
        }
        if ($actionTaken) { Write-Host "`nPress Enter to continue..."; Read-Host }
    }
}

function global:Get-RecentCommandSnippets {
    param([int]$Count = 10)
    $snippets = $script:Data.Tasks | Where-Object { $_.IsCommand -eq $true }
    $sortedSnippets = $snippets | Sort-Object @{Expression = { $_.UseCount }; Descending = $true}, @{Expression = { if ($_.LastUsed) { try {[DateTime]::Parse($_.LastUsed)} catch {[DateTime]::MinValue} } else { [DateTime]::MinValue } }; Descending = $true}, Description
    return $sortedSnippets | Select-Object -First $Count
}

function global:Show-SnippetCategories {
    Write-Header "Snippet Categories"
    $snippets = $script:Data.Tasks | Where-Object { $_.IsCommand -eq $true }
    if ($snippets.Count -eq 0) { Write-Host "No snippets found to categorize." -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")); return }
    $categories = $snippets | Group-Object Category | Sort-Object Count -Descending
    if ($categories.Count -eq 0) { Write-Host "No categories assigned to snippets." -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")); return }
    Write-Host "Category usage:" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG"))
    foreach ($catGroup in $categories) {
        $categoryName = if ([string]::IsNullOrEmpty($catGroup.Name)) {"[Uncategorized]"} else {$catGroup.Name}
        Write-Host "  $categoryName $($catGroup.Count) snippet(s)"
        $topInCategory = $catGroup.Group | Sort-Object UseCount -Descending | Sort-Object Description | Select-Object -First 3
        foreach ($snippet in $topInCategory) { Write-Host "    - $($snippet.Description) (Used: $($snippet.UseCount))" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")) }
    }
}

function global:Show-SnippetHotkeys {
    Write-Header "Snippet Hotkeys"
    $snippetsWithHotkeys = $script:Data.Tasks | Where-Object { $_.IsCommand -eq $true -and (-not [string]::IsNullOrEmpty($_.Hotkey)) }
    if ($snippetsWithHotkeys.Count -eq 0) { Write-Host "No hotkeys assigned to any snippets." -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")); return }
    Write-Host "Assigned hotkeys:" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG"))
    foreach ($snippet in $snippetsWithHotkeys | Sort-Object Hotkey) { Write-Host "  $($snippet.Hotkey): $($snippet.Description) (ID: $($snippet.Id.Substring(0,6)))" }
    Write-Warning "`nNote: Actual hotkey binding requires an external keyboard hook implementation."
}

function global:Edit-CommandSnippetSettings {
    Write-Header "Command Snippet Settings"
    if (-not $script:Data.Settings.CommandSnippets) { $script:Data.Settings.CommandSnippets = (Get-DefaultSettings).CommandSnippets }
    $csSettings = $script:Data.Settings.CommandSnippets
    Write-Host "Current settings:" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG"))
    Write-Host "  Enable Hotkeys:       $(if ($csSettings.EnableHotkeys) { 'Yes' } else { 'No' }) (Note: actual binding is external)"
    Write-Host "  Auto-Copy on Add:     $(if ($csSettings.AutoCopyToClipboard) { 'Yes' } else { 'No' })"
    Write-Host "  Show in Task List:   $(if ($csSettings.ShowInTaskList) { 'Yes' } else { 'No' })"
    Write-Host "  Default Category:    $($csSettings.DefaultCategory)"
    Write-Host "  Recent Snippets Limit: $($csSettings.RecentLimit)"
    Write-Host "`nLeave empty to keep current value." -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
    $enableHotkeysInput = Read-Host "`nEnable hotkeys? (Y/N)"; if (-not [string]::IsNullOrWhiteSpace($enableHotkeysInput)) { $csSettings.EnableHotkeys = ($enableHotkeysInput.ToUpper() -eq 'Y') }
    $autoCopyInput = Read-Host "`nAuto-copy to clipboard when adding a new snippet? (Y/N)"; if (-not [string]::IsNullOrWhiteSpace($autoCopyInput)) { $csSettings.AutoCopyToClipboard = ($autoCopyInput.ToUpper() -eq 'Y') }
    $showInTasksInput = Read-Host "`nShow command snippets in the main task list views? (Y/N)"; if (-not [string]::IsNullOrWhiteSpace($showInTasksInput)) { $csSettings.ShowInTaskList = ($showInTasksInput.ToUpper() -eq 'Y') }
    $newDefaultCategory = Read-Host "`nDefault category for new snippets (current: $($csSettings.DefaultCategory))"; if (-not [string]::IsNullOrWhiteSpace($newDefaultCategory)) { $csSettings.DefaultCategory = $newDefaultCategory }
    $newRecentLimitStr = Read-Host "`nNumber of recent snippets to show (current: $($csSettings.RecentLimit))"
    if (-not [string]::IsNullOrWhiteSpace($newRecentLimitStr)) { try { $limit = [int]$newRecentLimitStr; if ($limit -ge 0) { $csSettings.RecentLimit = $limit } else { Write-Warning "Limit must be non-negative."} } catch { Write-Warning "Invalid number format for limit." } }
    Save-UnifiedData
    Write-Success "Command Snippet settings updated!"
}

#endregion

#region Task Management Functions

function global:Add-TodoTask {
    Write-Header "Add New Task"
    $description = Read-Host "`nTask description"
    if ([string]::IsNullOrEmpty($description)) { Write-Error "Task description cannot be empty!"; return }
    Write-Host "`nPriority: [C]ritical, [H]igh, [M]edium, [L]ow (default: $($script:Data.Settings.DefaultPriority))" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
    $priorityInput = Read-Host "Priority"
    $priority = switch ($priorityInput.ToUpper()) { "C" { "Critical" } "H" { "High" } "L" { "Low" } "M" { "Medium" } default { $script:Data.Settings.DefaultPriority } }
    $existingCategories = $script:Data.Tasks | Where-Object { ($_.IsCommand -ne $true) -and (-not [string]::IsNullOrEmpty($_.Category)) } | Select-Object -ExpandProperty Category -Unique | Sort-Object
    if ($existingCategories) { Write-Host "`nExisting categories: $($existingCategories -join ', ')" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.AccentFG")) }
    $category = Read-Host "Category (default: $($script:Data.Settings.DefaultCategory))"
    if ([string]::IsNullOrEmpty($category)) { $category = $script:Data.Settings.DefaultCategory }
    Write-Host "`nLink to project? (Y/N)"
    $linkProjectChoice = Read-Host
    $projectKey = $null
    if ($linkProjectChoice.ToUpper() -eq 'Y') {
        Show-ProjectsAndTemplates -Simple
        $projectKeyInput = Read-Host "`nProject key (leave empty if none)"
        if (-not [string]::IsNullOrWhiteSpace($projectKeyInput)) { if (Get-ProjectOrTemplate $projectKeyInput) { $projectKey = $projectKeyInput } else { Write-Warning "Project '$projectKeyInput' not found." } }
    }
    Write-Host "`nStart date (optional): Enter date (YYYY-MM-DD), 'today', 'tomorrow', or '+X' for X days from now" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
    $startDateInput = Read-Host "Start date"
    $startDate = $null
    if (-not [string]::IsNullOrWhiteSpace($startDateInput)) { try { $parsedDate = switch -Regex ($startDateInput.ToLower()) { '^today$' { [datetime]::Today } '^tomorrow$' { [datetime]::Today.AddDays(1) } '^\+(\d+)$' { [datetime]::Today.AddDays([int]$Matches[1]) } default { [datetime]::Parse($startDateInput) } }; $startDate = $parsedDate.ToString("yyyy-MM-dd") } catch { Write-Warning "Invalid start date format." } }
    Write-Host "`nDue date (optional): Enter date (YYYY-MM-DD), 'today', 'tomorrow', or '+X' for X days from now" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
    $dueDateInput = Read-Host "Due date"
    $dueDate = $null
    if (-not [string]::IsNullOrWhiteSpace($dueDateInput)) { try { $parsedDueDate = switch -Regex ($dueDateInput.ToLower()) { '^today$' { [datetime]::Today } '^tomorrow$' { [datetime]::Today.AddDays(1) } '^\+(\d+)$' { [datetime]::Today.AddDays([int]$Matches[1]) } default { [datetime]::Parse($dueDateInput) } }; $dueDate = $parsedDueDate.ToString("yyyy-MM-dd") } catch { Write-Warning "Invalid due date format." } }
    Write-Host "`nTags (comma-separated, optional):" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
    $tagsInput = Read-Host "Tags"
    $tags = if (-not [string]::IsNullOrWhiteSpace($tagsInput)) { $tagsInput -split ',' | ForEach-Object { $_.Trim() } | Where-Object { -not [string]::IsNullOrWhiteSpace($_) } } else { @() }
    $estimatedTimeInput = Read-Host "`nEstimated time in hours (optional, e.g., 2.5)"
    $estimatedTime = 0.0
    if (-not [string]::IsNullOrWhiteSpace($estimatedTimeInput)) { try { $estimatedTime = [double]$estimatedTimeInput } catch { Write-Warning "Invalid estimate format." } }
    $subtasks = @()
    Write-Host "`nAdd subtasks? (Y/N)" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
    $addSubtasksChoice = Read-Host
    if ($addSubtasksChoice.ToUpper() -eq 'Y') {
        Write-Host "Enter subtasks (empty line to finish):" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
        while ($true) { $subtaskDesc = Read-Host "  Subtask"; if ([string]::IsNullOrEmpty($subtaskDesc)) { break }; $subtasks += @{ Description = $subtaskDesc; Completed = $false; CompletedDate = $null } }
    }
    $newTask = @{
        Id = New-TodoId; Description = $description; Priority = $priority; Category = $category; ProjectKey = $projectKey
        StartDate = $startDate; DueDate = $dueDate; Tags = $tags; Progress = 0; Completed = $false
        CreatedDate = [datetime]::Now.ToString("yyyy-MM-dd HH:mm:ss"); CompletedDate = $null; EstimatedTime = $estimatedTime
        TimeSpent = 0.0; Subtasks = $subtasks; Notes = ""; LastModified = [datetime]::Now.ToString("yyyy-MM-dd HH:mm:ss"); IsCommand = $false
    }
    $script:Data.Tasks += $newTask
    if ($projectKey) { Update-ProjectStatistics -ProjectKey $projectKey }
    Save-UnifiedData
    Write-Success "Task added successfully!"; Write-Host "ID: $($newTask.Id)" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
    if ($script:Data.Settings.EnableTimeTracking -and $projectKey) { if ((Read-Host "`nStart timer for this task? (Y/N)").ToUpper() -eq 'Y') { Start-Timer -ProjectKeyParam $projectKey -TaskIdParam $newTask.Id } }
}

function global:Quick-AddTask {
    param([string]$InputString)
    if (-not $InputString) { $InputString = Read-Host "Quick add task (e.g., 'My new task #work @urgent !High due:tomorrow project:PROJ1 est:2.5')"; if([string]::IsNullOrWhiteSpace($InputString)) { Write-Info "Quick add cancelled."; return } }
    $description = $InputString; $category = $script:Data.Settings.DefaultCategory; $tags = @(); $priority = $script:Data.Settings.DefaultPriority; $dueDate = $null; $startDate = $null; $projectKey = $null; $estimatedTime = 0.0
    if ($description -match '#(\S+)') { $category = $Matches[1]; $description = $description -replace ('#' + [regex]::Escape($Matches[1])), '' }
    $tagMatches = [regex]::Matches($description, '@(\S+)'); foreach ($match in $tagMatches) { $tags += $match.Groups[1].Value; $description = $description -replace ('@' + [regex]::Escape($match.Groups[1].Value)), '' }
    if ($description -match '!(critical|high|medium|low|c|h|m|l)\b') { $priority = switch ($Matches[1].ToLower()) { "c" { "Critical" } "critical" { "Critical" } "h" { "High" } "high" { "High" } "l" { "Low" } "low" { "Low" } default { "Medium" } }; $description = $description -replace ('!' + [regex]::Escape($Matches[1])), '' }
    if ($description -match 'project:(\S+)') { $extractedProjectKey = $Matches[1]; if (Get-ProjectOrTemplate $extractedProjectKey) { $projectKey = $extractedProjectKey } else { Write-Warning "Unknown project: $extractedProjectKey" }; $description = $description -replace ('project:' + [regex]::Escape($Matches[1])), '' }
    if ($description -match 'est:(\d+\.?\d*)') { try { $estimatedTime = [double]$Matches[1] } catch { $estimatedTime = 0.0 }; $description = $description -replace ('est:' + [regex]::Escape($Matches[1])), '' }
    if ($description -match 'due:(\S+)') { $dueDateStr = $Matches[1]; try { $parsedDueDate = switch -Regex ($dueDateStr.ToLower()) { '^today$' { [datetime]::Today } '^tomorrow$' { [datetime]::Today.AddDays(1) } '^mon(day)?$' { Get-NextWeekday 1 } '^tue(sday)?$' { Get-NextWeekday 2 } '^wed(nesday)?$' { Get-NextWeekday 3 } '^thu(rsday)?$' { Get-NextWeekday 4 } '^fri(day)?$' { Get-NextWeekday 5 } '^sat(urday)?$' { Get-NextWeekday 6 } '^sun(day)?$' { Get-NextWeekday 0 } '^\+(\d+)$' { [datetime]::Today.AddDays([int]$Matches[1]) } default { [datetime]::Parse($dueDateStr) } }; $dueDate = $parsedDueDate.ToString("yyyy-MM-dd") } catch { Write-Warning "Invalid due date format '$dueDateStr'." }; $description = $description -replace ('due:' + [regex]::Escape($Matches[1])), '' }
    $description = $description.Trim() -replace '\s+', ' '; if ([string]::IsNullOrEmpty($description)) { Write-Error "Task description cannot be empty!"; return }
    $newTask = @{ Id = New-TodoId; Description = $description; Priority = $priority; Category = $category; ProjectKey = $projectKey; StartDate = $startDate; DueDate = $dueDate; Tags = $tags; Progress = 0; Completed = $false; CreatedDate = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss"); CompletedDate = $null; EstimatedTime = $estimatedTime; TimeSpent = 0.0; Subtasks = @(); Notes = ""; LastModified = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss"); IsCommand = $false }
    $script:Data.Tasks += $newTask; if ($projectKey) { Update-ProjectStatistics -ProjectKey $projectKey }; Save-UnifiedData
    Write-Success "Quick added: '$description'"; if ($priority -ne $script:Data.Settings.DefaultPriority) { Write-Host "   Priority: $priority" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")) }; if ($dueDate) { Write-Host "   Due: $(Format-TodoDate $dueDate)" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")) }; if ($projectKey) { Write-Host "   Project: $((Get-ProjectOrTemplate $projectKey).Name)" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")) }; if ($tags.Count -gt 0) { Write-Host "   Tags: $($tags -join ', ')" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")) }; if ($estimatedTime -gt 0) { Write-Host "   Est. Time: ${estimatedTime}h" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")) }
}

function global:Complete-Task {
    param([string]$TaskIdInput)
    $idToComplete = $TaskIdInput; if (-not $idToComplete) { Show-TasksView; $idToComplete = Read-Host "`nEnter task ID to complete"; if ([string]::IsNullOrWhiteSpace($idToComplete)) { Write-Info "Cancelled."; return } }
    $task = $script:Data.Tasks | Where-Object { $_.Id -like "$idToComplete*" -and ($_.IsCommand -ne $true) } | Select-Object -First 1
    if (-not $task) { Write-Error "Task with ID starting '$idToComplete' not found!"; return }; if ($task.Completed) { Write-Info "Task '$($task.Description)' is already completed!"; return }
    if ($task.Subtasks -and ($task.Subtasks | Where-Object { -not $_.Completed }).Count -gt 0) { $uncompletedCount = ($task.Subtasks | Where-Object { -not $_.Completed }).Count; Write-Warning "Task has $uncompletedCount uncompleted subtask(s)."; if ((Read-Host "Complete anyway? (Y/N)").ToUpper() -ne 'Y') { Write-Info "Cancelled."; return } }
    $task.Completed = $true; $task.Progress = 100; $task.CompletedDate = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss"); $task.LastModified = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
    if ($task.ProjectKey) { Update-ProjectStatistics -ProjectKey $task.ProjectKey }; Save-UnifiedData
    Write-Success "Completed: $($task.Description)"
    if ($task.TimeSpent -gt 0) { Write-Host "   Time spent: $($task.TimeSpent) hours" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")); if ($task.EstimatedTime -gt 0 -and $task.TimeSpent -gt 0) { $efficiency = [Math]::Round(($task.EstimatedTime / $task.TimeSpent) * 100, 0); Write-Host "   Efficiency: $efficiency% of estimate" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")) } }
}

function global:Update-TaskProgress {
    param([string]$TaskIdInput)
    $idToUpdate = $TaskIdInput; if (-not $idToUpdate) { Show-TasksView; $idToUpdate = Read-Host "`nEnter task ID to update progress"; if ([string]::IsNullOrWhiteSpace($idToUpdate)) { Write-Info "Cancelled."; return } }
    $task = $script:Data.Tasks | Where-Object { $_.Id -like "$idToUpdate*" -and ($_.IsCommand -ne $true) } | Select-Object -First 1
    if (-not $task) { Write-Error "Task with ID starting '$idToUpdate' not found!"; return }
    Write-Host "`nTask: $($task.Description) (ID: $($task.Id.Substring(0,6)))" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.AccentFG")); Write-Host "Current progress: $($task.Progress)%"; Draw-ProgressBar -Percent $task.Progress; Write-Host ""
    if ($task.Subtasks -and $task.Subtasks.Count -gt 0) { $completedSubtasks = ($task.Subtasks | Where-Object { -not $_.Completed }).Count; $calculatedProgress = [Math]::Round(($completedSubtasks / $task.Subtasks.Count) * 100, 0); Write-Host "Progress based on subtasks: $calculatedProgress%" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")); if ((Read-Host "`nUpdate based on: [S]ubtasks, or [M]anual entry? (S/M)").ToUpper() -eq 'S') { $task.Progress = $calculatedProgress; if ($task.Progress -eq 100 -and (-not $task.Completed)) { $task.Completed = $true; $task.CompletedDate = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss"); Write-Info "Task auto-completed." } elseif ($task.Progress -lt 100 -and $task.Completed) { $task.Completed = $false; $task.CompletedDate = $null; Write-Info "Task re-opened." }; $task.LastModified = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss"); Save-UnifiedData; Write-Success "Progress updated to $calculatedProgress%!"; return } }
    $newProgressInput = Read-Host "New progress percentage (0-100)"; try { $progressValue = [int]$newProgressInput; if ($progressValue -lt 0 -or $progressValue -gt 100) { throw "Out of range." }; $task.Progress = $progressValue; if ($progressValue -eq 100 -and (-not $task.Completed)) { $task.Completed = $true; $task.CompletedDate = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss"); Write-Info "Task marked as completed." } elseif ($progressValue -lt 100 -and $task.Completed) { $task.Completed = $false; $task.CompletedDate = $null; Write-Info "Task marked as not completed." }; $task.LastModified = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss"); Save-UnifiedData; Write-Success "Progress updated to $progressValue%!" } catch { Write-Error "Invalid progress value! $_" }
}

function global:Edit-Task {
    param([string]$TaskIdInput)
    $idToEdit = $TaskIdInput; if (-not $idToEdit) { Show-TasksView; $idToEdit = Read-Host "`nEnter task ID to edit"; if ([string]::IsNullOrWhiteSpace($idToEdit)) { Write-Info "Edit cancelled."; return } }
    $task = $script:Data.Tasks | Where-Object { $_.Id -like "$idToEdit*" -and ($_.IsCommand -ne $true) } | Select-Object -First 1
    if (-not $task) { Write-Error "Task with ID starting '$idToEdit' not found!"; return }
    Write-Header "Edit Task: $($task.Id.Substring(0,6)) - $($task.Description)"; Write-Host "Leave field empty to keep current value." -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
    $originalTaskSnapshot = $task.PSObject.Copy(); $changesMade = $false
    $newDesc = Read-Host "Description (current: $($task.Description))"; if (-not [string]::IsNullOrWhiteSpace($newDesc) -and $newDesc -ne $task.Description) { $task.Description = $newDesc }
    $newPriorityInput = Read-Host "Priority (current: $($task.Priority)) - [C]ritical, [H]igh, [M]edium, [L]ow"; if (-not [string]::IsNullOrWhiteSpace($newPriorityInput)) { $task.Priority = switch ($newPriorityInput.ToUpper()) { "C" { "Critical" } "H" { "High" } "M" { "Medium" } "L" { "Low" } default { $task.Priority } } }
    $newCategory = Read-Host "Category (current: $($task.Category))"; if (-not [string]::IsNullOrWhiteSpace($newCategory) -and $newCategory -ne $task.Category) { $task.Category = $newCategory }
    $currentProjectName = if ($task.ProjectKey) { (Get-ProjectOrTemplate $task.ProjectKey).Name } else { 'None' }; Write-Host "Project (current: $currentProjectName - key: $($task.ProjectKey))"; Show-ProjectsAndTemplates -Simple; $newProjectKeyInput = Read-Host "New project key (or 'none' to remove)"; if (-not [string]::IsNullOrWhiteSpace($newProjectKeyInput)) { if ($newProjectKeyInput.ToLower() -in @('none', 'clear')) { $task.ProjectKey = $null } elseif (Get-ProjectOrTemplate $newProjectKeyInput) { $task.ProjectKey = $newProjectKeyInput } else { Write-Warning "Project key '$newProjectKeyInput' not found." } }
    $currentDueDateDisplay = if ($task.DueDate) { Format-TodoDate $task.DueDate } else { 'None' }; $newDueDateInput = Read-Host "Due Date (current: $currentDueDateDisplay) - YYYY-MM-DD, today, +X, or 'clear'"; if (-not [string]::IsNullOrWhiteSpace($newDueDateInput)) { if ($newDueDateInput.ToLower() -eq 'clear') { $task.DueDate = $null } else { try { $parsedDueDate = switch -Regex ($newDueDateInput.ToLower()) { '^today$' { [datetime]::Today } '^tomorrow$' { [datetime]::Today.AddDays(1) } '^\+(\d+)$' { [datetime]::Today.AddDays([int]$Matches[1]) } default { [datetime]::Parse($newDueDateInput) } }; $task.DueDate = $parsedDueDate.ToString("yyyy-MM-dd") } catch { Write-Warning "Invalid date format." } } }
    $newEstimateInput = Read-Host "Estimated Time (current: $($task.EstimatedTime)h)"; if (-not [string]::IsNullOrWhiteSpace($newEstimateInput)) { try { $task.EstimatedTime = [double]$newEstimateInput } catch { Write-Warning "Invalid number for estimate." } }
    $currentTagsDisplay = if ($task.Tags -and $task.Tags.Count -gt 0) { $task.Tags -join ', ' } else { "None" }; $newTagsInput = Read-Host "Tags (current: $currentTagsDisplay) - comma-separated, or 'clear'"; if ($newTagsInput -ne $null) { if ($newTagsInput.ToLower() -eq 'clear' -or [string]::IsNullOrWhiteSpace($newTagsInput)) { $task.Tags = @() } else { $task.Tags = $newTagsInput -split ',' | ForEach-Object { $_.Trim() } | Where-Object { -not [string]::IsNullOrWhiteSpace($_) } } }
    
    $editNotesChoice = Read-Host "Edit notes? Current: $(if ([string]::IsNullOrWhiteSpace($task.Notes)) { 'No notes' } else { 'Has notes' }) (Y/N)"; if ($editNotesChoice.ToUpper() -eq 'Y') { Write-Host "Current notes:"; Write-Host $task.Notes -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")); Write-Host "`nEnter new notes (press Esc when finished, or type 'clear' on first line and Esc to empty):"; $newNotes = Read-MultilineText; $firstLine = ($newNotes -split "`n")[0].Trim(); if ($firstLine.ToLower() -eq 'clear') { $task.Notes = "" } elseif ($newNotes -ne $task.Notes) { $task.Notes = $newNotes } }
    
    foreach($prop in $originalTaskSnapshot.PSObject.Properties.Name){ if($task.$prop -ne $originalTaskSnapshot.$prop){ $changesMade = $true; break } }; if (($task.Tags | ConvertTo-Json) -ne ($originalTaskSnapshot.Tags | ConvertTo-Json)) { $changesMade = $true }
    if ($changesMade) { $task.LastModified = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss"); if ($originalTaskSnapshot.ProjectKey -and $originalTaskSnapshot.ProjectKey -ne $task.ProjectKey) { Update-ProjectStatistics -ProjectKey $originalTaskSnapshot.ProjectKey }; if ($task.ProjectKey) { Update-ProjectStatistics -ProjectKey $task.ProjectKey }; Save-UnifiedData; Write-Success "Task '$($task.Description)' updated!" } else { Write-Info "No changes made." }
}

function global:Manage-Subtasks {
    param([string]$TaskIdInput)
    
    $idForSubtasks = $TaskIdInput
    if (-not $idForSubtasks) {
        Show-TasksView
        $idForSubtasks = Read-Host "`nEnter task ID to manage subtasks (or Enter to cancel)"
        if ([string]::IsNullOrWhiteSpace($idForSubtasks)) { Write-Info "Subtask management cancelled."; return }
    }
   
    $task = $script:Data.Tasks | Where-Object { $_.Id -like "$idForSubtasks*" -and ($_.IsCommand -ne $true) } | Select-Object -First 1
   
    if (-not $task) { Write-Error "Task with ID starting '$idForSubtasks' not found!"; return }
    if ($null -eq $task.Subtasks -or -not ($task.Subtasks -is [System.Array])) { $task.Subtasks = @() }
 
    while ($true) {
        Clear-Host
        Write-Header "Manage Subtasks for: $($task.Description) (ID: $($task.Id.Substring(0,6)))"
       
        if ($task.Subtasks.Count -eq 0) { Write-Host "`nNo subtasks yet." -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")) }
        else {
            Write-Host "`nSubtasks:"
            for ($i = 0; $i -lt $task.Subtasks.Count; $i++) {
                $subtask = $task.Subtasks[$i]
                $icon = if ($subtask.Completed) { Apply-PSStyle -Text "✓" -FG (Get-ThemeProperty "Palette.SuccessFG") } else { "○" }
                $color = if ($subtask.Completed) { (Get-ThemeProperty "Palette.SubtleFG") } else { (Get-ThemeProperty "Palette.PrimaryFG") }
                Write-Host "  [$i] $(Apply-PSStyle -Text "$icon $($subtask.Description)" -FG $color)"
            }
            $completedCount = ($task.Subtasks | Where-Object { $_.Completed }).Count
            Write-Host "`nProgress from subtasks: $completedCount/$($task.Subtasks.Count) completed" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SuccessFG"))
        }
       
        Write-Host "`n[A]dd subtask, [T]oggle complete, [E]dit subtask, [D]elete subtask, [B]ack"
        $choice = Read-Host "Choice"
        $actionTaken = $true
 
        switch ($choice.ToLower()) {
            "a" {
                $desc = Read-Host "New subtask description"
                if (-not [string]::IsNullOrWhiteSpace($desc)) {
                    $task.Subtasks += @{ Description = $desc; Completed = $false; CompletedDate = $null }
                    Write-Success "Subtask added!"
                } else { Write-Info "Subtask not added (empty description)."; $actionTaken = $false }
            }
            "t" {
                if ($task.Subtasks.Count -eq 0) { Write-Error "No subtasks to toggle!"; $actionTaken = $false; break }
                $indexInput = Read-Host "Subtask number to toggle"
                try {
                    $idx = [int]$indexInput
                    if ($idx -ge 0 -and $idx -lt $task.Subtasks.Count) {
                        $task.Subtasks[$idx].Completed = -not $task.Subtasks[$idx].Completed
                        $task.Subtasks[$idx].CompletedDate = if ($task.Subtasks[$idx].Completed) { (Get-Date).ToString("yyyy-MM-dd HH:mm:ss") } else { $null }
                        Write-Success "Subtask completion toggled!"
                    } else { Write-Error "Invalid index!"; $actionTaken = $false }
                } catch { Write-Error "Invalid index format!"; $actionTaken = $false }
            }
            "e" {
                 if ($task.Subtasks.Count -eq 0) { Write-Error "No subtasks to edit!"; $actionTaken = $false; break }
                 $indexInput = Read-Host "Subtask number to edit"
                 try {
                    $idx = [int]$indexInput
                    if ($idx -ge 0 -and $idx -lt $task.Subtasks.Count) {
                        $newSubDesc = Read-Host "New description for '$($task.Subtasks[$idx].Description)'"
                        if(-not [string]::IsNullOrWhiteSpace($newSubDesc)){
                            $task.Subtasks[$idx].Description = $newSubDesc
                            Write-Success "Subtask description updated."
                        } else { Write-Info "Description not changed (empty input)."; $actionTaken = $false}
                    } else { Write-Error "Invalid index!"; $actionTaken = $false }
                 } catch { Write-Error "Invalid index format!"; $actionTaken = $false }
            }
            "d" {
                if ($task.Subtasks.Count -eq 0) { Write-Error "No subtasks to delete!"; $actionTaken = $false; break }
                $indexToDelete = Read-Host "Subtask number to delete"
                try {
                    $idx = [int]$indexToDelete
                    if ($idx -ge 0 -and $idx -lt $task.Subtasks.Count) {
                        Write-Warning "Delete subtask '$($task.Subtasks[$idx].Description)'?"
                        if((Read-Host "Confirm (Y/N)").ToUpper() -eq 'Y'){
                            $task.Subtasks = @($task.Subtasks | Select-Object -Index (0..($task.Subtasks.Count-1) | Where-Object { $_ -ne $idx }))
                            Write-Success "Subtask deleted!"
                        } else { Write-Info "Deletion cancelled."; $actionTaken = $false}
                    } else { Write-Error "Invalid index!"; $actionTaken = $false }
                } catch { Write-Error "Invalid index format!"; $actionTaken = $false }
            }
            "b" { return }
            default {
                if (-not [string]::IsNullOrEmpty($choice)) { Write-Warning "Unknown command." }
                $actionTaken = $false
            }
        }
        if ($actionTaken) {
            if ($task.Subtasks.Count -gt 0) {
                $completedSubtasksCount = ($task.Subtasks | Where-Object { $_.Completed }).Count
                $task.Progress = [Math]::Round(($completedSubtasksCount / $task.Subtasks.Count) * 100, 0)
            } else {
                 if (-not $task.Completed -and $task.Progress -ne 100) { $task.Progress = 0 }
            }
            if ($task.Progress -eq 100 -and (-not $task.Completed)) {
                 $task.Completed = $true; $task.CompletedDate = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
            } elseif ($task.Progress -lt 100 -and $task.Completed) {
                 $task.Completed = $false; $task.CompletedDate = $null
            }
            $task.LastModified = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss")
            Save-UnifiedData
            if ($choice.ToLower() -ne "b") { Start-Sleep -Seconds 1 }
        }
    }
}
 
function global:Remove-Task {
    param([string]$TaskIdInput)
    
    $idToRemove = $TaskIdInput
    if (-not $idToRemove) {
        Show-TasksView
        $idToRemove = Read-Host "`nEnter task ID to delete (or Enter to cancel)"
        if ([string]::IsNullOrWhiteSpace($idToRemove)) { Write-Info "Deletion cancelled."; return }
    }
   
    $task = $script:Data.Tasks | Where-Object { $_.Id -like "$idToRemove*" -and ($_.IsCommand -ne $true) } | Select-Object -First 1
   
    if (-not $task) { Write-Error "Task with ID starting '$idToRemove' not found!"; return }
   
    Write-Warning "Permanently delete task: '$($task.Description)' (ID: $($task.Id.Substring(0,6)))?"
    if ($task.TimeSpent -gt 0) { Write-Warning "This task has $($task.TimeSpent) hours logged! This time will NOT be deleted from project totals unless manually adjusted." }
    if ($task.Subtasks -and $task.Subtasks.Count -gt 0) { Write-Warning "This task has $($task.Subtasks.Count) subtask(s) which will also be deleted."}
   
    if ((Read-Host "Type 'yes' to confirm deletion").ToLower() -eq 'yes') {
        $originalProjectKey = $task.ProjectKey
        $script:Data.Tasks = $script:Data.Tasks | Where-Object { $_.Id -ne $task.Id }
       
        if ($originalProjectKey) { Update-ProjectStatistics -ProjectKey $originalProjectKey }
        Save-UnifiedData
        Write-Success "Task '$($task.Description)' deleted!"
    } else {
        Write-Info "Deletion cancelled."
    }
}
 
function global:Archive-CompletedTasks {
    $completedTasks = $script:Data.Tasks | Where-Object { $_.Completed -and ($_.IsCommand -ne $true) }
    
    if ($completedTasks.Count -eq 0) { Write-Info "No completed tasks to archive."; return }
 
    $cutoffDate = [datetime]::Today.AddDays(-$script:Data.Settings.AutoArchiveDays)
    $tasksToAutoArchive = $completedTasks | Where-Object {
        (-not [string]::IsNullOrEmpty($_.CompletedDate)) -and ([datetime]::Parse($_.CompletedDate).Date -lt $cutoffDate.Date)
    }
   
    $tasksToConsider = $tasksToAutoArchive
    $archiveMode = "automatic"
 
    if ($tasksToAutoArchive.Count -eq 0) {
        Write-Info "No tasks old enough for automatic archiving (older than $($script:Data.Settings.AutoArchiveDays) days)."
        if ((Read-Host "`nArchive all $($completedTasks.Count) completed task(s) manually now? (Y/N)").ToUpper() -eq 'Y') {
            $tasksToConsider = $completedTasks
            $archiveMode = "manual"
        } else {
            Write-Info "Archive operation cancelled."; return
        }
    } else {
        if ((Read-Host "Archive $($tasksToAutoArchive.Count) task(s) older than $($script:Data.Settings.AutoArchiveDays) days? (Y/N)").ToUpper() -ne 'Y') {
            Write-Info "Automatic archive cancelled."; return
        }
    }
   
    if ($tasksToConsider.Count -eq 0) { Write-Info "No tasks selected for archiving."; return }
 
    if ($null -eq $script:Data.ArchivedTasks) { $script:Data.ArchivedTasks = @() }
    $script:Data.ArchivedTasks += $tasksToConsider
 
    $idsToArchive = $tasksToConsider | ForEach-Object {$_.Id}
    $script:Data.Tasks = $script:Data.Tasks | Where-Object { $_.Id -notin $idsToArchive }
   
    $affectedProjects = $tasksToConsider | Where-Object { -not [string]::IsNullOrEmpty($_.ProjectKey) } | Select-Object -ExpandProperty ProjectKey -Unique
    foreach ($projectKey in $affectedProjects) { Update-ProjectStatistics -ProjectKey $projectKey }
   
    Save-UnifiedData
    Write-Success "Archived $($tasksToConsider.Count) task(s) ($archiveMode)."
}
 
function global:View-TaskArchive {
    Clear-Host
    Write-Header "Archived Tasks"
   
    if (-not $script:Data.ArchivedTasks -or $script:Data.ArchivedTasks.Count -eq 0) {
        Write-Host "`n  📭 No archived tasks." -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
        return
    }
   
    $groupedByMonth = $script:Data.ArchivedTasks |
        Where-Object {-not [string]::IsNullOrEmpty($_.CompletedDate)} |
        Group-Object { try { [datetime]::Parse($_.CompletedDate).ToString("yyyy-MM") } catch { "InvalidDate" } } |
        Sort-Object Name -Descending
   
    foreach ($monthGroup in $groupedByMonth) {
        $monthYearDisplay = if ($monthGroup.Name -eq "InvalidDate") { "[Tasks with Invalid Completion Dates]" }
                           else { try { [datetime]::ParseExact($monthGroup.Name, "yyyy-MM", $null).ToString("MMMM yyyy") } catch { $monthGroup.Name } }
        Write-Host "`n  📅 $monthYearDisplay ($($monthGroup.Count) items)" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG"))
       
        foreach ($task in $monthGroup.Group | Sort-Object @{Expression={if([string]::IsNullOrEmpty($_.CompletedDate)) {[DateTime]::MinValue} else {[DateTime]::Parse($_.CompletedDate)}}; Descending=$true}) {
            Write-Host "     ✓ $($task.Description) (ID: $($task.Id.Substring(0,6)))" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
            $completedDateDisplay = if ($task.CompletedDate) { try {([datetime]::Parse($task.CompletedDate)).ToString('MMM dd, yyyy HH:mm')} catch{"N/A"}} else { "N/A" }
            Write-Host "       Completed: $completedDateDisplay" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
           
            if ($task.TimeSpent -gt 0) {
                Write-Host "       Time Spent: $($task.TimeSpent)h" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")) -NoNewline
                if ($task.EstimatedTime -gt 0) { Write-Host " (Est: $($task.EstimatedTime)h)" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")) }
                else { Write-Host }
            }
            if ($task.ProjectKey) {
                $project = Get-ProjectOrTemplate $task.ProjectKey
                if ($project) { Write-Host "       Project: $($project.Name) (Key: $($task.ProjectKey))" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")) }
            }
        }
    }
   
    $totalArchived = $script:Data.ArchivedTasks.Count
    $totalTimeSpent = ($script:Data.ArchivedTasks | Measure-Object -Property TimeSpent -Sum).Sum
    $totalEstimatedTime = ($script:Data.ArchivedTasks | Measure-Object -Property EstimatedTime -Sum).Sum
    
    Write-Host "`n" ("=" * 60) -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
    Write-Host "  Total archived: $totalArchived tasks" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SuccessFG"))
    if ($totalTimeSpent -gt 0) {
        Write-Host "  Total time spent on archived: $totalTimeSpent hours" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SuccessFG"))
        if ($totalEstimatedTime -gt 0 -and $totalTimeSpent -gt 0) {
            $efficiency = [Math]::Round(($totalEstimatedTime / $totalTimeSpent) * 100, 0)
            Write-Host "  Average efficiency (archived): $efficiency% of estimates" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SuccessFG"))
        }
    }
   
    Write-Host "`nPress any key to continue..." -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
    $null = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
}
 
function global:Edit-TaskSettings {
    Write-Header "Task Settings"
    Write-Host "Leave empty to keep current value." -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
 
    $settings = $script:Data.Settings
    
    $newPriorityInput = Read-Host "`nDefault Priority (current: $($settings.DefaultPriority)) - [C]ritical, [H]igh, [M]edium, [L]ow"
    if (-not [string]::IsNullOrWhiteSpace($newPriorityInput)) {
        $settings.DefaultPriority = switch ($newPriorityInput.ToUpper()) {
            "C" { "Critical" } "H" { "High" } "M" { "Medium" } "L" { "Low" }
            default { $settings.DefaultPriority }
        }
    }
 
    $newCategoryInput = Read-Host "`nDefault Category (current: $($settings.DefaultCategory))"
    if (-not [string]::IsNullOrWhiteSpace($newCategoryInput)) {
        $settings.DefaultCategory = $newCategoryInput
    }
 
    $newShowDaysInput = Read-Host "`nDays to show completed tasks in active views (current: $($settings.ShowCompletedDays))"
    if (-not [string]::IsNullOrWhiteSpace($newShowDaysInput)) {
        try {
            $days = [int]$newShowDaysInput
            if ($days -ge 0) { $settings.ShowCompletedDays = $days }
            else { Write-Warning "Days must be non-negative. Not changed."}
        }
        catch { Write-Warning "Invalid number for ShowCompletedDays. Not changed." }
    }
   
    $newArchiveDaysInput = Read-Host "`nDays until completed tasks are auto-archived (current: $($settings.AutoArchiveDays))"
    if (-not [string]::IsNullOrWhiteSpace($newArchiveDaysInput)) {
        try {
            $days = [int]$newArchiveDaysInput
            if ($days -ge 0) { $settings.AutoArchiveDays = $days }
            else { Write-Warning "Days must be non-negative. Not changed."}
        }
        catch { Write-Warning "Invalid number for AutoArchiveDays. Not changed." }
    }
 
    $enableTimeTrackingInput = Read-Host "`nEnable time tracking integration for tasks (Y/N) (current: $(if($settings.EnableTimeTracking){'Yes'}else{'No'}))"
    if(-not [string]::IsNullOrWhiteSpace($enableTimeTrackingInput)){
        $settings.EnableTimeTracking = $enableTimeTrackingInput.ToUpper() -eq 'Y'
    }
 
    Save-UnifiedData
    Write-Success "Task settings updated!"
}
 
#endregion
 
#region Task Status Functions
 
function global:Get-TaskStatus {
    param($Task)
   
    if ($Task.Completed) { return "Completed" }
    if ($Task.Progress -ge 100) { return "Done (Pending Confirmation)" }
    if ($Task.Progress -gt 0) { return "In Progress" }
 
    if (-not [string]::IsNullOrEmpty($Task.DueDate)) {
        try {
            $dueDate = [datetime]::Parse($Task.DueDate).Date
            $today = [datetime]::Today.Date
            $daysUntil = ($dueDate - $today).Days
            if ($daysUntil -lt 0) { return "Overdue" }
            if ($daysUntil -eq 0) { return "Due Today" }
            if ($daysUntil -gt 0 -and $daysUntil -le 3) { return "Due Soon" }
        } catch { }
    }
    if (-not [string]::IsNullOrEmpty($Task.StartDate)) {
         try {
            $startDate = [datetime]::Parse($Task.StartDate).Date
            $today = [datetime]::Today.Date
            if ($startDate -gt $today) { return "Scheduled" }
        } catch { }
    }
    return "Pending"
}
 
function global:Get-PriorityInfo {
    param($Priority)
    switch ($Priority) {
        "Critical" { return @{ Color = (Get-ThemeProperty "Palette.ErrorFG"); Icon = "🔥" } }
        "High" { return @{ Color = (Get-ThemeProperty "Palette.ErrorFG"); Icon = "🔴" } }
        "Medium" { return @{ Color = (Get-ThemeProperty "Palette.WarningFG"); Icon = "🟡" } }
        "Low" { return @{ Color = (Get-ThemeProperty "Palette.SuccessFG"); Icon = "🟢" } }
        default { return @{ Color = (Get-ThemeProperty "Palette.SubtleFG"); Icon = "⚪" } }
    }
}
 
#endregion
 
#region Display Functions (Task Specific Views)
 
function global:Show-TasksView {
    param(
        [string]$Filter = "",
        [string]$SortBy = "Smart",
        [switch]$ShowCompleted,
        [string]$View = "Default" 
    )
   
    $tasksToDisplay = $script:Data.Tasks
    if (-not $script:Data.Settings.CommandSnippets.ShowInTaskList) {
        $tasksToDisplay = $tasksToDisplay | Where-Object { $_.IsCommand -ne $true }
    }
 
    if ($Filter) {
        $tasksToDisplay = $tasksToDisplay | Where-Object {
            $_.Description -like "*$Filter*" -or
            $_.Category -like "*$Filter*" -or
            ($_.Tags -and ($_.Tags -join ' ') -like "*$Filter*") -or
            ($_.ProjectKey -and (Get-ProjectOrTemplate $_.ProjectKey) -and (Get-ProjectOrTemplate $_.ProjectKey).Name -like "*$Filter*") -or
            $_.Id -like "*$Filter*"
        }
    }
   
    if (-not $ShowCompleted) {
        $cutoffDate = [datetime]::Today.AddDays(-$script:Data.Settings.ShowCompletedDays)
        $tasksToDisplay = $tasksToDisplay | Where-Object {
            (-not $_.Completed) -or
            ((-not [string]::IsNullOrEmpty($_.CompletedDate)) -and ([datetime]::Parse($_.CompletedDate).Date -ge $cutoffDate.Date))
        }
    }
    
    $sortedTasks = switch ($SortBy.ToLower()) {
        "smart" {
            $tasksToDisplay | Sort-Object @{Expression={
                $status = Get-TaskStatus $_
                switch($status) {
                    "Overdue" { 1 } "Due Today" { 2 } "Due Soon" { 3 }
                    "In Progress" { 4 } "Done (Pending Confirmation)" {4} "Pending" { 5 } "Scheduled" { 6 }
                    "Completed" { 7 } default { 8 }
                }
            }}, @{Expression={
                switch($_.Priority) {
                    "Critical" { 1 } "High" { 2 } "Medium" { 3 } "Low" { 4 } default { 5 }
                }
            }}, @{Expression={
                if([string]::IsNullOrEmpty($_.DueDate)) {
                    [DateTime]::MaxValue
                } else {
                    try { [DateTime]::Parse($_.DueDate) } catch { [DateTime]::MaxValue }
                }
            }}, @{Expression={
                if([string]::IsNullOrEmpty($_.CreatedDate)) {
                    [DateTime]::MinValue
                } else {
                    try { [DateTime]::Parse($_.CreatedDate) } catch { [DateTime]::MinValue }
                }
            }}
        }
        "priority" {
            $tasksToDisplay | Sort-Object @{Expression={
                switch($_.Priority) {
                    "Critical" { 1 } "High" { 2 } "Medium" { 3 } "Low" { 4 } default { 5 }
                }
            }}, @{Expression={
                if([string]::IsNullOrEmpty($_.DueDate)) {
                    [DateTime]::MaxValue
                } else {
                    try { [DateTime]::Parse($_.DueDate) } catch { [DateTime]::MaxValue }
                }
            }}, @{Expression={
                if([string]::IsNullOrEmpty($_.CreatedDate)) {
                    [DateTime]::MinValue
                } else {
                    try { [DateTime]::Parse($_.CreatedDate) } catch { [DateTime]::MinValue }
                }
            }}
        }
        "duedate" {
            $tasksToDisplay | Sort-Object @{Expression={
                if([string]::IsNullOrEmpty($_.DueDate)) {
                    [DateTime]::MaxValue
                } else {
                    try { [DateTime]::Parse($_.DueDate) } catch { [DateTime]::MaxValue }
                }
            }}, @{Expression={
                switch($_.Priority) {
                    "Critical" { 1 } "High" { 2 } "Medium" { 3 } "Low" { 4 } default { 5 }
                }
            }}
        }
        "created" {
            $tasksToDisplay | Sort-Object @{Expression={
                if([string]::IsNullOrEmpty($_.CreatedDate)) {
                    [DateTime]::MinValue
                } else {
                    try { [DateTime]::Parse($_.CreatedDate) } catch { [DateTime]::MinValue }
                }
            }; Descending = $true}
        }
        "category" {
            $tasksToDisplay | Sort-Object @{Expression={
                if([string]::IsNullOrEmpty($_.Category)) { "zzz" } else { $_.Category }
            }}, @{Expression={
                switch($_.Priority) {
                    "Critical" { 1 } "High" { 2 } "Medium" { 3 } "Low" { 4 } default { 5 }
                }
            }}
        }
        "project" {
            $tasksToDisplay | Sort-Object @{Expression={
                if([string]::IsNullOrEmpty($_.ProjectKey)) { "zzz" } else { $_.ProjectKey }
            }}, @{Expression={
                switch($_.Priority) {
                    "Critical" { 1 } "High" { 2 } "Medium" { 3 } "Low" { 4 } default { 5 }
                }
            }}
        }
        default { $tasksToDisplay }
    }
   
    if ($sortedTasks.Count -eq 0) {
        Write-Host "`n  📭 No tasks found matching current filters." -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG"))
        Show-TaskStatistics $tasksToDisplay
        return
    }
   
    switch ($View.ToLower()) {
        "kanban" { Show-KanbanView $sortedTasks }
        "timeline" { Show-TimelineView $sortedTasks }
        "project" { Show-ProjectTaskView $sortedTasks }
        default { Show-TaskListView $sortedTasks }
    }
   
    Show-TaskStatistics $sortedTasks
}
 
function global:Show-TaskListView {
    param($TasksToDisplay)
    
    $groups = $TasksToDisplay | Group-Object Category | Sort-Object Name
   
    foreach ($group in $groups) {
        $categoryName = if ([string]::IsNullOrEmpty($group.Name)) { "[Uncategorized]" } else { $group.Name }
        Write-Host "`n  📁 $categoryName ($($group.Count) tasks)" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.AccentFG"))
        Write-Host "  " ("-" * ($categoryName.Length + 15)) -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
        
        foreach ($task in $group.Group) { Show-TaskItem $task }
    }
}
 
function global:Show-TaskItem {
    param($Task)
   
    $icon = if ($Task.Completed) { Apply-PSStyle -Text "✅" -FG (Get-ThemeProperty "Palette.SuccessFG") } else { "⬜" }
    $priorityInfo = Get-PriorityInfo $Task.Priority
    $id = $Task.Id.Substring(0, 6)
    $status = Get-TaskStatus $Task
    
    Write-Host "  $icon [$id] " -NoNewline
    Write-Host (Apply-PSStyle -Text $priorityInfo.Icon -FG $priorityInfo.Color) -NoNewline
    Write-Host " " -NoNewline
   
    $descriptionText = $Task.Description
    if ($Task.Completed) {
        Write-Host (Apply-PSStyle -Text $descriptionText -FG (Get-ThemeProperty "Palette.SubtleFG"))
    } else {
        $statusColor = switch ($status) {
            "Overdue" { Get-ThemeProperty "Palette.ErrorFG" }
            "Due Today" { Get-ThemeProperty "Palette.WarningFG" }
            "Due Soon" { Get-ThemeProperty "Palette.InfoFG" }
            "In Progress" { Get-ThemeProperty "Palette.InfoFG" }
            "Done (Pending Confirmation)" { Get-ThemeProperty "Palette.SuccessFG"}
            default { Get-ThemeProperty "Palette.PrimaryFG" }
        }
        Write-Host (Apply-PSStyle -Text $descriptionText -FG $statusColor)
    }
   
    Write-Host "      " -NoNewline
    $detailsParts = @()
 
    if ($status -notin @("Pending", "Completed", "Done (Pending Confirmation)")) {
        $badgeColor = switch ($status) {
            "Overdue" { Get-ThemeProperty "Palette.ErrorFG" }
            "Due Today" { Get-ThemeProperty "Palette.WarningFG" }
            "Due Soon" { Get-ThemeProperty "Palette.InfoFG" }
            "In Progress" { Get-ThemeProperty "Palette.InfoFG" }
            "Scheduled" { Get-ThemeProperty "Palette.AccentFG" }
            default { Get-ThemeProperty "Palette.SubtleFG" }
        }
        $detailsParts += Apply-PSStyle -Text "[$status]" -FG $badgeColor
    }
   
    if (-not [string]::IsNullOrEmpty($Task.DueDate)) {
        $dueDateObj = try {[datetime]::Parse($Task.DueDate)} catch {$null}
        if($dueDateObj){
            $dueDateStr = Format-TodoDate $Task.DueDate
            $daysUntil = ($dueDateObj.Date - [datetime]::Today.Date).Days
            $dateColor = if ($daysUntil -lt 0 -and !$Task.Completed) { Get-ThemeProperty "Palette.ErrorFG" }
                        elseif ($daysUntil -eq 0 -and !$Task.Completed) { Get-ThemeProperty "Palette.WarningFG" }
                        elseif ($daysUntil -gt 0 -and $daysUntil -le 3 -and !$Task.Completed) { Get-ThemeProperty "Palette.InfoFG" }
                        else { Get-ThemeProperty "Palette.SubtleFG" }
            $detailsParts += Apply-PSStyle -Text "📅 $dueDateStr" -FG $dateColor
        }
    }
   
    if ($Task.ProjectKey) {
        $project = Get-ProjectOrTemplate $Task.ProjectKey
        if ($project) {
            $detailsParts += Apply-PSStyle -Text "🏗️  $($project.Name)" -FG (Get-ThemeProperty "Palette.AccentFG")
        }
    }
   
    if ($Task.Tags -and $Task.Tags.Count -gt 0) {
        $detailsParts += Apply-PSStyle -Text "🏷️  $($Task.Tags -join ', ')" -FG (Get-ThemeProperty "Palette.InfoFG")
    }
   
    if ($Task.Progress -gt 0 -and -not $Task.Completed) {
        $detailsParts += Apply-PSStyle -Text "📈 $($Task.Progress)%" -FG (Get-ThemeProperty "Palette.SuccessFG")
    }
   
    if ($Task.TimeSpent -gt 0) {
        $detailsParts += Apply-PSStyle -Text "⏱️  $($Task.TimeSpent)h" -FG (Get-ThemeProperty "Palette.InfoFG")
    }
   
    if ($detailsParts.Count -gt 0) {
        Write-Host ($detailsParts -join (Apply-PSStyle -Text " | " -FG (Get-ThemeProperty "Palette.SubtleFG")))
    } else { Write-Host }
 
    if ($Task.Subtasks -and $Task.Subtasks.Count -gt 0) {
        $completedSubtasks = ($Task.Subtasks | Where-Object { $_.Completed }).Count
        Write-Host "      📌 Subtasks: $completedSubtasks/$($Task.Subtasks.Count) completed" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.InfoFG"))
    }
}
 
function global:Show-KanbanView {
    param($TasksToDisplay)
    
    $columns = @{
        "To Do" = $TasksToDisplay | Where-Object { (-not $_.Completed) -and ($_.Progress -eq 0) -and (Get-TaskStatus $_) -notin @("Scheduled", "Overdue", "Due Today", "Due Soon") }
        "Scheduled/Due" = $TasksToDisplay | Where-Object { (-not $_.Completed) -and ($_.Progress -eq 0) -and (Get-TaskStatus $_) -in @("Scheduled", "Overdue", "Due Today", "Due Soon") }
        "In Progress" = $TasksToDisplay | Where-Object { (-not $_.Completed) -and ($_.Progress -gt 0) -and ($_.Progress -lt 100) }
        "Done" = $TasksToDisplay | Where-Object { $_.Completed -or ($_.Progress -eq 100) }
    }
    $columnOrder = @("To Do", "Scheduled/Due", "In Progress", "Done")
    $columnColors = @{
        "To Do" = (Get-ThemeProperty "Palette.PrimaryFG")
        "Scheduled/Due" = (Get-ThemeProperty "Palette.WarningFG")
        "In Progress" = (Get-ThemeProperty "Palette.InfoFG")
        "Done" = (Get-ThemeProperty "Palette.SuccessFG")
    }
 
    Write-Host "`n  KANBAN BOARD" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.InfoFG"))
    Write-Host "  " ("=" * (($columnOrder.Count * 22) + $columnOrder.Count -1)) -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
    
    $maxItems = 0
    if ($columns.Values.Count -gt 0) {
        $maxItems = ($columns.Values | ForEach-Object { $_.Count } | Measure-Object -Maximum).Maximum
        if ($null -eq $maxItems) {$maxItems = 0}
    }
    if ($maxItems -eq 0) { Write-Host "  No tasks to display in Kanban view." ; return}
 
    $colWidth = 20
    $border = Get-BorderStyleChars
    
    $headerTopLine = "  $($border.TopLeft)"
    $headerTextLine = "  $($border.Vertical)"
    $headerSeparatorLine = "  $($border.TLeft)"
    foreach($colName in $columnOrder){
        $headerTopLine += ($border.Horizontal * $colWidth) + $border.TTop
        $headerTextLine += " $(Apply-PSStyle -Text $colName.ToUpper().PadRight($colWidth -1) -FG $columnColors[$colName])$($border.Vertical)"
        $headerSeparatorLine += ($border.Horizontal * $colWidth) + $border.Cross
    }
    Write-Host ($headerTopLine.Substring(0, $headerTopLine.Length-1) + $border.TopRight)
    Write-Host $headerTextLine
    Write-Host ($headerSeparatorLine.Substring(0, $headerSeparatorLine.Length-1) + $border.TRight)
    
    for ($i = 0; $i -lt $maxItems; $i++) {
        Write-Host "  $($border.Vertical)" -NoNewline
        foreach ($columnName in $columnOrder) {
            $itemsInColumn = $columns[$columnName]
            if ($i -lt $itemsInColumn.Count) {
                $item = $itemsInColumn[$i]
                $text = "$($item.Id.Substring(0,4)): $($item.Description)"
                if ($text.Length -gt ($colWidth - 2)) {
                    $text = $text.Substring(0, $colWidth - 3) + "…"
                }
                $priorityInfo = Get-PriorityInfo $item.Priority
                Write-Host " $(Apply-PSStyle -Text $priorityInfo.Icon -FG $priorityInfo.Color)$($text.PadRight($colWidth - 2))" -NoNewline
            } else {
                Write-Host (" ".PadRight($colWidth)) -NoNewline
            }
            Write-Host "$($border.Vertical)" -NoNewline
        }
        Write-Host
    }
   
    $footerLine = "  $($border.BottomLeft)"
    foreach($colName in $columnOrder){
        $footerLine += ($border.Horizontal * $colWidth) + $border.TBottom
    }
    Write-Host ($footerLine.Substring(0, $footerLine.Length-1) + $border.BottomRight)
}
 
function global:Show-TimelineView {
    param($TasksToDisplay)
    
    Write-Host "`n  📅 TIMELINE VIEW" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.InfoFG"))
    Write-Host "  " ("=" * 60) -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
    
    $today = [datetime]::Today.Date
    $groups = @{
        "Overdue" = $TasksToDisplay | Where-Object { (-not [string]::IsNullOrEmpty($_.DueDate)) -and ([datetime]::Parse($_.DueDate).Date -lt $today) -and (-not $_.Completed) }
        "Today" = $TasksToDisplay | Where-Object { (-not [string]::IsNullOrEmpty($_.DueDate)) -and ([datetime]::Parse($_.DueDate).Date -eq $today) -and (-not $_.Completed) }
        "This Week" = $TasksToDisplay | Where-Object {
            (-not [string]::IsNullOrEmpty($_.DueDate)) -and
            ([datetime]::Parse($_.DueDate).Date -gt $today) -and
            ([datetime]::Parse($_.DueDate).Date -le $today.AddDays(6)) -and
            (-not $_.Completed)
        }
        "Next Week" = $TasksToDisplay | Where-Object {
            (-not [string]::IsNullOrEmpty($_.DueDate)) -and
            ([datetime]::Parse($_.DueDate).Date -gt $today.AddDays(6)) -and
            ([datetime]::Parse($_.DueDate).Date -le $today.AddDays(13)) -and
            (-not $_.Completed)
        }
        "Later" = $TasksToDisplay | Where-Object {
            (-not [string]::IsNullOrEmpty($_.DueDate)) -and
            ([datetime]::Parse($_.DueDate).Date -gt $today.AddDays(13)) -and
            (-not $_.Completed)
        }
        "No Date" = $TasksToDisplay | Where-Object { [string]::IsNullOrEmpty($_.DueDate) -and (-not $_.Completed) }
        "Completed" = $TasksToDisplay | Where-Object {$_.Completed}
    }
   
    foreach ($period in @("Overdue", "Today", "This Week", "Next Week", "Later", "No Date", "Completed")) {
        $itemsInPeriod = $groups[$period]
        if ($itemsInPeriod.Count -eq 0) { continue }
       
        $color = switch ($period) {
            "Overdue" { Get-ThemeProperty "Palette.ErrorFG" } "Today" { Get-ThemeProperty "Palette.WarningFG" }
            "This Week" { Get-ThemeProperty "Palette.InfoFG" } "Next Week" { Get-ThemeProperty "Palette.AccentFG" }
            "Later" { Get-ThemeProperty "Palette.AccentFG" } "No Date" { Get-ThemeProperty "Palette.SubtleFG" }
            "Completed" { Get-ThemeProperty "Palette.SuccessFG"}
        }
       
        Write-Host "`n  ⏰ $period ($($itemsInPeriod.Count))" -ForegroundColor (Get-LegacyColor $color)
       
        foreach ($task in $itemsInPeriod | Sort-Object @{Expression={if([string]::IsNullOrEmpty($_.DueDate)) {[DateTime]::MaxValue} else {[DateTime]::Parse($_.DueDate)}}}, Priority) {
            $priorityInfo = Get-PriorityInfo $task.Priority
            Write-Host "     $(Apply-PSStyle -Text $priorityInfo.Icon -FG $priorityInfo.Color) " -NoNewline
           
            if ((-not [string]::IsNullOrEmpty($task.DueDate)) -and $period -ne "No Date" -and $period -ne "Completed") {
                $date = try {[datetime]::Parse($task.DueDate)} catch {$null}
                if($date) {Write-Host "$($date.ToString('MMM dd')) - " -NoNewline -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))}
            }
           
            $taskDescColor = if ($task.Completed) { (Get-ThemeProperty "Palette.SubtleFG") } else { $color }
            Write-Host (Apply-PSStyle -Text "$($task.Id.Substring(0,4)): $($task.Description)" -FG $taskDescColor) -NoNewline
           
            if ($task.ProjectKey) {
                $project = Get-ProjectOrTemplate $task.ProjectKey
                if ($project) { Write-Host (Apply-PSStyle -Text " [$($project.Name)]" -FG (Get-ThemeProperty "Palette.AccentFG")) -NoNewline }
            }
            Write-Host
        }
    }
}
 
function global:Show-ProjectTaskView {
    param($TasksToDisplay)
    
    Write-Host "`n  🏗️  PROJECT VIEW" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.InfoFG"))
    Write-Host "  " ("=" * 60) -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
    
    $groups = $TasksToDisplay | Group-Object ProjectKey | Sort-Object @{ Expression = { if ([string]::IsNullOrEmpty($_.Name)) { "zzz_NoProject" } else { (Get-ProjectOrTemplate $_.Name).Name } } }
    
    foreach ($group in $groups) {
        $projectKey = $group.Name
        $project = if ($projectKey) { Get-ProjectOrTemplate $projectKey } else { $null }
        $projectName = if ($project) { $project.Name } else { "[No Project]" }
       
        $activeCount = ($group.Group | Where-Object { -not $_.Completed }).Count
        $completedCount = ($group.Group | Where-Object { $_.Completed }).Count
        
        Write-Host "`n  📂 $projectName " -NoNewline -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.AccentFG"))
        Write-Host "($activeCount active, $completedCount completed)" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
        
        $totalTasksInGroup = $group.Group.Count
        $progressPercent = 0
        if ($totalTasksInGroup -gt 0) {
            $progressPercent = [Math]::Round(($completedCount / $totalTasksInGroup) * 100, 0)
        }
       
        Draw-ProgressBar -Percent $progressPercent; Write-Host ""
       
        foreach ($task in $group.Group | Sort-Object Completed, @{Expression={if([string]::IsNullOrEmpty($_.DueDate)) {[DateTime]::MaxValue} else {[DateTime]::Parse($_.DueDate)}}}, Priority) {
            Show-TaskItem $task
        }
       
        $totalEstimated = ($group.Group | Measure-Object -Property EstimatedTime -Sum).Sum
        $totalSpent = ($group.Group | Measure-Object -Property TimeSpent -Sum).Sum
       
        if ($totalEstimated -gt 0 -or $totalSpent -gt 0) {
            Write-Host "  " ("-" * 40) -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
            if ($totalEstimated -gt 0) { Write-Host "  Est. for these tasks: $totalEstimated hours" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")) }
            if ($totalSpent -gt 0) {
                Write-Host "  Spent on these tasks: $totalSpent hours" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
                if ($totalEstimated -gt 0 -and $totalSpent -gt 0) {
                    $efficiency = [Math]::Round(($totalEstimated / $totalSpent) * 100, 0)
                    Write-Host "  Efficiency for these: $efficiency%" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
                }
            }
        }
    }
}
 
function global:Show-TaskStatistics {
    param($TasksToDisplay)
    if(-not $TasksToDisplay -or $TasksToDisplay.Count -eq 0) {
        Write-Host "`nNo tasks to show statistics for." -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
        return
    }
   
    $stats = @{
        Total = $TasksToDisplay.Count
        Completed = ($TasksToDisplay | Where-Object { $_.Completed }).Count
        Critical = ($TasksToDisplay | Where-Object { $_.Priority -eq "Critical" -and -not $_.Completed }).Count
        High = ($TasksToDisplay | Where-Object { $_.Priority -eq "High" -and -not $_.Completed }).Count
        Medium = ($TasksToDisplay | Where-Object { $_.Priority -eq "Medium" -and -not $_.Completed }).Count
        Low = ($TasksToDisplay | Where-Object { $_.Priority -eq "Low" -and -not $_.Completed }).Count
        Overdue = ($TasksToDisplay | Where-Object {
            (-not [string]::IsNullOrEmpty($_.DueDate)) -and ([datetime]::Parse($_.DueDate).Date -lt [datetime]::Today.Date) -and (-not $_.Completed)
        }).Count
        DueToday = ($TasksToDisplay | Where-Object {
            (-not [string]::IsNullOrEmpty($_.DueDate)) -and ([datetime]::Parse($_.DueDate).Date -eq [datetime]::Today.Date) -and (-not $_.Completed)
        }).Count
        InProgress = ($TasksToDisplay | Where-Object { $_.Progress -gt 0 -and $_.Progress -lt 100 -and (-not $_.Completed) }).Count
    }
   
    Write-Host "`n" ("=" * 70) -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
    $statLine = @("  📊 Total: $($stats.Total)")
    $statLine += Apply-PSStyle -Text "✅ Done: $($stats.Completed)" -FG (Get-ThemeProperty "Palette.SuccessFG")
    if ($stats.Critical -gt 0) { $statLine += Apply-PSStyle -Text "🔥 Critical: $($stats.Critical)" -FG (Get-ThemeProperty "Palette.ErrorFG") }
    if ($stats.High -gt 0) { $statLine += Apply-PSStyle -Text "🔴 High: $($stats.High)" -FG (Get-ThemeProperty "Palette.ErrorFG") }
    if ($stats.Medium -gt 0) { $statLine += Apply-PSStyle -Text "🟡 Med: $($stats.Medium)" -FG (Get-ThemeProperty "Palette.WarningFG") }
    if ($stats.Low -gt 0) { $statLine += Apply-PSStyle -Text "🟢 Low: $($stats.Low)" -FG (Get-ThemeProperty "Palette.SuccessFG") }
    if ($stats.InProgress -gt 0) { $statLine += Apply-PSStyle -Text "🔄 In Progress: $($stats.InProgress)" -FG (Get-ThemeProperty "Palette.InfoFG") }
    if ($stats.DueToday -gt 0) { $statLine += Apply-PSStyle -Text "📅 Due Today: $($stats.DueToday)" -FG (Get-ThemeProperty "Palette.WarningFG") }
    if ($stats.Overdue -gt 0) { $statLine += Apply-PSStyle -Text "⚠️  Overdue: $($stats.Overdue)" -FG (Get-ThemeProperty "Palette.ErrorFG") }
   
    Write-Host ($statLine -join (" " + (Apply-PSStyle -Text "|" -FG (Get-ThemeProperty "Palette.SubtleFG")) + " "))
}
 
function global:Show-TaskManagementMenu {
    $filterString = ""
    $sortByOption = "Smart"
    $showCompletedTasks = $false
    $viewModeOption = "Default"
    
    while ($true) {
        Clear-Host
        Write-Header "Task Management"
       
        Show-TasksView -Filter $filterString -SortBy $sortByOption -ShowCompleted:$showCompletedTasks -View $viewModeOption
       
        Write-Host "`n" ("=" * 70) -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
        $statusLine = "📝 "
        if ($filterString) { $statusLine += Apply-PSStyle -Text "Filter: '$filterString' | " -FG (Get-ThemeProperty "Palette.InfoFG") }
        $statusLine += "Sort: $sortByOption | View: $viewModeOption | "
        $statusLine += if ($showCompletedTasks) { "Showing: All (inc. all completed)" } else { "Showing: Active / Recent Completed (last $($script:Data.Settings.ShowCompletedDays) days)" }
        Write-Host $statusLine
       
        Write-Host "`nActions: [A]dd, [C]omplete, [E]dit, [D]elete, [P]rogress, [ST]Subtasks"
        Write-Host "Display: [F]ilter, [S]ort, [V]iew Mode, [T]oggle Completed Visibility"
        Write-Host "Archive: View [AR]chived, [ARC]hive Now"
        Write-Host "Quick Entry: 'qa <task details>', 'c <id>', 'e <id>', 'd <id>'"
        Write-Host "`n[B] Back to Dashboard"
       
        $choice = Read-Host "`nCommand"
       
        if ($choice -match '^qa\s+(.+)') { Quick-AddTask -InputString $Matches[1]; continue }
        if ($choice -match '^([cde]|st|p)\s+(.+)') {
            $cmd = $Matches[1].ToLower(); $id = $Matches[2]
            switch ($cmd) {
                "c" { Complete-Task -TaskIdInput $id } "d" { Remove-Task -TaskIdInput $id }
                "e" { Edit-Task -TaskIdInput $id } "p" { Update-TaskProgress -TaskIdInput $id }
                "st" { Manage-Subtasks -TaskIdInput $id }
            }
            Write-Host "`nPress Enter to continue..." ; Read-Host; continue
        }
       
        $actionProcessed = $true
        switch ($choice.ToLower()) {
            "a" { Add-TodoTask } "c" { Complete-Task } "e" { Edit-Task } "d" { Remove-Task }
            "p" { Update-TaskProgress } "st" { Manage-Subtasks }
            "f" { $filterString = Read-Host "Filter (empty to clear)"; if ([string]::IsNullOrEmpty($filterString)) { $filterString = "" } }
            "s" {
                Write-Host "Sort by: [S]mart, [P]riority, [D]ue date, [C]reated, c[A]tegory, p[R]oject"
                $sortChoice = Read-Host "Choice"; $sortByOption = switch ($sortChoice.ToLower()) {
                    "p" { "Priority" } "d" { "DueDate" } "c" { "Created" } "a" { "Category" }
                    "r" { "Project" } default { "Smart" }
                }
            }
            "v" {
                Write-Host "View mode: [D]efault List, [K]anban, [T]imeline, [P]roject-grouped"
                $viewChoice = Read-Host "Choice"; $viewModeOption = switch ($viewChoice.ToLower()) {
                    "k" { "Kanban" } "t" { "Timeline" } "p" { "Project" } default { "Default" }
                }
            }
            "t" { $showCompletedTasks = -not $showCompletedTasks }
            "arc" { Archive-CompletedTasks } "ar" { View-TaskArchive }
            "b" { return }
            default {
                if (-not [string]::IsNullOrEmpty($choice)) { Write-Warning "Unknown command." }
                $actionProcessed = $false
            }
        }
        if ($actionProcessed -and $choice.ToLower() -ne "b") { Write-Host "`nPress Enter to continue..."; Read-Host }
    }
}
 
function global:Show-TaskAnalytics {
    Write-Header "Task Analytics"
 
    $allTasks = $script:Data.Tasks | Where-Object { $_.IsCommand -ne $true }
    if ($allTasks.Count -eq 0) { Write-Warning "No tasks available for analytics."; return }
 
    $completedTasks = $allTasks | Where-Object { $_.Completed }
    $activeTasks = $allTasks | Where-Object { -not $_.Completed }
   
    Write-Host "Overall:" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG"))
    Write-Host "  Total Tasks: $($allTasks.Count)"
    Write-Host "  Active Tasks: $(Apply-PSStyle -Text $activeTasks.Count -FG (Get-ThemeProperty "Palette.WarningFG"))"
    Write-Host "  Completed Tasks: $(Apply-PSStyle -Text $completedTasks.Count -FG (Get-ThemeProperty "Palette.SuccessFG"))"
 
    if ($allTasks.Count -gt 0) {
        $completionRate = [Math]::Round(($completedTasks.Count / $allTasks.Count) * 100, 1)
        Write-Host "  Completion Rate: $completionRate%"
        Draw-ProgressBar -Percent $completionRate -Width 40
    }
 
    $today = [DateTime]::Today.Date
    $startOfWeek = Get-WeekStart $today
    $startOfMonth = $today.AddDays(-($today.Day - 1))
 
    $completedThisWeek = $completedTasks | Where-Object { (-not [string]::IsNullOrEmpty($_.CompletedDate)) -and ([datetime]::Parse($_.CompletedDate).Date -ge $startOfWeek.Date) }
    $completedThisMonth = $completedTasks | Where-Object { (-not [string]::IsNullOrEmpty($_.CompletedDate)) -and ([datetime]::Parse($_.CompletedDate).Date -ge $startOfMonth.Date) }
 
    Write-Host "`nCompletion Trends:" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG"))
    Write-Host "  Completed this Week (since $($startOfWeek.ToString('MMM dd'))): $($completedThisWeek.Count)"
    Write-Host "  Completed this Month ($($startOfMonth.ToString('MMMM'))): $($completedThisMonth.Count)"
 
    Write-Host "`nActive Tasks by Priority:" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG"))
    $activeTasks | Group-Object Priority | Sort-Object @{Expression={@{"Critical"=1;"High"=2;"Medium"=3;"Low"=4}[$_.Name]}} | ForEach-Object {
        $priorityInfo = Get-PriorityInfo $_.Name
        Write-Host "  $(Apply-PSStyle -Text "$($priorityInfo.Icon) $($_.Name):" -FG $priorityInfo.Color) $($_.Count)"
    }
 
    Write-Host "`nActive Tasks by Category:" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG"))
    $activeTasks | Group-Object Category | Sort-Object Name | ForEach-Object {
        $catName = if ([string]::IsNullOrEmpty($_.Name)) {"[Uncategorized]"} else {$_.Name}
        Write-Host "  $catName $($_.Count)"
    }
   
    $overdueTasks = $activeTasks | Where-Object { (-not [string]::IsNullOrEmpty($_.DueDate)) -and ([datetime]::Parse($_.DueDate).Date -lt $today.Date) }
    if ($overdueTasks.Count -gt 0) {
        Write-Host "`nOverdue Tasks: $(Apply-PSStyle -Text $($overdueTasks.Count) -FG (Get-ThemeProperty "Palette.ErrorFG"))" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.ErrorFG"))
        $avgOverdueDays = $overdueTasks | ForEach-Object { ($today.Date - ([datetime]::Parse($_.DueDate).Date)).Days } | Measure-Object -Average
        if ($avgOverdueDays.Average -and $avgOverdueDays.Average -gt 0) {
            Write-Host "  Average Overdue by: $([Math]::Round($avgOverdueDays.Average,1)) days"
        }
    }

    Write-Host "`nEstimated vs. Spent Time (Completed Tasks):" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG"))
    $completedWithTime = $completedTasks | Where-Object {$_.TimeSpent -gt 0 -and $_.EstimatedTime -gt 0}
    if($completedWithTime.Count -gt 0){
        $totalEst = ($completedWithTime | Measure-Object EstimatedTime -Sum).Sum
        $totalSpent = ($completedWithTime | Measure-Object TimeSpent -Sum).Sum
        Write-Host "  Total Estimated (completed w/ time): $totalEst hours"
        Write-Host "  Total Spent (completed w/ time): $totalSpent hours"
        if($totalSpent -gt 0) {
            $overallEfficiency = [Math]::Round(($totalEst / $totalSpent) * 100, 1)
            Write-Host "  Overall Efficiency: $overallEfficiency%"
        }
    } else { Write-Host "  Not enough data for efficiency calculation."}
}

#endregion
```

---
### **File 6: `enhanced-selection.ps1`**
*This is the advanced selection module from `CURRENT`. It provides a rich, interactive list selection experience with arrow keys, searching, and details. It is used by the new architecture to handle all list-based selections.*

```powershell
# Enhanced Selection System
# Provides arrow key navigation, numbered lists, and visual highlighting for selections

function global:Show-EnhancedSelection {
    param(
        [Parameter(Mandatory=$true)]
        [array]$Items,                    # Array of items to select from
        [string]$Title = "Select Item",   # Title to display
        [string]$DisplayProperty = "",    # Property to display (for objects)
        [string]$ValueProperty = "",      # Property to return (for objects)
        [switch]$AllowMultiple,           # Allow multiple selections
        [switch]$ShowDetails,             # Show additional details
        [hashtable]$DetailProperties = @{}, # Properties to show as details
        [int]$PageSize = 15,              # Items per page
        [switch]$ReturnIndex              # Return index instead of item
    )
    
    if ($Items.Count -eq 0) {
        Write-Warning "No items to select from."
        return $null
    }
    
    # Initialize variables
    $selectedIndex = 0
    $selectedItems = @()
    $pageStart = 0
    $searchFilter = ""
    
    while ($true) {
        Clear-Host
        Write-Header $Title
        
        # Show search filter if active
        if ($searchFilter) {
            Write-Host "Filter: " -NoNewline -ForegroundColor Yellow
            Write-Host $searchFilter -ForegroundColor Cyan
            Write-Host ""
        }
        
        # Filter items based on search
        $filteredItems = if ($searchFilter) {
            $Items | Where-Object {
                $displayText = if ($DisplayProperty -and $_ -is [PSObject]) {
                    $_.$DisplayProperty
                } else {
                    $_.ToString()
                }
                $displayText -like "*$searchFilter*"
            }
        } else {
            $Items
        }
        
        if ($filteredItems.Count -eq 0) {
            Write-Host "  No items match the filter." -ForegroundColor Gray
            Write-Host "`n[ESC] Clear filter | [BACKSPACE] Edit filter"
            $key = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
            
            switch ($key.VirtualKeyCode) {
                27 { $searchFilter = ""; $selectedIndex = 0 } # ESC
                8 { # Backspace
                    if ($searchFilter.Length -gt 0) {
                        $searchFilter = $searchFilter.Substring(0, $searchFilter.Length - 1)
                    }
                }
            }
            continue
        }
        
        # Calculate page boundaries
        $totalItems = $filteredItems.Count
        $pageEnd = [Math]::Min($pageStart + $PageSize, $totalItems) - 1
        
        # Ensure selected index is within bounds
        if ($selectedIndex -ge $totalItems) {
            $selectedIndex = $totalItems - 1
        }
        
        # Adjust page if selected item is outside current page
        if ($selectedIndex -lt $pageStart) {
            $pageStart = $selectedIndex
            $pageEnd = [Math]::Min($pageStart + $PageSize, $totalItems) - 1
        }
        elseif ($selectedIndex -gt $pageEnd) {
            $pageEnd = $selectedIndex
            $pageStart = [Math]::Max(0, $pageEnd - $PageSize + 1)
        }
        
        # Display items
        for ($i = $pageStart; $i -le $pageEnd; $i++) {
            $item = $filteredItems[$i]
            $displayText = if ($DisplayProperty -and $item -is [PSObject]) {
                $item.$DisplayProperty
            } else {
                $item.ToString()
            }
            
            $quickKey = if ($i - $pageStart -lt 9) {
                ($i - $pageStart + 1).ToString()
            } elseif ($i - $pageStart -lt 35) {
                [char](97 + ($i - $pageStart - 9))
            } else {
                " "
            }
            
            if ($AllowMultiple) {
                $isSelected = $selectedItems -contains $i
                $indicator = if ($isSelected) { "[✓]" } else { "[ ]" }
                $indicatorColor = if ($isSelected) { "Green" } else { "DarkGray" }
                Write-Host "  " -NoNewline
                Write-Host $indicator -ForegroundColor $indicatorColor -NoNewline
            } else {
                $indicator = if ($i -eq $selectedIndex) { "→" } else { " " }
                $indicatorColor = if ($i -eq $selectedIndex) { "Cyan" } else { "DarkGray" }
                Write-Host " " -NoNewline
                Write-Host $indicator -ForegroundColor $indicatorColor -NoNewline
            }
            
            Write-Host " [$quickKey]" -ForegroundColor DarkCyan -NoNewline
            
            $itemColor = if ($i -eq $selectedIndex) { "White" } else { "Gray" }
            Write-Host " $displayText" -ForegroundColor $itemColor
            
            if ($ShowDetails -and $DetailProperties.Count -gt 0 -and $i -eq $selectedIndex) {
                foreach ($detailKey in $DetailProperties.Keys) {
                    $detailValue = if ($item -is [PSObject] -and $item.PSObject.Properties[$DetailProperties[$detailKey]]) {
                        $item.($DetailProperties[$detailKey])
                    } else { "" }
                    if ($detailValue) {
                        Write-Host "       $detailKey`: $detailValue" -ForegroundColor DarkGray
                    }
                }
            }
        }
        
        if ($totalItems -gt $PageSize) {
            Write-Host "`n  Page $([Math]::Floor($selectedIndex / $PageSize) + 1) of $([Math]::Ceiling($totalItems / $PageSize))" -ForegroundColor DarkGray
            Write-Host "  ↑↓ Navigate | PgUp/PgDn Change page" -ForegroundColor DarkGray
        }
        
        Write-Host "`n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━" -ForegroundColor DarkGray
        
        if ($AllowMultiple) {
            Write-Host "  [SPACE] Toggle | [A] All | [N] None | [ENTER] Confirm | [ESC] Cancel" -ForegroundColor Yellow
        } else {
            Write-Host "  [ENTER] Select | [ESC] Cancel | [1-9,a-z] Quick select" -ForegroundColor Yellow
        }
        Write-Host "  [/] Search filter | [BACKSPACE] Clear character" -ForegroundColor DarkGray
        
        $key = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
        
        switch ($key.VirtualKeyCode) {
            38 { if ($selectedIndex -gt 0) { $selectedIndex-- } else { $selectedIndex = $totalItems - 1 } }
            40 { if ($selectedIndex -lt $totalItems - 1) { $selectedIndex++ } else { $selectedIndex = 0 } }
            33 { $selectedIndex = [Math]::Max(0, $selectedIndex - $PageSize) }
            34 { $selectedIndex = [Math]::Min($totalItems - 1, $selectedIndex + $PageSize) }
            36 { $selectedIndex = 0 }
            35 { $selectedIndex = $totalItems - 1 }
            32 { if ($AllowMultiple) { if ($selectedItems -contains $selectedIndex) { $selectedItems = $selectedItems | Where-Object { $_ -ne $selectedIndex } } else { $selectedItems += $selectedIndex } } }
            13 {
                if ($AllowMultiple) {
                    if ($selectedItems.Count -eq 0) { Write-Warning "`nNo items selected."; Start-Sleep -Seconds 1; continue }
                    $result = @(); foreach ($idx in $selectedItems) { $item = $filteredItems[$idx]; if ($ReturnIndex) { $result += $idx } elseif ($ValueProperty -and $item -is [PSObject]) { $result += $item.$ValueProperty } else { $result += $item } }; return $result
                } else {
                    $item = $filteredItems[$selectedIndex]; if ($ReturnIndex) { return $selectedIndex } elseif ($ValueProperty -and $item -is [PSObject]) { return $item.$ValueProperty } else { return $item }
                }
            }
            27 { if ($searchFilter) { $searchFilter = ""; $selectedIndex = 0 } else { return $null } }
            8 { if ($searchFilter.Length -gt 0) { $searchFilter = $searchFilter.Substring(0, $searchFilter.Length - 1) } }
            65 { if ($AllowMultiple -and $key.Character -eq 'a') { $selectedItems = 0..($totalItems - 1) } }
            78 { if ($AllowMultiple -and $key.Character -eq 'n') { $selectedItems = @() } }
            191 { $searchFilter = ""; Write-Host "`n  Start typing to filter..." -ForegroundColor Gray }
            default {
                if ($key.Character -ge '1' -and $key.Character -le '9') {
                    $quickIndex = [int]$key.Character.ToString() - 1 + $pageStart
                    if ($quickIndex -lt $totalItems) {
                        if ($AllowMultiple) { if ($selectedItems -contains $quickIndex) { $selectedItems = $selectedItems | Where-Object { $_ -ne $quickIndex } } else { $selectedItems += $quickIndex } }
                        else { $selectedIndex = $quickIndex; $item = $filteredItems[$selectedIndex]; if ($ReturnIndex) { return $selectedIndex } elseif ($ValueProperty -and $item -is [PSObject]) { return $item.$ValueProperty } else { return $item } }
                    }
                }
                elseif ($key.Character -ge 'a' -and $key.Character -le 'z') {
                    $quickIndex = [int]($key.Character) - [int]('a') + 9 + $pageStart
                    if ($quickIndex -lt $totalItems) {
                        if ($AllowMultiple) { if ($selectedItems -contains $quickIndex) { $selectedItems = $selectedItems | Where-Object { $_ -ne $quickIndex } } else { $selectedItems += $quickIndex } }
                        else { $selectedIndex = $quickIndex; $item = $filteredItems[$selectedIndex]; if ($ReturnIndex) { return $selectedIndex } elseif ($ValueProperty -and $item -is [PSObject]) { return $item.$ValueProperty } else { return $item } }
                    }
                }
                elseif ($key.Character -and -not [char]::IsControl($key.Character) -and $key.Character -ne "`0") {
                    $searchFilter += $key.Character
                }
            }
        }
    }
}

function global:Select-ProjectOrTemplate {
    param(
        [string]$Title = "Select Project or Template",
        [switch]$IncludeNone,
        [switch]$ProjectsOnly,
        [switch]$TemplatesOnly
    )
    
    $items = @()
    
    if ($IncludeNone) {
        $items += [PSCustomObject]@{ Key = $null; Name = "[None - No Project]"; Type = "None"; Client = ""; Status = "" }
    }
    
    if (-not $TemplatesOnly -and $script:Data.Projects -and $script:Data.Projects.Count -gt 0) {
        foreach ($proj in $script:Data.Projects.GetEnumerator() | Sort-Object {$_.Value.Name}) {
            $items += [PSCustomObject]@{ Key = $proj.Key; Name = "$($proj.Value.Name) [$($proj.Key)]"; Type = "Project"; Client = if ($proj.Value.Client) { $proj.Value.Client } else { "-" }; Status = $proj.Value.Status }
        }
    }
    
    if (-not $ProjectsOnly -and $script:Data.Settings.TimeTrackerTemplates -and $script:Data.Settings.TimeTrackerTemplates.Count -gt 0) {
        foreach ($tmpl in $script:Data.Settings.TimeTrackerTemplates.GetEnumerator()) {
            $items += [PSCustomObject]@{ Key = $tmpl.Key; Name = "$($tmpl.Value.Name) [$($tmpl.Key)]"; Type = "Template"; Client = if ($tmpl.Value.Client) { $tmpl.Value.Client } else { "-" }; Status = "Template" }
        }
    }
    
    if ($items.Count -eq 0) { Write-Warning "No projects or templates available."; return $null }
    
    return Show-EnhancedSelection -Items $items -Title $Title -DisplayProperty "Name" -ValueProperty "Key" -ShowDetails -DetailProperties @{ "Type" = "Type"; "Client" = "Client"; "Status" = "Status" }
}

function global:Select-Task {
    param(
        [string]$Title = "Select Task",
        [switch]$AllowMultiple,
        [switch]$ActiveOnly,
        [switch]$IncludeCompleted,
        [string]$ProjectFilter = ""
    )
    
    $tasks = $script:Data.Tasks | Where-Object { $_.IsCommand -ne $true }
    
    if ($ActiveOnly) {
        $tasks = $tasks | Where-Object { -not $_.Completed }
    } elseif (-not $IncludeCompleted) {
        $cutoffDate = [datetime]::Today.AddDays(-$script:Data.Settings.ShowCompletedDays)
        $tasks = $tasks | Where-Object { (-not $_.Completed) -or ((-not [string]::IsNullOrEmpty($_.CompletedDate)) -and ([datetime]::Parse($_.CompletedDate).Date -ge $cutoffDate.Date)) }
    }
    
    if ($ProjectFilter) {
        $tasks = $tasks | Where-Object { $_.ProjectKey -eq $ProjectFilter }
    }
    
    if ($tasks.Count -eq 0) { Write-Warning "No tasks available for selection."; return $null }
    
    $items = @()
    foreach ($task in $tasks | Sort-Object @{Expression={$_.Completed}}, @{Expression={Get-TaskStatus $_}}, Priority, Description) {
        $status = Get-TaskStatus $task
        $priorityInfo = Get-PriorityInfo $task.Priority
        $project = if ($task.ProjectKey) { Get-ProjectOrTemplate $task.ProjectKey } else { $null }
        $displayName = "$($priorityInfo.Icon) $($task.Description)"
        if ($task.Completed) { $displayName = "✓ $displayName" }
        
        $items += [PSCustomObject]@{ Id = $task.Id; DisplayName = $displayName; Status = $status; Priority = $task.Priority; Project = if ($project) { $project.Name } else { "-" }; Due = if ($task.DueDate) { Format-TodoDate $task.DueDate } else { "-" }; Progress = "$($task.Progress)%" }
    }
    
    return Show-EnhancedSelection -Items $items -Title $Title -DisplayProperty "DisplayName" -ValueProperty "Id" -AllowMultiple:$AllowMultiple -ShowDetails -DetailProperties @{ "Status" = "Status"; "Project" = "Project"; "Due" = "Due"; "Progress" = "Progress" }
}

function global:Get-EnhancedConfirmation {
    param(
        [string]$Message,
        [string]$Title = "Confirm",
        [switch]$DefaultNo
    )
    
    $options = @(
        [PSCustomObject]@{ Value = $true; Display = "Yes" },
        [PSCustomObject]@{ Value = $false; Display = "No" }
    )
    
    $defaultIndex = if ($DefaultNo) { 1 } else { 0 }
    
    Clear-Host
    Write-Header $Title
    Write-Host $Message -ForegroundColor Yellow
    Write-Host ""
    
    for ($i = 0; $i -lt $options.Count; $i++) {
        $indicator = if ($i -eq $defaultIndex) { "→" } else { " " }
        $color = if ($i -eq $defaultIndex) { "White" } else { "Gray" }
        Write-Host "$indicator [$($i + 1)] $($options[$i].Display)" -ForegroundColor $color
    }
    
    Write-Host "`n[ENTER] Select default | [Y/N] Quick select | [ESC] Cancel"
    
    $key = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
    
    switch ($key.VirtualKeyCode) {
        13 { return $options[$defaultIndex].Value } # Enter
        27 { return $false } # Escape
        89 { return $true }  # Y
        78 { return $false } # N
        49 { return $true }  # 1
        50 { return $false } # 2
        default { return $options[$defaultIndex].Value }
    }
}
```

---
### **File 7: `fb.ps1`**
*This is the terminal file browser from `CURRENT`. It has been reviewed to ensure it uses the new theme and helper functions correctly.*

```powershell
# Terminal File Browser for PowerShell

#region State Variables
$script:FB_CurrentPath = $null
$script:FB_SelectedItems = @{}
$script:FB_Clipboard = @{ Items = @(); Action = "Copy" }
$script:FB_SortBy = "Name"
$script:FB_ShowHidden = $false
$script:FB_ViewMode = "Details"
$script:FB_SelectedIndex = 0
#endregion

#region Main Entry Points

function global:Start-TerminalFileBrowser {
    [CmdletBinding()]
    param(
        [string]$Path = (Get-Location).Path,
        [switch]$SelectFileMode,
        [switch]$SelectFolderMode
    )
    
    $script:FB_CurrentPath = Get-Item -LiteralPath $Path
    $script:FB_SelectedItems = @{}
    $script:FB_SelectedIndex = 0

    $originalTitle = $Host.UI.RawUI.WindowTitle
    $Host.UI.RawUI.WindowTitle = "File Browser: $($script:FB_CurrentPath.FullName)"
    
    $result = $null
    try {
        if ($SelectFileMode -or $SelectFolderMode) {
            $result = FB_MainLoop -SelectFileMode:$SelectFileMode -SelectFolderMode:$SelectFolderMode
        } else {
            FB_MainLoop
        }
    }
    finally {
        $Host.UI.RawUI.WindowTitle = $originalTitle
    }
    return $result
}

function FB_MainLoop {
    param($SelectFileMode, $SelectFolderMode)

    while ($true) {
        $items = Get-ChildItem -LiteralPath $script:FB_CurrentPath.FullName -Force:$script:FB_ShowHidden -ErrorAction SilentlyContinue | FB_SortItems
        
        Clear-Host
        FB_ShowHeader -SelectMode:($SelectFileMode -or $SelectFolderMode)
        FB_ShowFileList -Items $items
        FB_ShowStatusBar -Items $items

        $action = FB_GetAction
        
        switch ($action.Type) {
            "Exit" { return $null }
            "Refresh" { continue }
            "Navigate" { $script:FB_CurrentPath = Get-Item -LiteralPath $action.Path; $script:FB_SelectedItems = @{}; $script:FB_SelectedIndex = 0 }
            "Open" {
                if ($SelectFileMode -and -not $action.Item.PSIsContainer) { return $action.Item.FullName }
                if ($SelectFolderMode -and $action.Item.PSIsContainer) { return $action.Item.FullName }
                if ($action.Item.PSIsContainer) { $script:FB_CurrentPath = $action.Item; $script:FB_SelectedItems = @{}; $script:FB_SelectedIndex = 0 }
                else { try { Start-Process -FilePath $action.Item.FullName } catch { Write-Warning "Could not open file: $_" } }
            }
            "ReturnPath" { return $action.Path }
            "Invoke" { & $action.Action; Start-Sleep -Milliseconds 500 } # Pause after action
        }
    }
}
#endregion

#region UI Display Functions

function FB_ShowHeader {
    param($SelectMode)
    $pathColor = Get-ThemeProperty 'Palette.WarningFG'
    Write-Header "File Browser"
    Write-Host " 📍 Path: " -ForegroundColor (Get-LegacyColor $pathColor) -NoNewline
    Write-Host $script:FB_CurrentPath.FullName
    if($SelectMode) { Write-Host "`n 🎯 SELECTION MODE: Press Enter on a file/folder to select and exit." -ForegroundColor (Get-LegacyColor (Get-ThemeProperty 'Palette.InfoFG'))}
}

function FB_ShowFileList {
    param($Items)
    switch ($script:FB_ViewMode) {
        "Details" { FB_ShowDetailView -Items $Items }
        default { FB_ShowDetailView -Items $Items }
    }
}

function FB_ShowDetailView {
    param ($Items)
    $headers = @(
        @{ T = " "; W = 1 }, # Selection
        @{ T = " "; W = 1 }, # Icon
        @{ T = "Name"; W = ($Host.UI.RawUI.WindowSize.Width - 48); Align = "Left" },
        @{ T = "Size"; W = 12; Align = "Right" },
        @{ T = "Modified"; W = 19; Align = "Left" }
    )
    $headerString = ""
    foreach ($h in $headers) { $headerString += "{0,-$($h.W)} " -f $h.T }
    Write-Host "`n$headerString" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty 'Palette.HeaderFG'))
    
    # Parent directory
    if ($script:FB_CurrentPath.Parent) {
        if ($script:FB_SelectedIndex -eq -1) { Write-Host ">" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty 'Palette.WarningFG')) -NoNewline } else { Write-Host " " -NoNewline }
        Write-Host " 📁 .. " -ForegroundColor (Get-LegacyColor (Get-ThemeProperty 'Palette.AccentFG'))
    }

    for ($i = 0; $i -lt $Items.Count; $i++) {
        $item = $Items[$i]
        $isSelected = $script:FB_SelectedItems.ContainsKey($item.FullName)
        $isCurrent = ($i -eq $script:FB_SelectedIndex)

        if ($isCurrent) { Write-Host ">" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty 'Palette.WarningFG')) -NoNewline } else { Write-Host " " -NoNewline }
        if ($isSelected) { Write-Host "[✓] " -ForegroundColor (Get-LegacyColor (Get-ThemeProperty 'Palette.SuccessFG')) -NoNewline } else { Write-Host "[ ] " -NoNewline }
        
        $nameColor = if ($item.PSIsContainer) { Get-ThemeProperty 'Palette.InfoFG' } else { Get-ThemeProperty 'Palette.PrimaryFG' }
        $icon = if ($item.PSIsContainer) { "📁" } else { "📄" }
        Write-Host "$icon " -NoNewline
        $name = if ($item.Name.Length -gt $headers[2].W - 3) { $item.Name.Substring(0, $headers[2].W - 3) + "..." } else { $item.Name }
        Write-Host ("{0,-$($headers[2].W - 2)}" -f $name) -ForegroundColor (Get-LegacyColor $nameColor) -NoNewline
        
        $size = if ($item.PSIsContainer) { "<DIR>" } else { "$([Math]::Round($item.Length / 1KB, 2)) KB" }
        Write-Host ("{0,12}" -f $size) -ForegroundColor (Get-LegacyColor (Get-ThemeProperty 'Palette.SubtleFG')) -NoNewline

        Write-Host "  $($item.LastWriteTime.ToString('yyyy-MM-dd HH:mm'))" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty 'Palette.SubtleFG'))
    }
}

function FB_ShowStatusBar {
    param ($Items)
    $width = $Host.UI.RawUI.WindowSize.Width
    Write-Host ("`n" + ("-" * $width)) -ForegroundColor (Get-LegacyColor (Get-ThemeProperty 'Palette.SubtleFG'))
    $status = " Items: $($Items.Count) | Selected: $($script:FB_SelectedItems.Count) | Clipboard: $($script:FB_Clipboard.Items.Count) | Sort: $($script:FB_SortBy) | Hidden: $($script:FB_ShowHidden)"
    Write-Host $status -ForegroundColor (Get-LegacyColor (Get-ThemeProperty 'Palette.SubtleFG'))
    Write-Host "[?] Help" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty 'Palette.WarningFG'))
}

#endregion

#region Actions and Logic

function FB_GetAction {
    $items = Get-ChildItem -LiteralPath $script:FB_CurrentPath.FullName -Force:$script:FB_ShowHidden -ErrorAction SilentlyContinue | FB_SortItems
    $key = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")

    switch ($key.VirtualKeyCode) {
        38 { if ($script:FB_SelectedIndex -gt 0) { $script:FB_SelectedIndex-- } elseif ($script:FB_CurrentPath.Parent) { $script:FB_SelectedIndex = -1 }; return @{ Type = "Refresh" } }
        40 { if ($script:FB_SelectedIndex -lt ($items.Count - 1)) { $script:FB_SelectedIndex++ }; return @{ Type = "Refresh" } }
        37 { if ($script:FB_CurrentPath.Parent) { return @{ Type = "Navigate"; Path = $script:FB_CurrentPath.Parent.FullName } }; return @{ Type = "Refresh" } }
        13 {
            if ($script:FB_SelectedIndex -eq -1 -and $script:FB_CurrentPath.Parent) { return @{ Type = "Navigate"; Path = $script:FB_CurrentPath.Parent.FullName } }
            if ($script:FB_SelectedIndex -ge 0 -and $script:FB_SelectedIndex -lt $items.Count) { return @{ Type = "Open"; Item = $items[$script:FB_SelectedIndex] } }
            return @{ Type = "Refresh" }
        }
        32 {
            if ($script:FB_SelectedIndex -ge 0 -and $script:FB_SelectedIndex -lt $items.Count) {
                $item = $items[$script:FB_SelectedIndex]; if ($script:FB_SelectedItems.ContainsKey($item.FullName)) { $script:FB_SelectedItems.Remove($item.FullName) } else { $script:FB_SelectedItems[$item.FullName] = $item }
            }
            if ($script:FB_SelectedIndex -lt ($items.Count - 1)) { $script:FB_SelectedIndex++ }
            return @{ Type = "Refresh" }
        }
    }

    switch ($key.Character.ToString().ToLower()) {
        "q" { return @{ Type = "Exit" } }
        "?" { return @{ Type = "Invoke"; Action = { FB_ShowHelp } } }
        "c" { return @{ Type = "Invoke"; Action = { FB_CopyItems -Items $items } } }
        "v" { return @{ Type = "Invoke"; Action = { FB_PasteItems } } }
        "n" { return @{ Type = "Invoke"; Action = { FB_NewItem } } }
        "d" { return @{ Type = "Invoke"; Action = { FB_DeleteItems -Items $items } } }
        "r" { return @{ Type = "Invoke"; Action = { FB_RenameItem -Items $items } } }
        "a" { return @{ Type = "Invoke"; Action = { foreach($item in $items) { $script:FB_SelectedItems[$item.FullName] = $item } } } }
        "s" { return @{ Type = "Invoke"; Action = { FB_ToggleSort } } }
        "h" { $script:FB_ShowHidden = -not $script:FB_ShowHidden; return @{ Type = "Refresh" } }
    }
    return @{ Type = "Refresh" }
}

function FB_CopyItems {
    param($Items)
    $selected = $script:FB_SelectedItems.Values
    if ($selected.Count -eq 0 -and $script:FB_SelectedIndex -ge 0) { $selected = @($Items[$script:FB_SelectedIndex]) }
    if ($selected.Count -gt 0) { $script:FB_Clipboard.Items = @($selected.FullName); Write-Info "Copied $($selected.Count) items." }
}

function FB_PasteItems {
    if ($script:FB_Clipboard.Items.Count -eq 0) { Write-Warning "Clipboard is empty."; return }
    foreach ($source in $script:FB_Clipboard.Items) {
        $dest = Join-Path $script:FB_CurrentPath.FullName (Split-Path $source -Leaf)
        try { Copy-Item -LiteralPath $source -Destination $dest -Recurse -Force; Write-Success "Pasted: $(Split-Path $source -Leaf)" }
        catch { Write-Error "Failed to paste $(Split-Path $source -Leaf): $_" }
    }
}

function FB_DeleteItems {
    param($Items)
    $selected = $script:FB_SelectedItems.Values
    if ($selected.Count -eq 0 -and $script:FB_SelectedIndex -ge 0) { $selected = @($Items[$script:FB_SelectedIndex]) }
    if ($selected.Count -gt 0) {
        Write-Warning "Permanently delete $($selected.Count) items?"; if ((Read-Host "Type 'yes' to confirm").ToLower() -eq 'yes') {
            foreach ($item in $selected) {
                try { Remove-Item -LiteralPath $item.FullName -Recurse -Force; Write-Success "Deleted: $($item.Name)" }
                catch { Write-Error "Failed to delete $($item.Name): $_" }
            }
            $script:FB_SelectedItems.Clear()
        }
    }
}

function FB_RenameItem {
    param($Items)
    if ($script:FB_SelectedIndex -ge 0) {
        $item = $Items[$script:FB_SelectedIndex]
        $newName = Read-Host "Rename '$($item.Name)' to"
        if (-not [string]::IsNullOrWhiteSpace($newName)) {
            try { Rename-Item -LiteralPath $item.FullName -NewName $newName; Write-Success "Renamed." } catch { Write-Error "Rename failed: $_" }
        }
    }
}

function FB_NewItem {
    $type = Read-Host "[F]ile or [D]irectory?"
    $name = Read-Host "Name?"
    if ([string]::IsNullOrWhiteSpace($name)) { return }
    $path = Join-Path $script:FB_CurrentPath.FullName $name
    $itemType = if ($type.ToLower() -eq 'd') { "Directory" } else { "File" }
    try { New-Item -Path $path -ItemType $itemType | Out-Null; Write-Success "Created $itemType '$name'." } catch { Write-Error "Failed to create: $_" }
}

function FB_ToggleSort {
    $sortOptions = @("Name", "Date", "Size", "Type")
    $current = $sortOptions.IndexOf($script:FB_SortBy)
    $next = ($current + 1) % $sortOptions.Count
    $script:FB_SortBy = $sortOptions[$next]
}

function FB_SortItems {
    param([object[]]$Items)
    switch ($script:FB_SortBy) {
        "Name" { return $Items | Sort-Object PSIsContainer -Descending, Name }
        "Date" { return $Items | Sort-Object PSIsContainer -Descending, @{Expression="LastWriteTime"; Descending=$true} }
        "Size" { return $Items | Sort-Object PSIsContainer -Descending, @{Expression="Length"; Descending=$true} }
        "Type" { return $Items | Sort-Object PSIsContainer -Descending, Extension, Name }
    }
}

function FB_ShowHelp {
    Write-Header "File Browser Help"
    Write-Host @"
Key          Action
---          ------
↑/↓          Navigate files and folders
←            Go to parent directory
Enter        Open file or enter directory
Space        Select/Deselect the current item
a            Select all items in the current folder
c            Copy selected items to clipboard
v            Paste items from clipboard
d            Delete selected items (with confirmation)
r            Rename the current item
n            Create a new file or directory
s            Cycle through sort modes (Name, Date, Size, Type)
h            Toggle visibility of hidden files and folders
?            Show this help screen
q            Quit the file browser
"@
    Read-Host "`nPress Enter to continue..." | Out-Null
}

#endregion
```

---
### **File 8: `command-palette.ps1`**
*This is the command palette module from `CURRENT`. It provides a powerful, searchable command interface. It has been reviewed to ensure it uses the new theme and helper functions correctly.*

```powershell
# Command Palette System

# Command registry to store all discoverable commands
$script:CommandRegistry = @()

function global:Register-Command {
    param(
        [string]$Name,
        [string]$Description,
        [scriptblock]$Action,
        [string[]]$Tags = @(),
        [string]$Category = "General",
        [string[]]$Aliases = @(),
        [string]$KeyBinding = ""
    )
    
    $script:CommandRegistry += [PSCustomObject]@{
        Name = $Name; Description = $Description; Action = $Action; Tags = $Tags
        Category = $Category; Aliases = $Aliases; KeyBinding = $KeyBinding
        SearchText = "$Name $Description $($Tags -join ' ') $($Aliases -join ' ')"
    }
}

function global:Initialize-CommandRegistry {
    $script:CommandRegistry = @()
    Register-Command -Name "Add Manual Time Entry" -Description "Log time manually with project and description" -Action {Add-ManualTimeEntry} -Tags "time,log,manual" -Category "Time" -KeyBinding "M"
    Register-Command -Name "Start Timer" -Description "Start a timer for a project or task" -Action {Start-Timer} -Tags "timer,start,track" -Category "Time" -KeyBinding "S"
    Register-Command -Name "Stop Timer" -Description "Stop running timer(s) and log time" -Action {Stop-Timer} -Tags "timer,stop,finish" -Category "Time"
    Register-Command -Name "Add Task" -Description "Create a new task with full details" -Action {Add-TodoTask} -Tags "task,add,todo" -Category "Task" -KeyBinding "A"
    Register-Command -Name "Quick Add Task" -Description "Fast task entry with inline syntax" -Action {Quick-AddTask} -Tags "task,quick,add" -Category "Task" -Aliases "qa"
    Register-Command -Name "Complete Task" -Description "Mark a task as completed" -Action {Complete-Task} -Tags "task,complete,done" -Category "Task"
    Register-Command -Name "Today's Overview" -Description "Show today's summary of tasks, time, and timers" -Action {Show-TodayView} -Tags "today,overview,summary" -Category "Views" -KeyBinding "T"
    Register-Command -Name "Week Report" -Description "Display week timesheet report" -Action {Show-WeekReport} -Tags "week,report,timesheet" -Category "Reports" -KeyBinding "W"
    Register-Command -Name "Calendar View" -Description "Show monthly calendar with task indicators" -Action {Show-Calendar} -Tags "calendar,month,date" -Category "Views"
    Register-Command -Name "Add Project" -Description "Create a new project" -Action {Add-Project} -Tags "project,add,client" -Category "Project"
    Register-Command -Name "Project Details" -Description "View detailed project information" -Action {Show-ProjectDetail} -Tags "project,details,info" -Category "Project" -KeyBinding "P"
    Register-Command -Name "Manage Command Snippets" -Description "Access the command snippet manager" -Action {Manage-CommandSnippets} -Tags "command,snippet,script" -Category "Tools" -Aliases "cmd"
    Register-Command -Name "Backup Now" -Description "Create immediate backup of all data" -Action {Backup-Data} -Tags "backup,save,data" -Category "Data"
    Register-Command -Name "File Browser" -Description "Launch the interactive terminal file browser" -Action {Start-TerminalFileBrowser} -Tags "file,browser,explore" -Category "File Management" -Aliases "fb"
}

function global:Show-CommandPalette {
    param(
        [string]$InitialFilter = ""
    )
    if ($script:CommandRegistry.Count -eq 0) { Initialize-CommandRegistry }
    $filter = $InitialFilter; $selectedIndex = 0; $maxDisplay = 15
    while ($true) {
        Clear-Host
        Write-Host "╔═══════════════════ COMMAND PALETTE ═══════════════════╗" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.HeaderFG"))
        Write-Host "║ Type to search | ↑↓ Navigate | Enter: Execute | Esc: Cancel ║" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
        Write-Host "╚═════════════════════════════════════════════════════════╝" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.HeaderFG"))
        Write-Host "`nSearch: " -NoNewline -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG")); Write-Host "$filter" -NoNewline; Write-Host "_" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG")); Write-Host ""
        
        $filtered = @()
        if ([string]::IsNullOrWhiteSpace($filter)) {
            $filtered = $script:CommandRegistry | Sort-Object Category, Name
        } else {
            $filterWords = $filter.ToLower().Split(' ', [System.StringSplitOptions]::RemoveEmptyEntries)
            foreach ($command in $script:CommandRegistry) {
                $score = 0
                $searchText = $command.SearchText.ToLower()
                
                $allWordsMatch = $true
                foreach ($word in $filterWords) {
                    if (-not $searchText.Contains($word)) {
                        $allWordsMatch = $false
                        break
                    }
                }

                if ($allWordsMatch) {
                    $score += 50 # Base score for matching all words
                    if ($command.Name.ToLower().StartsWith($filter.ToLower())) {
                        $score += 20 # Bonus for name starting with the full term
                    }
                    if ($searchText.Contains($filter.ToLower())) {
                        $score += 10 # Bonus for exact substring match
                    }
                    $command | Add-Member -NotePropertyName Score -NotePropertyValue $score -Force
                    $filtered += $command
                }
            }
            $filtered = $filtered | Sort-Object Score -Descending
        }
        if ($selectedIndex -ge $filtered.Count) { $selectedIndex = [Math]::Max(0, $filtered.Count - 1) }
        
        $startIndex = [Math]::Max(0, $selectedIndex - [Math]::Floor($maxDisplay / 2)); $endIndex = [Math]::Min($filtered.Count - 1, $startIndex + $maxDisplay - 1)
        if ($filtered.Count -eq 0) { Write-Host "`n  No commands match '$filter'" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")) }
        else {
            $displayItems = $filtered[$startIndex..$endIndex]
            for($i = 0; $i -lt $displayItems.Count; $i++) {
                $cmd = $displayItems[$i]
                $currentDisplayIndex = $startIndex + $i
                $isSelected = ($currentDisplayIndex -eq $selectedIndex)
                if ($isSelected) { Write-Host "  → " -NoNewline -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.HeaderFG")) } else { Write-Host "    " -NoNewline }
                Write-Host "$($cmd.Name)" -NoNewline -ForegroundColor $(if ($isSelected) { "White" } else { "Gray" })
                if ($cmd.KeyBinding) { Write-Host " [$($cmd.KeyBinding)]" -NoNewline -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.WarningFG")) }
                Write-Host ""; Write-Host "      $($cmd.Description)" -ForegroundColor $(if ($isSelected) { "Gray" } else { "DarkGray" })
            }
            if ($startIndex -gt 0) { Write-Host "`n  ↑ More above..." -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")) }
            if ($endIndex -lt $filtered.Count - 1) { Write-Host "  ↓ More below..." -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG")) }
        }
        
        $key = $Host.UI.RawUI.ReadKey("NoEcho,IncludeKeyDown")
        switch ($key.VirtualKeyCode) {
            38 { $selectedIndex = [Math]::Max(0, $selectedIndex - 1) } # Up
            40 { $selectedIndex = [Math]::Min($filtered.Count - 1, $selectedIndex + 1) } # Down
            13 { if ($filtered.Count -gt 0 -and $selectedIndex -lt $filtered.Count) { $selected = $filtered[$selectedIndex]; Clear-Host; Write-Success "Executing: $($selected.Name)"; & $selected.Action; return $selected }; break } # Enter
            27 { return $null } # Escape
            8 { if ($filter.Length -gt 0) { $filter = $filter.Substring(0, $filter.Length - 1); $selectedIndex = 0 } } # Backspace
            default { 
                if ($key.Character -and -not [char]::IsControl($key.Character) -and $key.Character -ne "`0" -and $key.VirtualKeyCode -notin @(16,17,18,91)) { 
                    $filter += $key.Character; $selectedIndex = 0 
                } 
            }
        }
    }
}

function global:Invoke-CommandPalette {
    param([switch]$AsScreen)
    if ($AsScreen) {
        Set-CurrentScreen -ScreenDefinition @{
            Name = "CommandPaletteScreen"
            OnLoad = {
                Clear-Host
                $result = Show-CommandPalette
                if ($result) { Pause-And-Redisplay }
                else { Navigate-Back }
            }
            ProcessKeyPressOverride = { param($KeyInfo) # No-op, handled by Show-CommandPalette
            }
        }
    } else {
        $result = Show-CommandPalette
        if ($result) {
            Write-Host "`nCommand completed." -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.SubtleFG"))
        } else {
            Write-Info "Command palette cancelled."
        }
    }
}

function global:Find-Commands {
    param([string]$SearchTerm)
    if ($script:CommandRegistry.Count -eq 0) { Initialize-CommandRegistry }
    $results = @()
    $filterWords = $SearchTerm.ToLower().Split(' ', [System.StringSplitOptions]::RemoveEmptyEntries)
    foreach ($command in $script:CommandRegistry) {
        $score = 0
        $searchText = $command.SearchText.ToLower()
        
        $allWordsMatch = $true
        foreach ($word in $filterWords) {
            if (-not $searchText.Contains($word)) {
                $allWordsMatch = $false
                break
            }
        }

        if ($allWordsMatch) {
            $score += 50
            if ($command.Name.ToLower().StartsWith($SearchTerm.ToLower())) { $score += 20 }
            if ($searchText.Contains($SearchTerm.ToLower())) { $score += 10 }
            $command | Add-Member -NotePropertyName Similarity -NotePropertyValue $score -Force
            $results += $command
        }
    }
    return $results | Sort-Object Similarity -Descending
}
```

---
### **File 9: `core-time.ps1`**
*This is a new module created to house all time-tracking-specific logic, keeping it separate from the main data module. It includes functions for timers and time entry.*

```powershell
# core-time.ps1 - Time Tracking Logic

function global:Add-ManualTimeEntry {
    Write-Header "Manual Time Entry"
    Show-ProjectsAndTemplates -Simple
    $projectKey = Read-Host "`nProject/Template Key"
    if (-not (Get-ProjectOrTemplate $projectKey)) {
        Write-Error "Invalid project or template key."
        return
    }
    $hoursInput = Read-Host "Hours (e.g., 1.5)"
    if (-not ([double]::TryParse($hoursInput, [ref]$hours))) {
        Write-Error "Invalid hours format."
        return
    }
    $dateInput = Read-Host "Date (YYYY-MM-DD, default: Today)"
    $date = if ([string]::IsNullOrWhiteSpace($dateInput)) { (Get-Date).ToString("yyyy-MM-dd") } else { $dateInput }
    $description = Read-Host "Description"
    
    $script:Data.TimeEntries += @{
        Date = $date
        ProjectKey = $projectKey
        Hours = $hours
        Description = $description
    }
    Save-UnifiedData
    Write-Success "Time entry added."
}

function global:Start-Timer {
    param([string]$ProjectKeyParam, [string]$TaskIdParam)
    Write-Header "Start Timer"
    $projectKey = $ProjectKeyParam
    if (-not $projectKey) {
        Show-ProjectsAndTemplates -Simple
        $projectKey = Read-Host "`nProject/Template Key"
    }
    if (-not (Get-ProjectOrTemplate $projectKey)) {
        Write-Error "Invalid project or template key."
        return
    }
    if ($script:Data.ActiveTimers.ContainsKey($projectKey)) {
        Write-Warning "A timer is already running for '$projectKey'."
        return
    }
    $script:Data.ActiveTimers[$projectKey] = @{
        StartTime = Get-Date
        TaskId = $TaskIdParam
    }
    Save-UnifiedData
    Write-Success "Timer started for '$projectKey'."
}

function global:Stop-Timer {
    Write-Header "Stop Timer"
    if ($script:Data.ActiveTimers.Count -eq 0) {
        Write-Info "No active timers to stop."
        return
    }
    
    $keys = @($script:Data.ActiveTimers.Keys)
    $options = $keys | ForEach-Object {
        $project = Get-ProjectOrTemplate $_
        "$($project.Name) ($_)"
    }
    $options += "Stop ALL Timers"
    
    $choice = Show-MenuSelection -Title "Select Timer to Stop" -Options $options
    if (-not $choice) { Write-Info "Stop timer cancelled."; return }
    
    if ($choice -eq "Stop ALL Timers") {
        foreach ($key in $keys) {
            Stop-SingleTimer -Key $key
        }
    } else {
        $keyToStop = ($choice -split ' ')[-1].Trim('()')
        Stop-SingleTimer -Key $keyToStop
    }
}

function global:Stop-SingleTimer {
    param([string]$Key, [switch]$Silent)
    
    $timer = $script:Data.ActiveTimers[$Key]
    if (-not $timer) { return }
    
    $endTime = Get-Date
    $elapsed = $endTime - $timer.StartTime
    $hours = [Math]::Round($elapsed.TotalHours, 2)
    
    if (-not $Silent) {
        $description = Read-Host "Description for this time entry"
        $script:Data.TimeEntries += @{
            Date = $endTime.ToString("yyyy-MM-dd")
            ProjectKey = $Key
            Hours = $hours
            Description = $description
        }
    } else {
         $script:Data.TimeEntries += @{
            Date = $endTime.ToString("yyyy-MM-dd")
            ProjectKey = $Key
            Hours = $hours
            Description = "Timer stopped on exit"
        }
    }
    
    # If linked to a task, update time spent
    if ($timer.TaskId) {
        $task = $script:Data.Tasks | Where-Object { $_.Id -eq $timer.TaskId } | Select-Object -First 1
        if ($task) {
            $task.TimeSpent = [double]$task.TimeSpent + $hours
        }
    }

    $script:Data.ActiveTimers.Remove($Key)
    Save-UnifiedData
    if (-not $Silent) { Write-Success "Timer for '$Key' stopped. Logged $hours hours." }
}

function global:Show-ActiveTimers {
    Write-Header "Active Timers"
    if ($script:Data.ActiveTimers.Count -eq 0) {
        Write-Info "No timers are currently running."
        return
    }
    foreach ($timerEnum in $script:Data.ActiveTimers.GetEnumerator()) {
        $project = Get-ProjectOrTemplate $timerEnum.Key
        $elapsed = (Get-Date) - $timerEnum.Value.StartTime
        Write-Host "  $($project.Name) ($($timerEnum.Key)) - $($elapsed.ToString('hh\:mm\:ss'))" -ForegroundColor (Get-LegacyColor (Get-ThemeProperty "Palette.InfoFG"))
    }
}

function global:Quick-TimeEntry {
    # Placeholder for future implementation
    Write-Warning "Quick Time Entry not yet implemented."
}

function global:Edit-TimeEntry {
    # Placeholder for future implementation
    Write-Warning "Edit Time Entry not yet implemented."
}

function global:Delete-TimeEntry {
    # Placeholder for future implementation
    Write-Warning "Delete Time Entry not yet implemented."
}

function global:Show-TodayTimeLog {
    # Placeholder for future implementation
    Write-Warning "Today's Full Time Log not yet implemented."
}

function global:Export-FormattedTimesheet {
    # Placeholder for future implementation
    Write-Warning "Export Formatted Timesheet not yet implemented."
}

function global:Show-WeekReport {
    # Placeholder for future implementation
    Write-Warning "Week Report not yet implemented."
}

function global:Show-ExtendedReport {
    # Placeholder for future implementation
    Write-Warning "Extended Week Report not yet implemented."
}

function global:Show-MonthSummary {
    # Placeholder for future implementation
    Write-Warning "Month Summary Report not yet implemented."
}

function global:Show-TimeAnalytics {
    # Placeholder for future implementation
    Write-Warning "Time Analytics not yet implemented."
}

function global:Export-AllData {
    # Placeholder for future implementation
    Write-Warning "Export All Data not yet implemented."
}

function global:Edit-TimeTrackingSettings {
    # Placeholder for future implementation
    Write-Warning "Edit Time Tracking Settings not yet implemented."
}
```